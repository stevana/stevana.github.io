<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>Stevan's notes – Towards human-readable binary encodings</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="index.html">Stevan's notes...</a></span>
    <a href="about.html">About</a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>Towards human-readable binary encodings</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#erlangs-bit-syntax" id="toc-erlangs-bit-syntax">Erlang’s
bit syntax</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#how-it-works" id="toc-how-it-works">How it works</a></li>
<li><a href="#extending-erlangs-bit-syntax"
id="toc-extending-erlangs-bit-syntax">Extending Erlang’s bit syntax</a>
<ul>
<li><a href="#in-place-updates" id="toc-in-place-updates">In-place
updates</a></li>
<li><a href="#on-disk-data-structures"
id="toc-on-disk-data-structures">On-disk data structures</a></li>
<li><a href="#zero-copy" id="toc-zero-copy">Zero-copy</a></li>
<li><a href="#backward--and-forward-compatiability-and-migrations"
id="toc-backward--and-forward-compatiability-and-migrations">Backward-
and forward-compatiability and migrations</a></li>
<li><a href="#compression" id="toc-compression">Compression</a></li>
<li><a href="#checksums" id="toc-checksums">Checksums</a></li>
<li><a href="#validation" id="toc-validation">Validation</a></li>
<li><a href="#protocols" id="toc-protocols">Protocols</a></li>
<li><a href="#pandoc-for-binary-encodings"
id="toc-pandoc-for-binary-encodings">Pandoc for binary
encodings</a></li>
</ul></li>
<li><a href="#discussion" id="toc-discussion">Discussion</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
</ul>
</nav>
<p>Can we make binary encodings “human-readable”? This post explores
this question by means of implementing a library inspired by Erlang’s
bit syntax.</p>
<h2 id="motivation">Motivation</h2>
<p>JSON is probably the most commonly used format for serialising data
today. A frequent argument for using it is that JSON is
human-readable.</p>
<p>What does that mean exactly? I suppose that people usually mean two
things. First, it’s less verbose than XML, making it easier to read.
Most people would probably still call XML human-readable, but arguebly
less so than JSON. Second, it’s easier to read than binary encodings
produced by MessagePack, ASN.1 or Protobuf, etc. For example, the JSON
string <code>"foo"</code> is represented by the following byte sequence
when using MessagePack:</p>
<pre><code>                 +------------ A string of length 3 consisting of ...
                 |  +--------- ... the character &#39;f&#39;, following by ...
                 |  |  +--+--- ... two &#39;o&#39; characters.
                 |  |  |  |
                 v  v  v  v
                 a3 66 6f 6f</code></pre>
<p>If we were to open a file with the above bytes or echo them to the
terminal we’d see <code>£foo</code>. Which, while one character
shorter<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> than the JSON string, is starting to
become unreadable already and it will become worse once the JSON object
is more complicated.</p>
<p>It’s worth noting that all serialised data ends up being bytes once
on disk or sent over the network. So in a sense one could argue that the
reason JSON is human-readable, is because these bytes get displayed as
ASCII or UTF-8 by our editors and the standard terminal utilities.
Another way to think about it is that ASCII and UTF-8 are encodings as
well, which would be unreadable without tool support. This isn’t a new
argument, people like <a
href="https://youtu.be/ieEaaofM7uU?list=PL_aCdZH3eJJVki0YqHbJtqZKSmcbXH0jP&amp;t=28">Joe
Armstrong</a> and <a href="https://youtu.be/qDhTjE0XmkE?t=2280">Martin
Thompson</a> have separately and on <a
href="https://youtu.be/rQIE22e0cW8?t=2003">multiple</a> occasions
pointed this out. Both stress that we are <a
href="https://youtu.be/bzDAYlpSbrM?t=1481">wasting</a> massive amounts
of CPU cycles on parsing JSON.</p>
<p>It’s not just that it’s less space efficient, as we saw with
<code>"foo"</code> vs <code>£foo</code>, it’s also because with JSON we
need to inspect every single character after the first <code>"</code> in
order to determine when the string ends, i.e. finding the closing
<code>"</code>. Whereas in, for example, the MessagePack case the length
of the string is encoded in the <code>a3</code> byte so we can jump
forward and just copy the three bytes (without looking at them). Joe
calls this <em>reconstructing</em> as opposed to parsing.</p>
<p>So if JSON is merely human-readable because of our application-level
tooling, this raises the question: what would it take to make binary
encodings “human-readable”?</p>
<p>For starters I think we’d need to make it easier to work with binary
data in our programming languages. I believe Erlang’s bit syntax, which
lets us do bit-level pattern-matching, is a good example of what better
language support for working with binary data looks like. Even though
Erlang’s way ahead most programming languages on this front, there are
important use cases which are not possible to express efficiently using
bit syntax though, e.g. in-place updates, leaving more to be
desired.</p>
<p>In the rest of this post we’ll have first have a look at how Erlang’s
bit syntax works, then we’ll turn to its shortcomings and try to start
addressing them by means of implementing a library.</p>
<h2 id="erlangs-bit-syntax">Erlang’s bit syntax</h2>
<p>Erlang has a feature called bit syntax which allows the user to
encode and decode data at the bit-level. Here’s an example, where we
encode three integers into two bytes:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="op">&gt;</span>​ <span class="va">Red</span> <span class="op">=</span> <span class="dv">2</span><span class="fu">.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span><span class="op">&gt;</span>​ <span class="va">Green</span> <span class="op">=</span> <span class="dv">61</span><span class="fu">.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dv">61</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span><span class="op">&gt;</span>​ <span class="va">Blue</span> <span class="op">=</span> <span class="dv">20</span><span class="fu">.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span><span class="op">&gt;</span>​ <span class="va">Mem</span> <span class="op">=</span> <span class="op">&lt;&lt;</span><span class="va">Red</span><span class="fu">:</span><span class="dv">5</span><span class="fu">,</span> <span class="va">Green</span><span class="fu">:</span><span class="dv">6</span><span class="fu">,</span> <span class="va">Blue</span><span class="fu">:</span><span class="dv">5</span><span class="op">&gt;&gt;</span><span class="fu">.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="dv">23</span><span class="fu">,</span><span class="dv">180</span><span class="op">&gt;&gt;</span></span></code></pre></div>
<p>Normally, even the smallest integer takes up one byte
(e.g. <code>char</code> in C or <code>Int8</code> in Haskell) but
Erlang’s bit syntax lets us encode, e.g., <code>Red</code> using only 5
bits (rather than the default 8 bits) and thus we can fit all three
integers in <span class="math inline">5 + 6 + 5 = 16</span> bits or two
bytes.</p>
<p>We can also pattern match at the bit-level using sizes to get our
integers back:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span><span class="op">&gt;</span>​ <span class="op">&lt;&lt;</span><span class="va">R1</span><span class="fu">:</span><span class="dv">5</span><span class="fu">,</span> <span class="va">G1</span><span class="fu">:</span><span class="dv">6</span><span class="fu">,</span> <span class="va">B1</span><span class="fu">:</span><span class="dv">5</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="va">Mem</span><span class="fu">.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="dv">23</span><span class="fu">,</span><span class="dv">180</span><span class="op">&gt;&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span><span class="op">&gt;</span>​ <span class="va">R1</span><span class="fu">.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dv">7</span><span class="op">&gt;</span>​ <span class="va">G1</span><span class="fu">.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dv">61</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span><span class="op">&gt;</span>​ <span class="va">B1</span><span class="fu">.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span></span></code></pre></div>
<p>For larger integer types, e.g. <code>0x12345678 :: Int32</code>, we
can also specify the byte order or <a
href="https://en.wikipedia.org/wiki/Endianness">endianness</a>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="op">&gt;</span>​ <span class="fu">{</span><span class="op">&lt;&lt;</span><span class="bn">16#12345678</span><span class="fu">:</span><span class="dv">32</span><span class="op">/</span><span class="ch">big</span><span class="op">&gt;&gt;</span><span class="fu">,</span><span class="op">&lt;&lt;</span><span class="bn">16#12345678</span><span class="fu">:</span><span class="dv">32</span><span class="op">/</span><span class="ch">little</span><span class="op">&gt;&gt;</span><span class="fu">,</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>​<span class="op">&lt;&lt;</span><span class="bn">16#12345678</span><span class="fu">:</span><span class="dv">32</span><span class="op">/</span><span class="ch">native</span><span class="op">&gt;&gt;</span><span class="fu">,</span><span class="op">&lt;&lt;</span><span class="bn">16#12345678</span><span class="fu">:</span><span class="dv">32</span><span class="op">&gt;&gt;</span><span class="fu">}.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span><span class="op">&lt;&lt;</span><span class="dv">18</span><span class="fu">,</span><span class="dv">52</span><span class="fu">,</span><span class="dv">86</span><span class="fu">,</span><span class="dv">120</span><span class="op">&gt;&gt;</span><span class="fu">,</span><span class="op">&lt;&lt;</span><span class="dv">120</span><span class="fu">,</span><span class="dv">86</span><span class="fu">,</span><span class="dv">52</span><span class="fu">,</span><span class="dv">18</span><span class="op">&gt;&gt;</span><span class="fu">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="dv">120</span><span class="fu">,</span><span class="dv">86</span><span class="fu">,</span><span class="dv">52</span><span class="fu">,</span><span class="dv">18</span><span class="op">&gt;&gt;</span><span class="fu">,</span><span class="op">&lt;&lt;</span><span class="dv">18</span><span class="fu">,</span><span class="dv">52</span><span class="fu">,</span><span class="dv">86</span><span class="fu">,</span><span class="dv">120</span><span class="op">&gt;&gt;</span><span class="fu">}</span></span></code></pre></div>
<p>For a slightly larger example, here’s pattern-matching on an IP
datagram of IP protocol version 4:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">-define</span>​<span class="fu">(</span><span class="va">IP_VERSION</span><span class="fu">,</span> <span class="dv">4</span><span class="fu">).</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>​<span class="op">-</span><span class="ch">define</span>​<span class="fu">(</span><span class="va">IP_MIN_HDR_LEN</span><span class="fu">,</span> <span class="dv">5</span><span class="fu">).</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">...</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="va">DgramSize</span> <span class="op">=</span> ​<span class="ch">byte_size</span>​<span class="fu">(</span><span class="va">Dgram</span><span class="fu">),</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>​<span class="ch">case</span>​ <span class="va">Dgram</span> ​<span class="ch">of</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;&lt;</span><span class="fu">?</span><span class="va">IP_VERSION</span><span class="fu">:</span><span class="dv">4</span><span class="fu">,</span> <span class="va">HLen</span><span class="fu">:</span><span class="dv">4</span><span class="fu">,</span> <span class="va">SrvcType</span><span class="fu">:</span><span class="dv">8</span><span class="fu">,</span> <span class="va">TotLen</span><span class="fu">:</span><span class="dv">16</span><span class="fu">,</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">ID</span><span class="fu">:</span><span class="dv">16</span><span class="fu">,</span> <span class="va">Flags</span><span class="fu">:</span><span class="dv">3</span><span class="fu">,</span> <span class="va">FragOff</span><span class="fu">:</span><span class="dv">13</span><span class="fu">,</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">TTL</span><span class="fu">:</span><span class="dv">8</span><span class="fu">,</span> <span class="va">Proto</span><span class="fu">:</span><span class="dv">8</span><span class="fu">,</span> <span class="va">HdrChkSum</span><span class="fu">:</span><span class="dv">16</span><span class="fu">,</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">SrcIP</span><span class="fu">:</span><span class="dv">32</span><span class="fu">,</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="va">DestIP</span><span class="fu">:</span><span class="dv">32</span><span class="fu">,</span> <span class="va">RestDgram</span><span class="op">/</span><span class="ch">binary</span><span class="op">&gt;&gt;</span> ​<span class="ch">when</span>​ <span class="va">HLen</span> <span class="op">&gt;=</span> <span class="dv">5</span><span class="fu">,</span> <span class="dv">4</span><span class="op">*</span><span class="va">HLen</span> <span class="op">=&lt;</span> <span class="va">DgramSize</span> <span class="op">-&gt;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">OptsLen</span> <span class="op">=</span> <span class="dv">4</span><span class="op">*</span><span class="fu">(</span><span class="va">HLen</span> <span class="op">-</span> <span class="fu">?</span><span class="va">IP_MIN_HDR_LEN</span><span class="fu">),</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span><span class="va">Opts</span><span class="fu">:</span><span class="va">OptsLen</span><span class="op">/</span><span class="ch">binary</span><span class="fu">,</span><span class="va">Data</span><span class="op">/</span><span class="ch">binary</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="va">RestDgram</span><span class="fu">,</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">...</span></span></code></pre></div>
<p>Note how we can match on the header length, <code>HLen</code>, and
later use the value of that match as the size when pattern matching on
later values.</p>
<h2 id="usage">Usage</h2>
<p>We can implement a library that lets us do similar things to Erlang’s
bit syntax, but in a more clunky way (it’s difficult to beat native
syntax support).</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">BitsAndBobs</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  pattern0    <span class="ot">=</span> sized word32 <span class="dv">5</span> <span class="op">:::</span> sized word32 <span class="dv">6</span> <span class="op">:::</span> sized word32 <span class="dv">5</span> <span class="op">:::</span> <span class="dt">Nil</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  bytestring0 <span class="ot">=</span> byteString [<span class="dv">2</span> <span class="op">:.</span> sized word32 <span class="dv">5</span>, <span class="dv">61</span> <span class="op">:.</span> sized word32 <span class="dv">6</span>, <span class="dv">20</span> <span class="op">:.</span> sized word32 <span class="dv">5</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>bitMatch pattern0 bytestring0</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- =&gt; (2,(61,(20,())))</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  pattern1    <span class="ot">=</span> word8 <span class="op">:&gt;&gt;=</span> \sz <span class="ot">-&gt;</span> sized bytes sz <span class="op">:::</span> bytes <span class="op">:::</span> <span class="dt">Nil</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  bytestring1 <span class="ot">=</span> byteString [<span class="dv">5</span> <span class="op">:.</span> word8, <span class="st">&quot;hello, rest&quot;</span> <span class="op">:.</span> bytes]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>bitMatch pattern1 bytestring1</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- =&gt; (5,(&quot;hello&quot;,(&quot;, rest&quot;,())))</span></span></code></pre></div>
<p>The above is <a
href="https://github.com/stevana/bits-and-bobs/blob/main/src/BitsAndBobs.hs">implemented</a>
in Haskell, but should be straightforward to port to most languages
using the following recipe.</p>
<h2 id="how-it-works">How it works</h2>
<p>The high-level idea when encoding a bunch of, possibly sized, values
into a <code>ByteString</code> is as follows:</p>
<ol type="1">
<li>For each value convert the value into a list of booleans (or
bits);</li>
<li>If the value is sized then only take that many bits, otherwise if it
isn’t sized use the default value, e.g. <code>Int8</code> = 8 bits,
<code>Float</code> = 32 bits, etc;</li>
<li>Concatenate the lists of booleans for each value into a single list
of booleans;</li>
<li>Split the list in groups of 8 bits;</li>
<li>Convert each 8 bits into a byte (<code>UInt8</code>);</li>
<li>Create a <code>ByteString</code> from list of
<code>UInt8</code>s.</li>
</ol>
<p>For decoding or pattern-matching a, possibly sized, pattern against a
<code>ByteString</code> the idea is:</p>
<ol type="1">
<li>Convert <code>ByteString</code> into list of booleans (or
bits);</li>
<li>For each pattern take its size many bits from the list;</li>
<li>Convert the bits into the value type of the pattern;</li>
<li>Continue matching the remaining patterns against the remaining
bits.</li>
</ol>
<p><code>Float</code> and <code>Double</code>s get converted into
<code>UInt32</code> and <code>UInt64</code> respectively before
converted into bits, and <code>Int</code>egers are encoding using <a
href="https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding">zigzag</a>
encoding<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<h2 id="extending-erlangs-bit-syntax">Extending Erlang’s bit syntax</h2>
<p>Erlang’s bit syntax makes it possible to decode binary data into the
host languague’s types, which can then be manipulated, and finally
encoded back to binary.</p>
<p>While already useful, it doesn’t cover some interesting use cases.
Let me try to explain the use cases and at the same time sketch possible
ways we can extend Erlang’s bit syntax to cover those.</p>
<h3 id="in-place-updates">In-place updates</h3>
<p>What if we merely want to update some binary in-place without reading
it all in and writing it all back out?</p>
<p>For example, the de facto standard for metadata format for mp3 files
is called <a href="https://en.wikipedia.org/wiki/ID3">ID3</a>. This was
never part of the mp3 specification, but rather added afterwards and so
in order to not break backwards-compatibility with old media players
they added it at the end of the file.</p>
<p>Lets imagine we wanted to write a metadata editor for mp3 files using
Erlang’s bit syntax. I think no matter how smart the Erlang run-time is
about bit syntax, it’s hard to imagine that it wouldn’t need to
deserialse and serialise more data than necessary. Worst case it would
deserialise all of the audio that leads up to where the metadata starts,
but even if it’s somehow clever and starts from the back then we’d still
probably need to at least deserialise all fields preceding the field we
want to update.</p>
<p>Inspired by this problem and how tools like <a
href="https://jemarch.net/poke"><code>poke</code></a> work, I’ve started
another experiment based on <code>Schema</code>s with this use case in
mind, here’s an example session of editing the metadata of an mp3
file:</p>
<pre><code>$ cabal run mp3 -- /tmp/test.mp3

mp3&gt; help
schema | read &lt;field&gt; | write &lt;field&gt; &lt;value&gt; | list | q(uit)

mp3&gt; schema
audio   : Binary
header  : Magic &quot;TAG&quot;
title   : ByteString (Fixed 30)
artist  : ByteString (Fixed 30)
album   : ByteString (Fixed 30)
year    : ByteString (Fixed 4)
comment : ByteString (Fixed 30)
genre   : UInt8

mp3&gt; read title
Unknown

mp3&gt; write title &quot;Bits and Bobs&quot;

mp3&gt; read title
Bits and Bobs

mp3&gt; list
Right (Id3V1 {title = &quot;Bits and Bobs&quot;, artist = &quot;&quot;, album = &quot;&quot;, year = &quot;2023&quot;, comment = &quot;&quot;})
mp3&gt; quit</code></pre>
<p>The user needs to specify the <code>Schema</code>, which is closely
mapped to the ID3v1 specficiation and the rest is provided by the
library. In particular all the offsets to the different fields are
calculated from the schema<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a>, which allow us to jump
straight to the field of interest and <em>reconstruct</em> it without
parsing. The above interactive <a href="app/Main.hs">editor</a> is
completely <a href="src/BitsAndBobs/Editor.hs">generic</a> and works for
any <code>Schema</code>!</p>
<p>If we can read and update fields, it should also be possible to get
<a
href="https://youtu.be/MUb8rD5mPvE?list=PLTj8twuHdQz-JcX7k6eOwyVPDB8CyfZc8&amp;t=830">diffs</a>
and patches for cheap.</p>
<h3 id="on-disk-data-structures">On-disk data structures</h3>
<p>Now that we can edit files in-place on the disk it would be nice to
use this in order to implement on-disk data structures. For example
imagine we’d like to do some kind of logging. If our schemas could
express arrays and records we could define our log to be an a struct
with a length field and an array of records field that of size length.
In addition to extending the schema with arrays and records, we’d also
need atomic increments of the length field so that we can in a
thread-safe manner allocate space in our array. B-trees or <a
href="https://github.com/real-logic/aeron">Aeron’s</a> <a
href="https://aeroncookbook.com/aeron/log-buffers-images/">log
buffers</a> would be other interesting on-disk data structures to
implement.</p>
<p>The generic editor would be useful for debugging and manipulating
such data structures, but we’d probably want more tooling. For logging
we probably want something like <code>cat</code> and <code>grep</code>
but generic in <code>Schema</code>.</p>
<h3 id="zero-copy">Zero-copy</h3>
<p>When we <code>read</code> a <code>ByteString</code> field in the mp3
metadata example above, we copied the bytes from the underlying file.
Sometimes we might want to avoid doing that.</p>
<p>For example imagine we are implementing some network protocol. We can
use a pre-allocated buffer and <a
href="https://linux.die.net/man/2/recv"><code>recv</code></a> bytes from
a socket into this buffer (avoiding allocating memory while handling
requests), once the request is inside our buffer we can decode
individual fields (without parsing) and from that we can determine what
kind of request it is. Let’s imagine it’s some kind of write request
where we want to save the payload of some field to disk. It would be a
waste to copy the bytestring of the payload only to write it disk
immediately after, since the network request consists of raw bytes and
that’s what we want to write to the disk anyway. Instead we’d like to be
able to decode the payload field as a pointer/slice of the buffer which
we pass to <a
href="https://linux.die.net/man/2/write"><code>write</code></a> (thus
avoiding copying aka “zero-copy”).</p>
<h3 id="backward--and-forward-compatiability-and-migrations">Backward-
and forward-compatiability and migrations</h3>
<p>Another big topic is schema evolution. How can we maintain backward-
and forward-compatibility as our software evolves? We probably want to
be able to migrate old formats into newer ones somehow also.</p>
<h3 id="compression">Compression</h3>
<p>Currently our schemas cannot express how to compress fields on disk,
or how to avoid sending unnecessary data in consecutive network
messages.</p>
<p>An example of the former might be to compress a bytestring field,
using say <a href="https://en.wikipedia.org/wiki/Deflate">deflate</a>,
before writing it to disk. While an example of the former might be to
only send the difference or change of some integer field, instead of
sending the whole integer again. To make things more concrete, lets say
the integer represents epoch time and we send messages several times per
second, then by only sending the difference or <a
href="https://en.wikipedia.org/wiki/Delta_encoding">delta</a> in time
since the last message we can save space. Other examples of compression
include <a
href="https://en.wikipedia.org/wiki/Dictionary_coder">dictionary</a>
compression, <a
href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length
encoding</a>, <a
href="https://en.wikipedia.org/wiki/Apache_Parquet#Bit_packing">bit
packing</a> and <a
href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman
coding</a>.</p>
<p>It would be neat if encoding and decoding fields could be done modulo
compression! Likewise the schema-based <code>cat</code> and
<code>grep</code> could also work modulo compression.</p>
<p>A related topic is storing our data in a row-based or columnar
fashion. Take the example of a logging library we discussed earlier with
a schema that’s an array of records, i.e. each log call adds a new
record to the array. This is nice in terms of writing efficiency, but if
we wanted to do a lot of grepping or some aggregation on some field in
the record then we’d have to jump around a lot in the file (jumping over
the other fields that we are not interested in). It could be more
efficient to restructure our data into a record of arrays instead, where
each array only has data from one field, that way searching or
aggregating over that field would be much more efficient (no jumping
around). Some compression is also a lot easier to apply on columnar
data, e.g. delta and run-length encoding. Perhaps it would make sense if
the schema-based tools could do such data transformations in order to
optimise for reads or archiving?</p>
<h3 id="checksums">Checksums</h3>
<p>If we can do encoding and decoding fields modulo compression, why not
also handle checksums transparently? When we update a field which is
part of a checksum, we’d probably want to check the checksum beforehand
and recompute it afterwards.</p>
<h3 id="validation">Validation</h3>
<p>What if some input bytes don’t match the schema? Currently all magic
tags in a schema get verified, but sometimes we might want to be able to
edit incomplete or malformed inputs.</p>
<p>Can we add refinements to the schema which allow us to express things
like, integer between 18 and 150 or bytestring containing only
alphanumeric characters, etc?</p>
<h3 id="protocols">Protocols</h3>
<p>So far we’ve looked at how to specify what data our programs use and
how it’s transformed to and from bytes on disk or over the network.
Another important aspect is what protocol is followed when said data is
sent between components in the system.</p>
<p>For example consider some client-server application where our schema
describes the request and responses:</p>
<pre class="mermaid"><code>flowchart LR
    Client -- request --&gt; Server
    Server -- response --&gt; Client</code></pre>
<p>The schema doesn’t say anything about in which order requests are
legal. For example, we might want to always requrie a login-like request
at the start of a session. Or let’s say we are describing a POSIX-like
filesystem API, then <code>read</code>s and <code>write</code>s must
only be made on <code>open</code> (and not yet <code>close</code>d) file
descriptors.</p>
<p>Joe Armstrong wrote a paper called <a
href="https://erlang.org/workshop/2002/Armstrong.pdf"><em>Getting Erlang
to talk to the outside world</em></a> (2002) which discusses this
problem. He proposed a language for describing protocols and a dynamic
sessions type checker, it never seemed to have got much traction though
even though he gave several <a
href="https://youtu.be/ed7A7r6DBsM?t=1071">talks</a> about it. One
implementation can be found <a
href="https://ubf.github.io/ubf/ubf-user-guide.en.html">here</a>.</p>
<h3 id="pandoc-for-binary-encodings">Pandoc for binary encodings</h3>
<p>There’s this neat tool called <a
href="https://github.com/jgm/pandoc"><code>pandoc</code></a> that makes
possible to convert between different text formats, e.g. from Markdown
to HTML.</p>
<p>The list of supported formats to convert from and to is pretty long.
If we were to convert to and from each pair of possibilities would
require <span
class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span> <a
href="https://youtu.be/ed7A7r6DBsM?t=2311">work</a>. So what
<code>pandoc</code> does instead is to convert each format to and from
its internal abstract representation, thereby reducing the problem to
<span class="math inline"><em>O</em>(<em>N</em>)</span>.</p>
<p>Could we do something similar for binary encodings?</p>
<p>In the book <em>Development and Deployment of Multiplayer Online
Games, Vol. I</em> by Sergey Ignatchenko (pp. 259-285, 2017) the author
talks about how most <a
href="https://en.wikipedia.org/wiki/Interface_description_language">IDLs</a>,
e.g. Protobufs, have the same language for describing <em>what</em> the
abstract data which we want to serialise and <em>how</em> we actually
want the data to be serialised. By separating the two, we could change
the binary format “on the wire” without changing the application which
operates on the abstract data (the <em>what</em> part). A clearer
separation between IDL and its encoding could perhaps be useful when
trying to solve the <code>pandoc</code> problem for binary.</p>
<p>Another way to think of this is: can we make a DSL for IDLs?</p>
<h2 id="discussion">Discussion</h2>
<ul>
<li><p>Q: Why not just use <a
href="https://en.wikipedia.org/wiki/Protocol_Buffers">Protobuf</a>?</p>
<p>A: Except for backward- and forward-compatibility, I don’t think
Protobufs can handle any of the above listed use cases. Also the way it
handles compatibility with it’s numbered and optional fields is quite
ugly<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p></li>
<li><p>Q: Writing safely to disk without going via a database is almost
impossible!?</p>
<p>A: Dan Luu has <a
href="https://danluu.com/deconstruct-files/">written</a> about <a
href="https://danluu.com/fsyncgate/">this</a> on several <a
href="https://danluu.com/file-consistency/">occasions</a>. Short answer:
don’t store anything you are worried about losing using this library.
Longer answer: I’d like to revisit this topic from the point of view of
testing at some later point in time. In particular I’m interested in how
we can make the results from the paper <a
href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/pillai"><em>All
File Systems Are Not Created Equal: On the Complexity of Crafting
Crash-Consistent Applications</em></a></p>
<ol start="2014" type="1">
<li>more accessible, especially their tool <a
href="https://github.com/madthanu/alice"><em>ALICE: Application-Level
Intelligent Crash Explorer</em></a>.</li>
</ol></li>
</ul>
<h2 id="contributing">Contributing</h2>
<p>The current implementation is in Haskell, but I’d really like to
encourage a discussion beyond specific languages. In order to make
binary “human-readable” we need solutions that are universal, i.e. work
in any language, or perhaps better yet than libraries – extend
programming languages with something like Erlang’s bit syntax.</p>
<ul>
<li>Do you have use cases that are not listed above?</li>
<li>Do you know of tools, libraries or solutions any of the above use
cases that have already not been discussed or are not listed below in
the “see also” section?</li>
<li>Do you know if some use cases impossible in general or incompatible
with each other?</li>
<li>Interested in porting any of these ideas to your favorite
language?</li>
</ul>
<p>If so, feel free to get in touch!</p>
<h2 id="see-also">See also</h2>
<ul>
<li>The Erlang reference manual on <a
href="https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax">bit
syntax</a>;</li>
<li>Programming examples of bit syntax from the Erlang <a
href="https://www.erlang.org/doc/programming_examples/bit_syntax.html">user’s
guide</a>;</li>
<li>Joe Armstrong’s PhD <a
href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-1166">thesis</a>
<ol start="2003" type="1">
<li>also has a section on bit syntax on p. 60;</li>
</ol></li>
<li><a href="https://erlang.org/workshop/2002/Gustafsson.pdf">Native
Code Compilation of Erlang’s Bit Syntax</a> (2002);</li>
<li><a href="https://capnproto.org/">Cap’n Proto</a>;</li>
<li>Simple Binary Encoding (<a
href="https://github.com/real-logic/simple-binary-encoding">SBE</a>) by
Martin Thompson et al;</li>
<li>GNU <a href="https://jemarch.net/poke">poke</a>, extensible editor
for structured binary data;</li>
<li><a href="https://github.com/wader/fq">fq: jq for binary formats</a>
also described in this <a
href="https://www.youtube.com/watch?v=GJOq_b0eb-s&amp;list=PLTj8twuHdQz-JcX7k6eOwyVPDB8CyfZc8&amp;index=1">talk</a>;</li>
<li><a href="https://github.com/antonmedv/fx">Terminal JSON
viewer</a>;</li>
<li>Rust’s <a href="https://github.com/jam1garner/binrw">binrw</a>
crate;</li>
<li><em>Designing Data-Intensive Applications</em> by Martin Kleppmann
(chapter 3-4, 2017);</li>
<li><em>Development and Deployment of Multiplayer Online Games, Vol.
I</em> by Sergey Ignatchenko (pp. 200-216 and 259-285, 2017).</li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The savings are greater for more complicated JSON
objects, especially considering JSON doesn’t support binary data which
needs to be either escaped or base64 encoded before used as a string.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I don’t think Erlang uses zig-zag encoding of integers,
in fact I’m not sure what it does with them.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The library tries to calculate the offset of a field
from the start of the file, in this case the beginning of the file
contains an audio binary “field” of unknown length, so it fails and
retries calculating the offset from the end of the file instead.<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Avro has a nicer story for <a
href="https://avro.apache.org/docs/1.11.1/specification/#schema-resolution">compatibility</a>.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
