<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>supervised-state-machines</title>
  <link rel="stylesheet" href="style.css?modified=1727256611" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/deploying_and_restarting_state_machines_using_supervisor_trees.html&t=supervised-state-machines">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About / <span class="work-with-me">Work with me</span></a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>supervised-state-machines</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#how-it-works" id="toc-how-it-works">How it works</a>
<ul>
<li><a href="#generic-server" id="toc-generic-server">Generic
server</a></li>
<li><a href="#supervisor" id="toc-supervisor">Supervisor</a></li>
<li><a href="#event-loop" id="toc-event-loop">Event loop</a></li>
<li><a href="#example" id="toc-example">Example</a></li>
</ul></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
</ul>
</nav>
<div class="date">Posted on Feb 13, 2023</div>
<p>An experimental implementation of Erlang/OTP’s
<code>gen_server</code> and <code>supervisor</code> behaviours that
doesn’t use lightweight threads and message passing.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>What exactly is it that makes Erlang suitable for writing reliable
distributed systems?</p>
<p>I’ve previously <a
href="https://github.com/stevana/armstrong-distributed-systems/blob/main/docs/erlang-is-not-about.md#erlangs-not-about-lightweight-processes-and-message-passing">argued</a>
that it’s Erlang’s <em>behaviours</em> rather than its lightweight
processes and message passing.</p>
<p>Behaviours can be thought of as generic building blocks for building
reliable distributed systems. Erlang/OTP exposes six behaviours and
encourages its users to compose them into bigger systems. The behaviours
are generic in that they are parametrised by interfaces, the idea being
that the user implements the interface in a problem specific way and
then the user gets the generic component from Erlang/OTP. Typically the
interface requires a sequential implementation while the generic
component exposes a concurrent (or thread-safe) API, i.e. behaviours
abstract away the low-level and difficult concurrent code which is
difficult to get right. Joe Armstrong <a
href="https://dl.acm.org/doi/10.1145/1238844.1238850">describes</a> them
as follows:</p>
<blockquote>
<p>Behaviors in Erlang can be thought of as parameterizable higher-order
parallel processes. They represent an extension of conventional
higher-order functions (like map, fold etc) into a concurrent
domain.</p>
</blockquote>
<p>Which I think is a good analogy, as e.g. <code>map</code> and
<code>fold</code> hide the low-level details of <code>for</code>-loops,
although the concurrent details of behaviours are typically more
complicated than manually dealing with index variables.</p>
<p>This repo is an experiment in trying to implement two of these
behaviours, namely <code>gen_server</code> and <code>supervisor</code>,
without using lightweight processes/threads and message passing. I
believe the last part about not using lightweight threads is a design
space that hasn’t been explored much yet. Most programming languages or
libraries seem to start with the assumption that what makes Erlang great
for writing reliable distributed systems is its lightweight threads and
message passing, and they never even get to the point where they steal
the structure of behaviours!</p>
</section>
<section id="how-it-works" class="level2">
<h2><a href="#how-it-works" title="How it works">How it works</a></h2>
<section id="generic-server" class="level3">
<h3><a href="#generic-server" title="Generic server">Generic
server</a></h3>
<p>The sequential semantics (or “business logic”) of a generic server
(<code>gen_server</code>) should take some input and the current state
and produce some output and a new updated state, i.e.:</p>
<pre><code>  input -&gt; state -&gt; (state, output)</code></pre>
<p>Client requests to the server will come in via the network, so we
also need a <code>Codec</code> to be able to decode
<code>ByteString</code>s into <code>input</code>s and encode
<code>output</code>s into <code>ByteString</code>s to be able to reply
to the client. We might also want to deserialise the initial state
<code>state</code> from disk on startup and serialise it to disk on
termination. See the <code>StateMachine</code> <a
href="src/StateMachine.hs">module</a> for the details of the above.</p>
</section>
<section id="supervisor" class="level3">
<h3><a href="#supervisor" title="Supervisor">Supervisor</a></h3>
<p>The job of a supervisor is to monitor its children for failures and
do restarts according to some predetermined restart strategy in case a
failure happens.</p>
<p>Supervisors are organised in trees where generic servers (or more
generally any other worker behaviours) are at the leaves and other
supervisors are at the nodes. Since supervisors trees determine an order
(depth-first) they can be used to deploy a system of generic
servers.</p>
<p>See the <code>Supervisor</code> <a
href="src/Supervisor.hs">module</a> for details.</p>
</section>
<section id="event-loop" class="level3">
<h3><a href="#event-loop" title="Event loop">Event loop</a></h3>
<p>The concurrent part of the generic servers is implemented in the
<code>EventLoop</code> <a href="src/EventLoop.hs">module</a>. The basic
idea is that we concurrently write client request
<code>ByteString</code>s to a concurrent queue and the event loop will
decode the input and <code>step</code> the right server with said input
and respond to the client with the output produce by the server.</p>
<p>The behavior of supervisors is also implemented in the event loop.
Basically we wrap the <code>step</code> function in a <code>try</code>
and <code>catch</code> and in case of failure we do the appropriate
restarts.</p>
</section>
<section id="example" class="level3">
<h3><a href="#example" title="Example">Example</a></h3>
<p>As an example of generic server I’ve implemented a simple key value
store in the <code>Example.KeyValueStore</code> <a
href="src/Example/KeyValueStore.hs">module</a>. In <a
href="app/Main.hs"><code>app/Main.hs</code></a> we start an event loop
with a simple supervisor tree containing the key value store:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">    main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> sup <span class="ot">=</span> <span class="dt">Supervisor</span> <span class="dt">OneForOne</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                  [ <span class="dt">Worker</span> (<span class="st">&quot;kv1&quot;</span>, kvStore)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                  , <span class="dt">Supervisor</span> <span class="dt">RestForOne</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                      [ <span class="dt">Worker</span> (<span class="st">&quot;kv2&quot;</span>, kvStore), <span class="dt">Worker</span> (<span class="st">&quot;kv3&quot;</span>, kvStore) ]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                  ]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>      queue <span class="ot">&lt;-</span> newTBQueueIO <span class="dv">128</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      withEventLoop sup queue <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        call_ <span class="st">&quot;kv2&quot;</span> (<span class="dt">Store</span> <span class="st">&quot;x&quot;</span> <span class="dv">1</span>) queue</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        r0 <span class="ot">&lt;-</span> call <span class="st">&quot;kv2&quot;</span> (<span class="dt">Lookup</span> <span class="st">&quot;x&quot;</span>) queue</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span> r0</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        call_ <span class="st">&quot;kv2&quot;</span> (<span class="dt">Lookup</span> <span class="st">&quot;crash&quot;</span>) queue <span class="co">-- Deliberate bug which causes a crash.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        r1 <span class="ot">&lt;-</span> call <span class="st">&quot;kv2&quot;</span> (<span class="dt">Lookup</span> <span class="st">&quot;x&quot;</span>) queue</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span> r1</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        r2 <span class="ot">&lt;-</span> call <span class="st">&quot;kv2&quot;</span> (<span class="dt">Lookup</span> <span class="st">&quot;y&quot;</span>) queue</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span> r2</span></code></pre></div>
<p>When run with <code>cabal run kv</code> it produces the following
output:</p>
<pre><code>    Calling kv2: Store &quot;x&quot; 1
    KV store starting: kv1
    KV store starting: kv2
    KV store starting: kv3
    Calling kv2: Lookup &quot;x&quot;
    Right &quot;Result (Just 1)&quot;
    Calling kv2: Lookup &quot;crash&quot;
    kv2 threw: divide by zero
    KV store terminating: kv2
    KV store terminating: kv3
    KV store starting: kv2
    KV store starting: kv3
    Calling kv2: Lookup &quot;x&quot;
    Right &quot;Result Nothing&quot;
    Calling kv2: Lookup &quot;y&quot;
    Right &quot;Result Nothing&quot;</code></pre>
</section>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>There are many ways in which this repo can be extended, here are some
ideas:</p>
<ul class="task-list">
<li><input type="checkbox" />Add HTTP endpoint for writing to the event
loop queue. (Hint: see the <code>HttpServer</code> and
<code>EventLoop</code> modules of this <a
href="https://github.com/stevana/coroutine-state-machines">repo</a>));</li>
<li><input type="checkbox" />Save and restore the state of the example
to disk in <code>terminate</code> and <code>init</code>;</li>
<li><input type="checkbox" />Customisable shutdown grace time;</li>
<li><input type="checkbox" />The supervisors itself should fail if its
children have failed too many times within some time interval;</li>
<li><input type="checkbox" />Supervisors should be able to supervise
supervisor trees that are deployed on other computers.</li>
</ul>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li>There are a handful of supervisor implementations in Haskell <a
href="https://hackage.haskell.org/packages/search?terms=supervisor">already</a>,
but I think all of them assume that the children are running on their
own threads.</li>
</ul>
</section>
</main>
</body>
</html>
