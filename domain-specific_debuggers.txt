Motivation

-   General purpose debuggers such as gdb are underused

-   Theory: people who use general purpose debuggers also care about
    memory layout, e.g.:

    -   John Carmack on using debuggers and his old .plan (1998);

    -   Martin Thompson also says “step through your code using a
        debugger”.

-   Possible fix: domain-specific debuggers, that focus on displaying
    your application state at the level of abstraction that you think of
    it, rather than how the programming language that you are using
    happens to lay it out in memory

Idea

-   Assumptions: determinism, state machine
-   Record inputs (and states) in circular buffer, dump to disk/SQLite
    db on error

Examples

Distributed systems

-   TigerbeetleDB’s demo https://youtu.be/w3WYdYyjek4?t=3175
-   https://spritely.institute/news/introducing-a-distributed-debugger-for-goblins-with-time-travel.html

Games

-   Tomorrow Corporation Tech Demo

Optimisations

-   Avoid storing the state in the trace (if deterministic)
-   Avoiding infinite traces via state snapshots
-   Turn off logging (if deterministic)
-   Audit trails

Contributing

-   General purpose formats for states, inputs and outputs against which
    generic debuggers can be written against? Structured JSON? Binary?

See also

-   The history of time traveling debuggers

-   https://werat.dev/blog/what-a-good-debugger-can-do/

-   Mozilla’s rr debugger

-   Visualising application state

-   Command sourcing

-   Jamie Brandon’s post Local state is harmful

    1.  
