<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>Property-based testing stateful systems: a tutorial</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/simulation_testing_using_state_machines.html&t=Property-based testing stateful systems: a tutorial">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About / <span class="work-with-me">Work with me</span></a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>Property-based testing stateful systems: a tutorial</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#structure" id="toc-structure">Structure</a></li>
<li><a href="#table-of-contents" id="toc-table-of-contents">Table of
contents</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#license" id="toc-license">License</a></li>
</ul>
</nav>
<div class="date">Posted on Feb  7, 2023</div>
<p><a
href="https://github.com/stevana/property-based-testing-stateful-systems-tutorial/actions"><img
src="https://github.com/stevana/property-based-testing-stateful-systems-tutorial/workflows/CI/badge.svg"
alt="GitHub CI" /></a> <a
href="https://hackage.haskell.org/package/property-based-testing-stateful-systems-tutorial"><img
src="https://img.shields.io/hackage/v/property-based-testing-stateful-systems-tutorial.svg"
alt="Hackage" /></a></p>
<p>Property-based testing (PBT), i.e. generating random inputs and
checking some property of the output, of pure programs is an established
practice by now. It’s taught in introductory university classes and it’s
part of test suites in industry.</p>
<p>Most real world programs are not pure though, they are stateful.
While it’s often possible to structure your program in such a way that
the impure stuff is done in <code>main</code>, e.g. read the contents of
a file, and then passed on to a pure function, e.g. a parser, it’s not
always possible. Consider a long-running program that interacts with the
filesystem and with other programs over the network, e.g. some kind of
web service or a distributed database. It’s difficult to split such a
program up into doing a little bit of impure stuff at the start, then
hand it over to a pure function (which we can apply PBT on).</p>
<p>Given this it’s perhaps a bit surprising that there are relatively
few resources about applying PBT to stateful systems. This repository is
an attempt to close that gap and try to make PBT stateful systems more
common.</p>
<p>The goals we’d like to achieve are:</p>
<ul>
<li><p>Show how to test stateful (i.e. impure/monadic) programs using
property-based testing;</p></li>
<li><p>Show how we can do concurrent testing to help uncover problems
such as race conditions;</p></li>
<li><p>Show how we can build bigger systems in a modular way by applying
the property-based testing equivalent of integration and contract
tests;</p></li>
<li><p>Show how to use fault injection and so called simulation testing
to “end-to-end” test distributed systems;</p></li>
<li><p>Introduce the reader to related work and open problems in the
area along the way.</p></li>
</ul>
<p>In the interest of brevity, we assume that the reader already
has:</p>
<ul>
<li><p>Enough familiarity with Haskell to be able to read simple
programs, for example if you can follow along in the <em>Learn You a
Haskell for Great Good!</em> <a
href="http://learnyouahaskell.com/chapters">tutorial</a>, then you
should be fine;</p></li>
<li><p>Some experience with property-based testing of non-stateful
(i.e. pure) programs. For example as explained in the official
QuickCheck <a
href="http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html">manual</a>
or in the following <a
href="https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html">tutorial</a>;</p></li>
<li><p>Basic knowledge of state machines (i.e. <a
href="https://en.wikipedia.org/wiki/Mealy_machine">Mealy</a> / <a
href="https://en.wikipedia.org/wiki/Moore_machine">Moore machines</a>
and <a
href="https://en.wikipedia.org/wiki/Finite-state_transducer">transducers</a>).</p></li>
</ul>
<p>Other than that this tutorial is striving to be as self-contained as
possibly as well as accessible to non-Haskell programmers.</p>
<section id="structure" class="level2">
<h2><a href="#structure" title="Structure">Structure</a></h2>
<p>The tutorial is split up into five parts (so far), and each part has
the following structure:</p>
<ul>
<li>Motivation: explains why we are doing what we are about to do;</li>
<li>Plan: how we will do it;</li>
<li>Code: a concrete implementation of the idea (in case you get stuck
when trying to implement it yourself);</li>
<li>Discussion: common questions or objections;</li>
<li>Exercises: things the authors were to lazy to do, but they know how
to;</li>
<li>Problems: things the authors don’t know how to do (yet);</li>
<li>See also: links to further reading about the topic or related
topics;</li>
<li>Summary: the most important take away.</li>
</ul>
<p>The parts build upon each other. We start by modelling and testing a
simple counter using a state machine in part 1, we then reuse the same
state machine model to test the counter for thread-safety using
linearisability in part 2. In part 3 we will implement a queue and a web
service that uses said queue, the state machine model for the queue and
the real implementation of the queue will be contract tested to ensure
that the model is faithful to the implementation, subsequently while
testing the web service we will use the model in place of the real
queue. In part 4 we introduce fault injection to the queue allowing us
to test how the web service performs when its dependency fails. Finally,
in part 5, we combine all the above ideas in what, sometimes is called
simulation testing, to test a distributed system that uses replicated
state machines.</p>
</section>
<section id="table-of-contents" class="level2">
<h2><a href="#table-of-contents" title="Table of contents">Table of
contents</a></h2>
<ol type="1">
<li><a href="./docs/Part01SMTesting.md#readme">State machine
testing</a></li>
<li><a href="./docs/Part02ConcurrentSMTesting.md#readme">Concurrent
state machine testing with linearisability</a></li>
<li><a href="./docs/Part03SMContractTesting.md#readme">Integration tests
against state machine fakes and consumer-driven contract tests for the
fakes</a></li>
<li><a
href="./docs/Part04FaultInjection.md#readme">Fault-injection</a></li>
<li>Simulation testing</li>
</ol>
</section>
<section id="usage" class="level2">
<h2><a href="#usage" title="Usage">Usage</a></h2>
<p>This repository contains literate Haskell code in <code>src</code>.
If you want to interact with it, install <a
href="https://www.haskell.org/ghcup/install/"><code>ghcup</code></a> and
then type <code>cabal repl</code>. Alternatively, if you are using the
<a href="https://nixos.org/download.html"><code>nix</code></a> package
manager, then running <code>nix-shell</code> in the root directory
should give you the right <code>ghc</code> version and all other
dependencies you might need.</p>
<p>The literate code is transformed into markdown using <a
href="https://pandoc.org/"><code>pandoc</code></a> in <a
href="./tools/generate_markdown.sh"><code>tools/generate_markdown.sh</code></a>
and the markdown is put inside the <a
href="./docs"><code>docs</code></a> directory for easier browsing.</p>
<p>The following is a link to the <a
href="./docs/Part01SMTesting.md#readme">first part</a> of the generate
markdown, at the end it will link to the second part and so on. Or you
can use the table of contents above or the <code>docs</code> directory
to jump to desired part straight away.</p>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>Any feedback, suggestions for improvement or questions are most
welcome via the issue tracker!</p>
<p>See the <a
href="./.github/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a> file
for more detailed guidelines regarding contributing.</p>
</section>
<section id="license" class="level2">
<h2><a href="#license" title="License">License</a></h2>
<p>See the <a href="./LICENSE"><code>LICENSE</code></a> file.</p>
</section>
</main>
</body>
</html>
