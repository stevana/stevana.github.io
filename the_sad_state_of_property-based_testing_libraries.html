<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>The sad state of property-based testing libraries</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/the_sad_state_of_property-based_testing_libraries.html&t=The sad state of property-based testing libraries">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About</a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>The sad state of property-based testing libraries</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#the-history-of-property-based-testing"
id="toc-the-history-of-property-based-testing">The history of
property-based testing</a></li>
<li><a href="#a-survey-of-property-based-testing-libraries"
id="toc-a-survey-of-property-based-testing-libraries">A survey of
property-based testing libraries</a></li>
<li><a href="#analysis" id="toc-analysis">Analysis</a>
<ul>
<li><a
href="#why-are-property-based-testing-libraries-in-such-a-sad-state"
id="toc-why-are-property-based-testing-libraries-in-such-a-sad-state">Why
are property-based testing libraries in such a sad state?</a>
<ul>
<li><a
href="#stateful-and-parallel-testing-isnt-as-useful-as-pure-testing"
id="toc-stateful-and-parallel-testing-isnt-as-useful-as-pure-testing">Stateful
and parallel testing isn’t as useful as pure testing</a></li>
<li><a href="#stateful-modelling-requires-training"
id="toc-stateful-modelling-requires-training">Stateful modelling
requires training</a></li>
<li><a href="#closed-source-helps-industry-adoption"
id="toc-closed-source-helps-industry-adoption">Closed source helps
industry adoption</a></li>
</ul></li>
<li><a href="#what-can-we-do-about-it"
id="toc-what-can-we-do-about-it">What can we do about it?</a></li>
</ul></li>
<li><a href="#synthesis" id="toc-synthesis">Synthesis</a>
<ul>
<li><a href="#pure-property-based-testing-recap"
id="toc-pure-property-based-testing-recap">Pure property-based testing
recap</a></li>
<li><a href="#stateful-property-based-testing-in-180-loc"
id="toc-stateful-property-based-testing-in-180-loc">Stateful
property-based testing in ~180 LOC</a>
<ul>
<li><a href="#example-counter" id="toc-example-counter">Example:
counter</a></li>
<li><a href="#stateful-library-implementation"
id="toc-stateful-library-implementation">Stateful library
implementation</a></li>
<li><a href="#example-circular-buffer"
id="toc-example-circular-buffer">Example: circular buffer</a></li>
<li><a href="#example-jug-puzzle-from-die-hard-3"
id="toc-example-jug-puzzle-from-die-hard-3">Example: jug puzzle from Die
Hard 3</a></li>
</ul></li>
<li><a href="#parallel-property-based-testing-in-230-loc"
id="toc-parallel-property-based-testing-in-230-loc">Parallel
property-based testing in ~230 LOC</a>
<ul>
<li><a href="#parallel-library-implementation"
id="toc-parallel-library-implementation">Parallel library
implementation</a></li>
<li><a href="#example-parallel-counter"
id="toc-example-parallel-counter">Example: parallel counter</a></li>
<li><a href="#example-process-registry"
id="toc-example-process-registry">Example: process registry</a></li>
</ul></li>
<li><a href="#integration-testing-with-contract-tested-fakes"
id="toc-integration-testing-with-contract-tested-fakes">Integration
testing with contract tested fakes</a>
<ul>
<li><a href="#example-queue-again" id="toc-example-queue-again">Example:
queue (again)</a></li>
<li><a href="#example-file-system" id="toc-example-file-system">Example:
file system</a></li>
<li><a href="#example-bigger-system-of-components"
id="toc-example-bigger-system-of-components">Example: bigger system of
components</a></li>
</ul></li>
</ul></li>
<li><a href="#conclusion-and-future-work"
id="toc-conclusion-and-future-work">Conclusion and future work</a></li>
<li><a href="#acknowledgments"
id="toc-acknowledgments">Acknowledgments</a></li>
</ul>
</nav>
<div class="date">Posted on Jun 19, 2024</div>
<p><em>Work in progress, please don’t share, but do get
involved!</em></p>
<p>Property-based testing is a rare example of academic research that
has made it to the mainstream in less than 30 years. Under the slogan
“don’t write tests, generate them” property-based testing has gained
support from a diverse group of programming language communities. In
fact, the Wikipedia page of the original property-basted testing Haskell
library, <a
href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a>, lists 57
reimplementations in other languages.</p>
<p>In this post I’d like to survey the most popular property-based
testing implementations and compare them with what used to be the
state-of-the-art fifteen years ago (2009). As the title already gives
away, most of the libraries do not offer their users the most advanced
property-based testing features. In order to best explain what’s missing
and why I think we ended up in this situation, let me start by telling
the brief history of property-based testing.</p>
<h2 id="the-history-of-property-based-testing">The history of
property-based testing</h2>
<p>In Gothenburg, Sweden’s second most populated city, there’s a
university called Chalmers. At the computer science department of
Chalmers there are several research groups, two of which are
particularly relevant to our story – the <em>Functional Programming</em>
group and <em>Programming Logic</em> group. I’ll let you guess what the
former group’s main interest is. The latter group’s mostly concerned
with a branch of functional programming where the type system is
sufficiently expressive that it allows for formal specifications of
programs, sometimes called dependently typed programming or type theory.
Agda is an example of a Haskell-like dependently typed programming
language, that also happens to be mainly developed by the Programming
Logic group. Given the overlap of interest and proximity, researchers at
the department are sometimes part of both groups or at least visit each
others research seminars from time to time.</p>
<p>John Hughes is a long-time member of the Functional Programming
group, who’s also well aware of the research on dependently typed
programming going on in the Programming Logic group. One day in the late
nineties, after having worked hard on finishing something important on
time, John found himself having a week “off”. So, just for fun, he
started experimenting with the idea of testing if a program respects a
formal specification.</p>
<p>Typically in dependently typed programming you use the types to write
the specification and then the program that implements that type is the
formal proof that the program is correct. For example, let’s say you’ve
implemented a list sorting function, the specification typically then is
that the output of the sorting function is ordered, i.e. for any index
<span class="math inline"><em>i</em></span> in your output list the
element at that index must be smaller or equal to the element at index
<span class="math inline"><em>i</em> + 1</span>. Formally proving that a
program is correct with respect to a specification is often as much work
as writing the program in the first place, so merely testing it can
often be a sweet spot where you get some confidence that the
specification is correct, without having to do the proving work. For
example in the sorting example you can simply generate a random input
list and then compare the output of your sorting function with the one
in the standard library (which is likely to be correct). As programs get
more complicated the ratio of effort saved by merely testing, as opposed
to proving, increases. In fact for bigger programs the effort involved
in proving correctness is simply too high for it to be practical (this
is an active area of research). Given all this, I hope that you can
start to see why this idea excited John.</p>
<p>While John was working on this idea, Koen Claessen, another member of
the Functional Programming group, <a
href="https://youtu.be/x4BNj7mVTkw?t=289">stuck his head</a> into John’s
office and asked what he was doing. Koen got excited as well and came
back the next day with his improved version of John’s code. There was
some things that Koen hadn’t thought about, so John iterated on his code
and so it went back and forth for a week until the first implementation
of property-based testing was written and not long afterwards they
published the paper <a
href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf"><em>QuickCheck:
A Lightweight Tool for Random Testing of Haskell Programs</em></a> (ICFP
2000). I think it’s worth stressing the <em>lightweight tool</em> part
from the paper’s title, the complete source code for the <a
href="https://github.com/Rewbert/quickcheck-v1">first version</a> of the
library is included in the appendix of the paper and it’s about 300
lines of code.</p>
<p>Haskell and dependently typed programming languages, like Agda, are
pure functional programming languages, meaning that it’s possible at the
type-level to distinguish whether a function has side-effects or not.
Proofs about functions in Agda, and similar languages, are almost always
only dealing with pure functions. Probably as a result of this, the
first version of QuickCheck can only test pure functions. This
shortcoming was rectified in the follow up paper <a
href="https://www.cse.chalmers.se/~rjmh/Papers/QuickCheckST.ps"><em>Testing
monadic code with QuickCheck</em></a> (2002) by the same authors. It’s
an important extension as it allows us to reason about functions that
use mutable state, file I/O and networking, etc. It also lays the
foundation for being able to test concurrent programs, as we shall see
below.</p>
<p>Around the same time as the second paper was published (2002), John
was applying for a major grant at the Swedish Strategic Research
Foundation. A part of the application process involved pitching in front
of a panel of people from industry. Some person from <a
href="https://en.wikipedia.org/wiki/Ericsson">Ericsson</a> was on the
panel and they were interested in QuickCheck. There was also a serial
entrepreneur on the panel and she encouraged John to start a company,
and the Ericsson person agreed to be a first customer, and so Quviq AB
was founded in 2006<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> by John and Thomas Arts (perhaps
somewhat surprisingly, Koen was never involved in the company).</p>
<p>The first project at Ericsson that Quviq helped out testing was
written in Erlang. Unlike Haskell, Erlang is not a pure functional
programming language and on top of that there’s concurrency everywhere.
So even the second, monadic, version of QuickCheck didn’t turn out to be
ergonomic enough for the job. This is what motivated the closed source
Quviq QuickCheck version written in Erlang, first mentioned in the paper
<a
href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=b268715b8c0bcebe53db857aa2d7a95fbb5c5dbf"><em>Testing
telecoms software with Quviq QuickCheck</em></a> (2006). The main
features of the closed source version that, as we shall see, are still
not found in many open source versions are:</p>
<ol type="1">
<li>Sequential <em>stateful</em> property-based testing using a state
machine model;</li>
<li><em>Parallel</em> testing with race condition detection by reusing
the sequential state machine model.</li>
</ol>
<p>We shall describe how these features work in detail later. For now
let’s just note that <em>stateful</em> testing in its current form was
first mentioned in <a
href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5ae25681ff881430797268c5787d7d9ee6cf542c"><em>QuickCheck
testing for fun and profit</em></a> (2007). This paper also mentions
that it took John four iterations to get the stateful testing design
right, so while the 2006 paper already does mention stateful testing
it’s likely containing one of those earlier iteration of it.</p>
<p>While the 2007 paper also mentions <em>parallel</em> testing via
traces and interleavings, it’s vague on details. It’s only later in <a
href="https://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf"><em>Finding
Race Conditions in Erlang with QuickCheck and PULSE</em></a> (ICFP 2009)
that parallel testing is described in detail including a reference to <a
href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf"><em>Linearizability:
a correctness condition for concurrent objects</em></a> by Herlihy and
Wing (1990) which is the main technique behind it.</p>
<p>I’d like to stress that no Quviq QuickCheck library code is ever
shared in any of these papers, they only contain the library APIs (which
are public) and test examples implemented using said APIs.</p>
<p>After that most papers are experience reports of applying Quviq
QuickCheck at different companies, e.g. <em>Testing A Database for Race
Conditions with QuickCheck</em> (2011), <a
href="https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"><em>Testing
the hard stuff and staying sane</em></a> (2014), <em>Testing AUTOSAR
software with QuickCheck</em> (2015), <em>Mysteries of Dropbox:
Property-Based Testing of a Distributed Synchronization Service</em>
(2016).</p>
<p>Sometimes various minor extensions to stateful and parallel testings
are needed in order to test some particular piece of software, e.g. C
FFI bindings in the case of AUTOSAR or eventual consistency in the case
of Dropbox, but by and large the stateful and parallel testing features
remain the same.</p>
<h2 id="a-survey-of-property-based-testing-libraries">A survey of
property-based testing libraries</h2>
<p>As we’ve seen above, the current state-of-the-art when it comes to
property-based testing is <em>stateful</em> testing via a state machine
model and reusing the same sequential state machine model combined with
linearisability to achieve <em>parallel</em> testing.</p>
<p>Next let’s survey the most commonly used property-based testing
libraries to see how well supported these two testing features are. Let
me be clear up front that I’ve not used all of these libraries. My
understanding comes from reading the documentation, issue tracker and
sometimes source code.</p>
<p>To my best knowledge, as of June 2024, the following table summarises
the situation. Please open an <a
href="https://github.com/stevana/stateful-pbt-with-fakes/issues">issue</a>,
PR, or get in <a href="https://stevana.github.io/about.html">touch</a>
if you see a mistake or an important omission.</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Library</th>
<th style="text-align: left;">Language</th>
<th style="text-align: center;">Stateful</th>
<th style="text-align: center;">Parallel</th>
<th style="text-align: left;">Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Eris</td>
<td style="text-align: left;">PHP</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">FsCheck</td>
<td style="text-align: left;">F#</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Has experimental <a
href="https://fscheck.github.io/FsCheck//StatefulTestingNew.html">stateful
testing</a>. An <a
href="https://github.com/fscheck/FsCheck/issues/214">issue</a> to add
parallel support has been open since 2016.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Gopter</td>
<td style="text-align: left;">Go</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">The README says “No parallel commands …
yet?” and there’s an open <a
href="https://github.com/leanovate/gopter/issues/20">issue</a> from
2017.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Hedgehog</td>
<td style="text-align: left;">Haskell</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;">Has parallel support, but the
implementation has <a
href="https://github.com/hedgehogqa/haskell-hedgehog/issues/104">issues</a>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Hypothesis</td>
<td style="text-align: left;">Python</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">PropEr</td>
<td style="text-align: left;">Erlang</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;">First open source library to support
both?</td>
</tr>
<tr class="odd">
<td style="text-align: left;">QuickCheck</td>
<td style="text-align: left;">Haskell</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/nick8325/quickcheck/issues/139">issue</a> to
add stateful testing since 2016.</td>
</tr>
<tr class="even">
<td style="text-align: left;">QuickTheories</td>
<td style="text-align: left;">Java</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Has <a
href="https://github.com/quicktheories/QuickTheories/issues/42">experimental</a>
for stateful testing, there’s also some parallel testing, but it’s
inefficient and restrictive compared to QuviQ’s Erlang version of
QuickCheck. From the <a
href="https://github.com/quicktheories/QuickTheories/blob/a963eded0604ab9fe1950611a64807851d790c1c/core/src/main/java/org/quicktheories/core/stateful/Parallel.java#L35">source
code</a>: “Supplied commands will first be run in sequence and compared
against the model, then run concurrently. All possible valid end states
of the system will be calculated, then the actual end state compared to
this. As the number of possible end states increases rapidly with the
number of commands, command lists should usually be constrained to 10 or
less.”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Rapid</td>
<td style="text-align: left;">Go</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">RapidCheck</td>
<td style="text-align: left;">C++</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/emil-e/rapidcheck/issues/47">issue</a> to add
parallel support from 2015.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ScalaCheck</td>
<td style="text-align: left;">Scala</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Has some support for parallel testing, but
it’s limited as can be witnessed by the fact that the two <a
href="https://github.com/typelevel/scalacheck/tree/19af6eb656ba759980664e29ec6ae3e063021685/examples">examples</a>
of testing LevelDB and Redis both are sequential
(<code>threadCount = 1</code>).</td>
</tr>
<tr class="even">
<td style="text-align: left;">SwiftCheck</td>
<td style="text-align: left;">Swift</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/typelift/SwiftCheck/issues/149">issue</a> to
add stateful testing from 2016.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast-check</td>
<td style="text-align: left;">TypeScript</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Has <a
href="https://fast-check.dev/docs/advanced/race-conditions/">some
support</a> for race condition checking, but it seems different from
Quviq QuickCheck’s parallel testing. In particular it doesn’t seem to
reuse the sequential state machine model nor use linearisability.</td>
</tr>
<tr class="even">
<td style="text-align: left;">jetCheck</td>
<td style="text-align: left;">Java</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">From the source code “Represents an action
with potential side effects, for single-threaded property-based testing
of stateful systems.”.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">jsverify</td>
<td style="text-align: left;">JavaScript</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/jsverify/jsverify/issues/148">issue</a> to add
stateful testing from 2015.</td>
</tr>
<tr class="even">
<td style="text-align: left;">lua-quickcheck</td>
<td style="text-align: left;">Lua</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">propcheck</td>
<td style="text-align: left;">Elixir</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/alfert/propcheck/issues/148">issue</a> to add
parallel testing from 2020.</td>
</tr>
<tr class="even">
<td style="text-align: left;">proptest</td>
<td style="text-align: left;">Rust</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">See proptest-state-machine.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">proptest-state-machine</td>
<td style="text-align: left;">Rust</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Documentation says “Currently, only
sequential strategy is supported, but a concurrent strategy is planned
to be added at later point.”.</td>
</tr>
<tr class="even">
<td style="text-align: left;">qcheck-stm</td>
<td style="text-align: left;">OCaml</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">quickcheck</td>
<td style="text-align: left;">Prolog</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">quickcheck</td>
<td style="text-align: left;">Rust</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Issue to add stateful testing has been <a
href="https://github.com/BurntSushi/quickcheck/issues/134">closed</a>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">quickcheck-state-machine</td>
<td style="text-align: left;">Haskell</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;">Second open source library with parallel
testing support? (I was <a
href="https://github.com/nick8325/quickcheck/issues/139#issuecomment-272439099">involved</a>
in the development.)</td>
</tr>
<tr class="even">
<td style="text-align: left;">rackcheck</td>
<td style="text-align: left;">Racket</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">rantly</td>
<td style="text-align: left;">Ruby</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">test.check</td>
<td style="text-align: left;">Clojure</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Someone has implemented stateful testing
in a blog <a
href="http://blog.guillermowinkler.com/blog/2015/04/12/verifying-state-machine-behavior-using-test-dot-check/">post</a>
though.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">theft</td>
<td style="text-align: left;">C</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="analysis">Analysis</h2>
<p>By now I hope that I’ve managed to convince you that most
property-based testing libraries do not implement what used to be the
state-of-the-art fifteen years ago.</p>
<p>Many libraries lack stateful testing via state machines and most lack
parallel testing support. Often users of the libraries have opened
tickets asking for these features, but the tickets have stayed open for
years without any progress. Furthermore it’s not clear to me whether all
libraries that support stateful testing can be generalised to parallel
testing without a substantial redesign of their APIs. I don’t think
there’s a single example of a library to which parallel testing was
added later, rather than designed for from the start.</p>
<h3
id="why-are-property-based-testing-libraries-in-such-a-sad-state">Why
are property-based testing libraries in such a sad state?</h3>
<p>Here are three reasons I’ve heard from John:</p>
<ol type="1">
<li><p>The stateful and parallel testing features are not as useful as
testing pure functions. This is what John told me when I asked him why
these features haven’t taken off in the context of Haskell (BobKonf
2017);</p></li>
<li><p>The state machine models that one needs to write for the stateful
and parallel testing require a different way of thinking compared to
normal testing. One can’t merely give these tools to new users without
also giving them proper training, John said in an <a
href="https://youtu.be/x4BNj7mVTkw?t=898">interview</a>;</p></li>
<li><p>Open source didn’t work, a closed source product and associated
services <a
href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5ae25681ff881430797268c5787d7d9ee6cf542c">helps</a>
adoption:</p>
<blockquote>
<p>“Thomas Arts and I have founded a start-up, Quviq AB, to develop and
market Quviq QuickCheck. Interestingly, this is the second
implementation of QuickCheck for Erlang. The first was presented at the
Erlang User Conference in 2003, and made available on the web. Despite
enthusiasm at the conference, it was never adopted in industry. We tried
to give away the technology, and it didn’t work! So now we are selling
it, with considerably more success. Of course, Quviq QuickCheck is no
longer the same product that was offered in 2003—it has been improved in
many ways, adapted in the light of customers’ experience, extended to be
simpler to apply to customers’ problems, and is available together with
training courses and consultancy. That is, we are putting a great deal
of work into helping customers adopt the technology. It was naive to
expect that simply putting source code on the web would suffice to make
that happen, and it would also be unreasonable to expect funding
agencies to pay for all the work involved. In that light, starting a
company is a natural way for a researcher to make an impact on
industrial practice—and so far, at least, it seems to be
succeeding.”</p>
</blockquote></li>
</ol>
<p>A cynic might argue that there’s a conflict of interest between doing
research and education on one hand and running a company that sells
licenses, training and consulting on the other.</p>
<p>Let me be clear that I’ve the utmost respect for John, and I believe
what he says to be true and I believe he acts with the best intentions.
Having said that let me try to address John’s points.</p>
<h4
id="stateful-and-parallel-testing-isnt-as-useful-as-pure-testing">Stateful
and parallel testing isn’t as useful as pure testing</h4>
<p>I think many people will agree that separating pure from
side-effectful code is good practice in any programming language, and I
do agree with John that you can get far by merely property-based testing
those pure fragments.</p>
<p>However I also think that stateful and parallel testing is almost
equally important for many non-trivial software systems. Most systems in
industry will have some database, stateful protocol or use concurrent
data structures, which all benefit from the stateful and parallel
testing features.</p>
<h4 id="stateful-modelling-requires-training">Stateful modelling
requires training</h4>
<p>Regarding formal specification requiring a special way of thinking
and therefor training, I believe this is a correct assessment. However I
also believe that this is already true for property-based testing of
pure functions. A non-trained user of pure property-based testing will
likely test less interesting properties than someone who’s trained.</p>
<p>Given that John has written <a
href="https://research.chalmers.se/publication/517894/file/517894_Fulltext.pdf">papers</a>
and given <a
href="https://www.youtube.com/watch?v=NcJOiQlzlXQ">talks</a> on the
topic of making property-based testing of pure functions more accessible
to programmers, one might wonder why we cannot do the same for stateful
and parallel testing?</p>
<p>The experience reports, that we’ve mentioned above, usually contain
some novelty (which warrants publishing a new paper) rather than general
advice which can be done with the vanilla stateful and parallel testing
features. Furthermore they require buying a Quviq license in order to
reproduce the results, a show stopper for many people.</p>
<p>I think it’s also worth stressing that stateful specifications are
not necessarily always more difficult than specifications for pure
functions. For example, to model a key-value store one can get quite far
with the model being a list of key-value pairs. In fact a simple model
like that managed to find a 17 step (shrunk) counterexample in LevelDB
to a known <a
href="https://github.com/google/leveldb/issues/50">issue</a>, within
mere minutes. It took weeks for Google to provide a fix, and then after
running the property again on the fixed code a new 31 step
counterexample was found within minutes. Turns out there was a bug in
the background compaction process. The compaction process improves read
performance and reclaims disk space, which is important for a key-value
store, but interestingly it’s not explicitly part of the model. Joseph W
Norton gave a <a
href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/strangeloop/lambdajam2013/master/slides/Norton-QuickCheck.html">talk</a>
at LambdaJam 2013 about it.</p>
<h4 id="closed-source-helps-industry-adoption">Closed source helps
industry adoption</h4>
<p>Regarding keeping the source closed helping with adoption, I think
this is perhaps the most controversial point that John makes.</p>
<p>If we try to see it from John’s perspective, how else would an
academic get funding to work on tooling (which typically isn’t
recognised as doing research), or feedback from industry? Surely, one
cannot expect research funding agencies to pay for this?</p>
<p>On the other hand one could ask why there isn’t a requirement that
published research should be reproducible using open source tools (or at
least tools that are freely available to the public and other
researchers)? Trying to replicate the results from the Quviq QuickCheck
papers (from 2006 and onward) without buying a Quviq QuickCheck license,
is almost impossible without a lot of reverse engineering work.</p>
<p>I suppose one could argue that one could have built a business around
an open source tool, only charging for the training and consulting, but
given how broken open source is today, unless you are a big company
(which takes more than it gives back), it’s definitely not clear that it
would have worked (and it was probably even worse back in 2006).</p>
<p>Even if John is right and that keeping it closed source has helped
adoption in industry, I think it’s by now fair to say it has not helped
open source adoption. Or perhaps another way to look at it, it’s
unlikely that a company that pays for a license in Erlang would then go
and port the library in another language.</p>
<h3 id="what-can-we-do-about-it">What can we do about it?</h3>
<p>I think there’s at least two things worth trying.</p>
<ol type="1">
<li><p>Provide a short open source implementation of stateful and
parallel property-based testing, analogous to the original ~300 lines of
code QuickCheck implementation.</p>
<p>Perhaps part of the original QuickCheck library’s success in
spreading to so many other languages can be attributed to the fact that
its small implementation and that it is part of the original
paper?</p></li>
<li><p>Try to make the formal specification part easier, so that we
don’t need to train developers (as much).</p>
<p>Perhaps we can avoid state machines as basis for specifications and
instead reuse concepts that programmers are already familiar with from
their current testing activities, e.g. mocking and test doubles more
generally?</p></li>
</ol>
<h2 id="synthesis">Synthesis</h2>
<p>In order to test the above hypothesis, I’d like to spend the rest of
this post as follows:</p>
<ol type="1">
<li><p>Show how one can implement stateful and parallel property-based
testing in about 400 lines of code (similar to the size of the original
QuickCheck implementation);</p></li>
<li><p>Make specifications simpler by using <a
href="https://martinfowler.com/bliki/TestDouble.html">fakes</a> rather
than state machines.</p></li>
</ol>
<p>Before we get started with stateful testing, let’s first recap how
property-based testing of pure functions works.</p>
<h3 id="pure-property-based-testing-recap">Pure property-based testing
recap</h3>
<p>It’s considered good practice to test new functions or functionality,
to make sure it does what we want. For example, imagine we’ve written a
linked-list reversal function called <code>reverse</code>, then it might
be sensible to test it against a couple of lists such as the empty list
and, say, the three element list <code>[1, 2, 3]</code>.</p>
<p>How does one choose which example inputs to test against though?
Typically one wants to choose corner cases, such as the empty list, that
perhaps were overlooked during the implementation. It’s difficult to
think of corner cases that you might have overlooked (because if you can
then you probably wouldn’t have overlooked them in the first place)!
This is where generating random inputs, a key feature of property-based
testing, comes in. The idea being that random inputs will eventually hit
corner cases.</p>
<p>When we manually pick inputs for our tests, like
<code>[1, 2, 3]</code>, we know what the output should be and so we can
make the appropriate assertion,
i.e. <code>reverse [1, 2, 3] == [3, 2, 1]</code>. When we generate
random inputs we don’t always know what the output should be. This is
where writing properties that relate the output to the input somehow
comes in. For example, while we don’t know what the output of reversing
an arbitrary list is, we do know that reversing it twice will give back
the input. This is how we can express this property in QuickCheck:</p>
<pre><code>&gt;&gt;&gt; quickCheck (\(xs :: [Int]) -&gt; reverse (reverse xs) == xs)
+++ OK, passed 100 tests.</code></pre>
<p>By default 100 tests get generated, but that can be adjusted:</p>
<pre><code>&gt;&gt;&gt; quickCheck (withMaxSuccess 5 (\(xs :: [Int]) -&gt; reverse (reverse xs) == xs))
+++ OK, passed 5 tests.</code></pre>
<p>We can see what test get generated using
<code>verboseCheck</code>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> verboseCheck (withMaxSuccess <span class="dv">5</span> (\(<span class="ot">xs ::</span> [<span class="dt">Int</span>]) <span class="ot">-&gt;</span> <span class="fu">reverse</span> (<span class="fu">reverse</span> xs) <span class="op">==</span> xs))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">5</span> tests<span class="op">.</span></span></code></pre></div>
<p>Or by using <code>sample</code> on the appropriate
<code>Gen</code>erator. In this case we are generating lists of
integers, hence the <code>Gen [Int]</code> type annotation:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> sample (<span class="ot">arbitrary ::</span> <span class="dt">Gen</span> [<span class="dt">Int</span>])</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">4</span>]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,<span class="dv">6</span>,<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">6</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">7</span>,<span class="dv">5</span>,<span class="op">-</span><span class="dv">8</span>,<span class="dv">1</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">11</span>,<span class="dv">4</span>]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">11</span>]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">3</span>,<span class="dv">17</span>,<span class="op">-</span><span class="dv">14</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">17</span>,<span class="dv">18</span>,<span class="op">-</span><span class="dv">8</span>,<span class="op">-</span><span class="dv">9</span>,<span class="op">-</span><span class="dv">13</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,<span class="dv">19</span>,<span class="dv">6</span>,<span class="dv">9</span>,<span class="op">-</span><span class="dv">15</span>,<span class="op">-</span><span class="dv">6</span>,<span class="op">-</span><span class="dv">19</span>]</span></code></pre></div>
<p>The list and integer generators are provided by the library and I
hope you agree that these seem like sensible arbitrary lists to use in
our tests.</p>
<p>Next let’s have a look at when a property fails. For example this is
what happens if we try to test that the output of reversing a list is
the input list:</p>
<pre><code>&gt;&gt;&gt; quickCheck (\(xs :: [Int]) -&gt; reverse xs == xs)
*** Failed! Falsified (after 3 tests and 2 shrinks):
[0,1]</code></pre>
<p>We see that after 3 tests a test case was generated that failed, the
input got shrunk twice and the minimal counterexample
<code>[0, 1]</code> is presented. Notice that we do need a list that is
at least of length two, because any shorter list will reverse to
itself.</p>
<p>As pointed out earlier, coming up with these properties is by no
means obvious. There are however a few patterns that come up over and
over again. With <code>reverse</code> we saw an example of an involutory
function, i.e. <code>f (f x) == x</code>, here are a few other
examples:</p>
<ul>
<li>Inverses,
e.g. <code>\(i :: Input) -&gt; deserialise (serialise i) == i</code>;</li>
<li>Idempotency,
e.g. <code>\(xs :: [Int]) -&gt; sort (sort xs) == sort xs</code>;</li>
<li>Associativity,
e.g. <code>\(i j k :: Int) -&gt; (i + j) + k == i + (j + k)</code>;</li>
<li>Axioms of abstract data types, e.g.
<code>\(x :: Int)(xs :: [Int]) -&gt; member x (insert x xs) &amp;&amp; not (member x (remove x xs))</code>;</li>
<li>Metamorphic properties, e.g.
<code>\(g :: Graph)(m n :: Node) -&gt; shortestPath g m n == shortestPath g n m</code>.</li>
</ul>
<p>Readers familiar with discrete math might recognise some of the
above.</p>
<h3 id="stateful-property-based-testing-in-180-loc">Stateful
property-based testing in ~180 LOC</h3>
<p>In the pure property-based testing case, that we just looked at, the
picture of the test setup looks a bit like this:</p>
<pre><code>         +-----+
      i  |     |  o
    -----&gt;  f  +----&gt;
         |     |
         +-----+</code></pre>
<p>Where <code>i</code> is the input we generate, <code>f</code> is the
function we are applying the generated input to to produce the output
<code>o</code>. In the case of the <code>reverse</code> example, from
before, <code>i</code> and <code>o</code> are of type list of integers
(<code>[Int]</code>), <code>f</code> is <code>reverse . reverse</code>
and the property that we check for every generated input is that input
is equal to the output.</p>
<p>Next let’s contrast this picture with how the test setup looks when
we are testing a stateful component. A simple example of a stateful
component is a counter with an <code>incr</code>ement operation which
increment the counter and returns the old count.</p>
<p>Unlike in the pure case, the same input will not give the same
output. For example the first time we do <code>incr</code> we get back
<code>0</code> (if we start counting from zero) while the second time we
do <code>incr</code> we get <code>1</code>. A database or a file system
are two other examples of stateful components, where the history of
previous inputs affects the output of the next input.</p>
<p>In the stateful case, the picture looks more like this:</p>
<pre><code>    +------+     +------+     +------+
    |      | i1  |      | i2  |      |
    |  s0  +-----&gt;  s1  +-----&gt;  s2  | ...
    |      |     |      |     |      |
    +------+     +--+---+     +--+---+
                    |            |
                    | o1         | o2
                    v            v

    ---------------------------------&gt; time</code></pre>
<p>Where <code>s</code> is the state, <code>i</code> is an input
(e.g. <code>incr</code>) and <code>o</code> is an output. Notice how the
state evolves over time and depends on the history of inputs.</p>
<p>In the pure case each test case is a single input, in the stateful
case we need a sequence of inputs in order to test how the system
changes over time. In the pure case our our properties were relations on
the input and output, i.e. <code>R : i -&gt; o -&gt; Bool</code>. In the
stateful case our properties would need to be generalised to
<code>R' : [i] -&gt; [o] -&gt; Bool</code> to account for how the state
changes over time. Writing such properties is cumbersome, an alternative
is to account for the state explicitly by means of some kind of
model.</p>
<p>This model could be a state machine of type
<code>m -&gt; i -&gt; (m, o)</code>, i.e. a function from the old model
and an input to the next model and the output. From this we can derive a
property that for each input checks if the outputs of the stateful
component agrees with the output of the state machine:</p>
<pre><code>   +------+     +------+     +------+
   |      | i1  |      | i2  |      |
   |  s0  +-----&gt;  s1  +-----&gt;  s2  | ...
   |      |     |      |     |      |
   +------+     +--++--+     +--++--+
                   ||           ||
                   ||o1         || o2
                   ||           ||
   +------+     +--++--+     +--++--+
   |      | i1  |      | i2  |      |
   |  m0  +-----&gt;  m1  +-----&gt;  m2  | ...
   |      |     |      |     |      |
   +------+     +------+     +------+</code></pre>
<p>In case the outputs disagree we shrink the sequence of inputs and try
to present the smallest counterexample, as in the pure case.</p>
<p>Let’s make things more concrete with some actual code that we can
run.</p>
<h4 id="example-counter">Example: counter</h4>
<p>All examples, in the rest of this post, will have three parts:</p>
<ol type="1">
<li>The software under test;</li>
<li>The model that the software under test gets tested against;</li>
<li>The generated tests and output from running them.</li>
</ol>
<p>The first part is independent of the stateful testing library we are
building. The second part is hooking up the first part to the library by
implementing an interface (type class). We’ll look at the definition of
the type class after the example. The final part is how to write the
actual property and interpret the output from running them.</p>
<h5 id="software-under-test">Software under test</h5>
<p>This is how you can implement a counter using a global mutable
variable in Haskell:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">gLOBAL_COUNTER ::</span> <span class="dt">IORef</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>gLOBAL_COUNTER <span class="ot">=</span> unsafePerformIO (newIORef <span class="dv">0</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE gLOBAL_COUNTER #-}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ot">incr ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>incr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> readIORef gLOBAL_COUNTER</span></code></pre></div>
<p>Notice that here <code>incr</code> doesn’t return the old value, like
above, and instead we have a separate operation <code>get</code> which
returns the current value of the counter.</p>
<h5 id="model">Model</h5>
<p>To model our counter we’ll use an integer.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Counter</span> <span class="ot">=</span> <span class="dt">Counter</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- We&#39;ll come back to the definition of the `StateModel` type class after this</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- example.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> <span class="dt">Counter</span> <span class="kw">where</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- We start counting from zero.</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  initialState ::</span> <span class="dt">Counter</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  initialState <span class="ot">=</span> <span class="dt">Counter</span> <span class="dv">0</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The commands correspond to the names of the functions that operate on the</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- global counter.</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span> <span class="dt">Counter</span> r</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Incr</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Get</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The responses correspond to the return types of each function. By</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- convention we&#39;ll add a underscore suffix to a response of the corresponding</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- command.</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span> <span class="dt">Counter</span> r</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Incr_</span> ()</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Get_</span> <span class="dt">Int</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The state machine takes a command and the model of the counter and returns</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- a new model and a response. We&#39;ll come back to the role of the `Either` later.</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="ot">  runFake ::</span> <span class="dt">Command</span> <span class="dt">Counter</span> r <span class="ot">-&gt;</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Void</span> (<span class="dt">Counter</span>, <span class="dt">Response</span> <span class="dt">Counter</span> r)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">Incr</span>  (<span class="dt">Counter</span> n) <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">Counter</span> (n <span class="op">+</span> <span class="dv">1</span>), <span class="dt">Incr_</span> ())</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">Get</span> m<span class="op">@</span>(<span class="dt">Counter</span> n) <span class="ot">=</span> <span class="fu">return</span> (m, <span class="dt">Get_</span> n)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- We also need to explain which part of the counter API each command</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- corresponds to.</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="ot">  runReal ::</span> <span class="dt">Command</span> <span class="dt">Counter</span> r <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">Counter</span> r)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>  runReal <span class="dt">Get</span>  <span class="ot">=</span> <span class="dt">Get_</span>  <span class="op">&lt;$&gt;</span> get</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>  runReal <span class="dt">Incr</span> <span class="ot">=</span> <span class="dt">Incr_</span> <span class="op">&lt;$&gt;</span> incr</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- We&#39;ll generate increments and reads of the counter with equal probability.</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Notice that we only need to explain how to generate a single command, the</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- library will use this to generate sequences of commands as we&#39;ll see later.</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommand ::</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> <span class="dt">Counter</span> r)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>  generateCommand _s <span class="ot">=</span> elements [<span class="dt">Incr</span>, <span class="dt">Get</span>]</span></code></pre></div>
<p>A common complaint is that the model (<code>Counter</code> and
<code>runFake</code>) is as big as the implementation itself. This is
true, because it’s an example. In reality the model will often be many
orders of magnitude smaller. This is due to the fact that the model,
unlike the real implementation, doesn’t need to persisting to disk,
communicating over the network, or perform various time or space
optimisations. Recall the LevelDB example from above.</p>
<h5 id="tests">Tests</h5>
<p>The tests, or property, can now be written as follows.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_counter ::</span> <span class="dt">Commands</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>prop_counter cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  run reset</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">reset ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>reset <span class="ot">=</span> writeIORef gLOBAL_COUNTER <span class="dv">0</span></span></code></pre></div>
<p>To run them, we can load the module and type
<code>quickCheck prop_counter</code> in the REPL, which gives us an
output like:</p>
<pre><code>+++ OK, passed 100 tests:
89% Get
85% Incr

Commands (2151 in total):
52.02% Get
47.98% Incr</code></pre>
<p>Where the first group of percentages tell us the proportion of tests
that contained the get and increment command respectively, and the
second group of percentages tell us the proportion of get and increment
commands out of all commands generated. Note that the first group
doesn’t add up to 100%, because most tests will contain both commands,
whereas the second group does. The reason the second group is almost
50-50 is because in the generator we generate both commands with equal
probability.</p>
<p>Another thing to note is that we need to <code>reset</code> the
counter between tests, otherwise the global counter will have the value
from the last test while the model always starts from zero and we get a
mismatch.</p>
<p>To make things a bit more interesting, let’s introduce a bug into our
counter and see if the tests can find it. Let’s make it so that if the
counter has the value of 42, then it won’t increment properly.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">incr42Bug ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>incr42Bug <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n&#39; <span class="ot">=</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">42</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>           <span class="kw">then</span> n <span class="co">-- </span><span class="al">BUG</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>           <span class="kw">else</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER n&#39;</span></code></pre></div>
<p>We also need to change the <code>runReal</code> function to use our
buggy increment as follows.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="st">- runReal Incr = Incr_ &lt;$&gt; incr</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ runReal Incr = Incr_ &lt;$&gt; incr42Bug</span></span></code></pre></div>
<p>When we run the property now, we’ll see something like the following
output.</p>
<pre><code>*** Failed! Assertion failed (after 66 tests and 29 shrinks):
    Commands [Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Get]
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Get --&gt; Get_ 42

    Expected: Get_ 43
    Got: Get_ 42</code></pre>
<p>Notice that this is indeed the smallest counterexample and how it
took 66 randomly generated test cases to find the sequence of inputs
that triggered the bug and then 29 shrink steps for QuickCheck to
minimise it.</p>
<h4 id="stateful-library-implementation">Stateful library
implementation</h4>
<p>In the example above we implemented the <code>StateModel</code>
interface (or type class), next we’ll have a look at the definition of
this interface and the testing functionality we can derive by
programming against the interface.</p>
<h5 id="stateful-testing-interface">Stateful testing interface</h5>
<p>Let me give you the full definition of the interface and then I’ll
explain it in words afterwards.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ( <span class="op">...</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>      ) <span class="ot">=&gt;</span> <span class="dt">StateModel</span> state <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- If we think of the system under test as a black box, then commands are the</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- inputs and responses the outputs to the black box.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span><span class="ot">  state ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span><span class="ot"> state ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Sometimes a command needs to refer to a previous response, e.g. when a file</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- is opened we get a handle which is later refered to when writing or reading</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- form the file. File handles, and similar constructs, are called references</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- and can be part of commands and responses.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span><span class="ot"> state ::</span> <span class="dt">Type</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span> state <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Not all commands are valid in all states. Pre-conditions allow the user to</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- specify when a command is safe to execute, for example we cannot write or</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- read to or from an unopened file. The `PreconditionFailure` data type</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- allows the user to create custom pre-condition failures. By default now</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- pre-condition failures are allowed, thus the `Void` (empty) type.</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">PreconditionFailure</span><span class="ot"> state ::</span> <span class="dt">Type</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">PreconditionFailure</span> state <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommand ::</span> state <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="ot">  shrinkCommand ::</span> state <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _state _cmd <span class="ot">=</span> []</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span class="ot">  initialState ::</span> state</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a><span class="ot">  runFake ::</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)) <span class="ot">-&gt;</span> state</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">PreconditionFailure</span> state)</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>                    (state, <span class="dt">Response</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a><span class="ot">  runReal ::</span> <span class="dt">Command</span> state (<span class="dt">Reference</span> state)</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">CommandMonad</span> state (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a><span class="ot">  monitoring ::</span> (state, state)</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Reference</span> state)</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Response</span> state (<span class="dt">Reference</span> state)</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Property</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>  monitoring _states _cmd _resp <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a><span class="ot">  commandName ::</span> (<span class="dt">Show</span> (<span class="dt">Command</span> state ref), <span class="dt">Show</span> ref)</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=&gt;</span> <span class="dt">Command</span> state ref <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>  commandName <span class="ot">=</span> <span class="fu">head</span> <span class="op">.</span> <span class="fu">words</span> <span class="op">.</span> <span class="fu">show</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Most often the result of executing a command against the system under test</span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- will live in the IO monad, but sometimes it can be useful to be able a</span></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- choose another monad.</span></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">CommandMonad</span><span class="ot"> state ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">CommandMonad</span> state <span class="ot">=</span> <span class="dt">IO</span></span></code></pre></div>
<p>The interface is parametrised by a <code>state</code> type that the
user needs to define before instantiating the interface. In the counter
example <code>state</code> is
<code>newtype Counter = Counter Int</code>. The user needs to provide an
<code>initialState :: state</code> from which we’ll start generating
commands and executing the model, in the counter case this is
<code>Counter 0</code>.</p>
<p>As part of the instantiating the user also needs to specify a type of
<code>Command</code>s and <code>Response</code>s, these were the
<code>Incr</code> and <code>Get</code> operations of the counter and
their response types respectively.</p>
<p>In addition there’s also three optional types, that we’ve not needed
in the counter example. The first is references, these are used to refer
back to previously created resources. For example if we open a file
handle on a POSIX-like file system, then later commands need to be able
to refer to that file handle when wanting to write or read from it. The
second datatype is <code>PreconditionFailure</code>, which is used to
give a nice error message when a command is executed in a disallowed
state. For example if we try to read from a file handle that has been
closed. The third data type is <code>CommandMonad</code> which let’s us
use a different monad than <code>IO</code> for executing our commands
in. After we’ve finished with the interface definition we’ll come back
to more examples where we’ll use these optional types, hopefully these
examples will help make things more concrete.</p>
<p>We’ve already seen that the user needs to provide a way to generate
single command, the only thing worth mentioning is that in case our
commands contain references then during the generation phase we only
deal with <code>Var</code>s of references, where
<code>data Var a = Var Int</code>. The reason for this is that we cannot
generate, for example, real file handles (only the operating system
can), so instead we generate symbolic references which are just
<code>Int</code>s. Think of these as placeholders for which real
references will be substituted in once the real references are created
during execution.</p>
<p>Shrinking of individual commands is optional and disabled by default,
but as we’ve seen this doesn’t exclude the sequence of commands to be
shrunk. We’ll shall see shortly how that is done in detail.</p>
<p>Next up we got <code>runFake</code> and <code>runReal</code> which
executes a command against the <code>state</code> model and the real
system respectively. Notice how <code>runFake</code> can fail with a
<code>PreconditionFailure</code>, whereas <code>runReal</code> is always
expected to succeed (because if a command fails the precondition check,
then it won’t get generated and hence never reach <code>runReal</code>).
Another difference is that <code>runFake</code> uses symbolic
references, while <code>runReal</code> deals with real references. We’ll
shortly see how this substitution of references works.</p>
<p>Lastly we have two optional functions related to keeping statistics
of generated test cases, which is useful for coverage reporting among
other things. We’ll come back to how these can be used as we look at
more examples after we’ve defined our stateful property-based testing
library.</p>
<h5 id="generating-and-shrinking">Generating and shrinking</h5>
<p>Once we have our interface we can start writing functions against the
interface. These functions are what the user gets once they implement
the interface. In this section we’ll have a look at generation of
sequences of <code>Commands</code>, which will be the inputs for our
tests, and how to shrink said inputs to produce a minimal
counterexample.</p>
<p>Let’s start by defining <code>Commands</code>, notice that they use
symbolic references (i.e. <code>Var (Reference state)</code>):</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Commands</span> state <span class="ot">=</span> <span class="dt">Commands</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> unCommands ::</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))] }</span></code></pre></div>
<p>As mentioned above, when we generate commands we cannot generate real
references, e.g. file handles, thus <code>Var (Reference state)</code>
is used which is isomorphic to just an <code>Int</code>.</p>
<p>Sometimes it’s convenient to split up <code>runFake</code> into two
parts, the first checks if the command is allowed in the current state,
i.e. the precondition holds:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">precondition ::</span> <span class="dt">StateModel</span> state</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">=&gt;</span> state <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>precondition s cmd <span class="ot">=</span> <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> _  <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> _ <span class="ot">-&gt;</span> <span class="dt">True</span></span></code></pre></div>
<p>And the second part advances the state:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nextState ::</span> <span class="dt">StateModel</span> state</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>          <span class="ot">=&gt;</span> state <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)) <span class="ot">-&gt;</span> state</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>nextState s cmd <span class="ot">=</span> <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> (s&#39;, _) <span class="ot">-&gt;</span> s&#39;</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> _err <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;nextState: impossible, we checked for success in precondition&quot;</span></span></code></pre></div>
<p>We assume that we’ll only ever look at the <code>nextState</code>
when the <code>precondition</code> holds.</p>
<p>Using these two functions we can implement QuickCheck’s
<code>Arbitrary</code> type class for <code>Commands</code> which let’s
us generate and shrink <code>Commands</code>:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> state <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Commands</span> state) <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> (<span class="dt">Commands</span> state)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> <span class="dt">Commands</span> <span class="op">&lt;$&gt;</span> genCommands initialState</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="ot">      genCommands ::</span> <span class="dt">StateModel</span> state</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>                  <span class="ot">=&gt;</span> state <span class="ot">-&gt;</span> <span class="dt">Gen</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>      genCommands s <span class="ot">=</span> sized <span class="op">$</span> \n <span class="ot">-&gt;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>          w <span class="ot">=</span> n <span class="ot">`div`</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>          frequency</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>            [ (<span class="dv">1</span>, <span class="fu">return</span> [])</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>            , (w, <span class="kw">do</span> mcmd <span class="ot">&lt;-</span> generateCommand s <span class="ot">`suchThatMaybe`</span> precondition s</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">case</span> mcmd <span class="kw">of</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> <span class="fu">return</span> []</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Just</span> cmd <span class="ot">-&gt;</span> (cmd <span class="op">:</span>) <span class="op">&lt;$&gt;</span> genCommands (nextState s cmd))</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="ot">  shrink ::</span> <span class="dt">Commands</span> state <span class="ot">-&gt;</span> [<span class="dt">Commands</span> state]</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>  shrink <span class="ot">=</span> pruneShrinks <span class="op">.</span> possibleShrinks</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="ot">      possibleShrinks ::</span> <span class="dt">Commands</span> state <span class="ot">-&gt;</span> [<span class="dt">Commands</span> state]</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>      possibleShrinks <span class="ot">=</span> <span class="fu">map</span> (<span class="dt">Commands</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">fst</span>) <span class="op">.</span> shrinkList shrinker</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>                      <span class="op">.</span> withStates initialState <span class="op">.</span> unCommands</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>          shrinker (cmd, s) <span class="ot">=</span> [ (cmd&#39;, s) <span class="op">|</span> cmd&#39; <span class="ot">&lt;-</span> shrinkCommand s cmd ]</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="ot">          withStates ::</span> <span class="dt">StateModel</span> state</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">=&gt;</span> state <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">-&gt;</span> [(<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)), state)]</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>          withStates s0 <span class="ot">=</span> go s0 []</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>              go _s acc []           <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>              go  s acc (cmd <span class="op">:</span> cmds) <span class="ot">=</span> go (nextState s cmd) ((cmd, s) <span class="op">:</span> acc) cmds</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a><span class="ot">      pruneShrinks ::</span> [<span class="dt">Commands</span> state] <span class="ot">-&gt;</span> [<span class="dt">Commands</span> state]</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>      pruneShrinks <span class="ot">=</span> coerce <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span>)</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>                   <span class="op">.</span> <span class="fu">map</span> (go initialState Set.empty [] <span class="op">.</span> unCommands)</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>          go _s _vars acc [] <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>          go  s  vars acc (cmd <span class="op">:</span> cmds)</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">not</span> (scopeCheck vars cmd) <span class="ot">=</span> go s vars acc cmds</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Left</span> _preconditionFailure <span class="ot">-&gt;</span> go s vars acc cmds</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Right</span> (s&#39;, resp) <span class="ot">-&gt;</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>                    returnedVars <span class="ot">=</span> Set.fromList (toList resp)</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>                    vars&#39; <span class="ot">=</span> returnedVars <span class="ot">`Set.union`</span> vars</span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>                    go s&#39; vars&#39; (cmd <span class="op">:</span> acc) cmds</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a><span class="ot">scopeCheck ::</span> <span class="dt">Foldable</span> (<span class="dt">Command</span> state)</span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>scopeCheck varsInScope cmd <span class="ot">=</span> usedVars <span class="ot">`Set.isSubsetOf`</span> varsInScope</span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>    usedVars <span class="ot">=</span> Set.fromList (toList cmd)</span></code></pre></div>
<p>Notice how after shrinking we prune away all commands that don’t pass
the precondition or that are out of scope with respect to symbolic
references.</p>
<p>The intuition here is that as we remove commands from the originally
generated <code>Commands</code> (which all pass their preconditions), we
might have broken some preconditions and pruning simply removes the
commands which we made invalid in the process of shrinking. Similarly we
can have a command that creates a reference that later commands then
depend on, if we during shrinking remove the command that created the
reference then we must also remove the commands that depend on the
reference.</p>
<h5 id="running-and-assertion-checking">Running and assertion
checking</h5>
<p>Once we’ve generated <code>Commands</code> we need to execute them
against the model and the real system using <code>runFake</code> and
<code>runReal</code>. In the process of doing so <code>runReal</code>
will produce <code>Reference</code>s that later commands might use, so
we also need to substitute symbolic references for real references.
This, together coverage statistics bookkeeping, is done in the
<code>runCommands</code> function:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runCommands ::</span> <span class="kw">forall</span> state<span class="op">.</span> <span class="dt">StateModel</span> state</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=&gt;</span> <span class="dt">Commands</span> state <span class="ot">-&gt;</span> <span class="dt">PropertyM</span> (<span class="dt">CommandMonad</span> state) ()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>runCommands (<span class="dt">Commands</span> cmds0) <span class="ot">=</span> go initialState emptyEnv cmds0</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> state <span class="ot">-&gt;</span> <span class="dt">Env</span> state <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">PropertyM</span> (<span class="dt">CommandMonad</span> state) ()</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    go _state _env [] <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    go  state  env (cmd <span class="op">:</span> cmds) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> runFake cmd state <span class="kw">of</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>          monitor (counterexample (<span class="st">&quot;Preconditon failed: &quot;</span> <span class="op">++</span> <span class="fu">show</span> err))</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>          assert <span class="dt">False</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> (state&#39;, resp) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> name <span class="ot">=</span> commandName cmd</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>          monitor (tabulate <span class="st">&quot;Commands&quot;</span> [name] <span class="op">.</span> classify <span class="dt">True</span> name)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Here we substitute all symbolic references for real ones:</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> ccmd <span class="ot">=</span> <span class="fu">fmap</span> (lookupEnv env) cmd</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>          cresp <span class="ot">&lt;-</span> run (runReal ccmd)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>          monitor (counterexample (<span class="fu">show</span> cmd <span class="op">++</span> <span class="st">&quot; --&gt; &quot;</span> <span class="op">++</span> <span class="fu">show</span> cresp))</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>          monitor (monitoring (state, state&#39;) ccmd cresp)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Here we collect all references from the response and store it in</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- our environment, so that subsequence commands can be substituted.</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> refs   <span class="ot">=</span> toList cresp</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>              env&#39;   <span class="ot">=</span> extendEnv env (<span class="fu">zip</span> [sizeEnv env<span class="op">..</span>] refs)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>              cresp&#39; <span class="ot">=</span> <span class="fu">fmap</span> (lookupEnv env&#39;) resp</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>              ok     <span class="ot">=</span> cresp <span class="op">==</span> cresp&#39;</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>          unless ok <span class="op">$</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            monitor (counterexample (<span class="st">&quot;Expected: &quot;</span> <span class="op">++</span> <span class="fu">show</span> cresp&#39; <span class="op">++</span> <span class="st">&quot;\nGot: &quot;</span> <span class="op">++</span> <span class="fu">show</span> cresp))</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- And finally here&#39;s where we assert that the model and the real</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- implementation agree.</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>          assert ok</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>          go state&#39; env&#39; cmds</span></code></pre></div>
<p>Where <code>Env</code> is defined as follows.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Env</span> state <span class="ot">=</span> <span class="dt">Env</span> {<span class="ot"> unEnv ::</span> <span class="dt">IntMap</span> (<span class="dt">Reference</span> state) }</span></code></pre></div>
<p>That’s all the pieces we need to implement that <code>Counter</code>
example that we saw above, plus some new constructs to deal with
precondition failures and references.</p>
<p>Next let’s have a look at an example where we need preconditions and
references.</p>
<h4 id="example-circular-buffer">Example: circular buffer</h4>
<p>This example is taken from John’s paper <a
href="https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"><em>Testing
the hard stuff and staying sane</em></a> (2014).</p>
<h5 id="software-under-test-1">Software under test</h5>
<p>The implementation is written in C and uses two indices which keep
track of the front and back of the queue, this allows us to implement
the queue in a circular fashion. I’ve copied the C code straight from
the paper. In order to test it from Haskell, we’ll use Haskell’s foreign
function interface.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> queue <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="op">*</span>buf<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> inp<span class="op">,</span> outp<span class="op">,</span> size<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> Queue<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>Queue <span class="op">*</span>new<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="op">*</span>buff <span class="op">=</span> malloc<span class="op">(</span>n<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  Queue q <span class="op">=</span> <span class="op">{</span>buff<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span>n<span class="op">};</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  Queue <span class="op">*</span>qptr <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>Queue<span class="op">));</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>qptr <span class="op">=</span> q<span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> qptr<span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> put<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>buf<span class="op">[</span>q<span class="op">-&gt;</span>inp<span class="op">]</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>inp <span class="op">=</span> <span class="op">(</span>q<span class="op">-&gt;</span>inp <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> get<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> q<span class="op">-&gt;</span>buf<span class="op">[</span>q<span class="op">-&gt;</span>outp<span class="op">];</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>outp <span class="op">=</span> <span class="op">(</span>q<span class="op">-&gt;</span>outp <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>q<span class="op">-&gt;</span>inp <span class="op">-</span> q<span class="op">-&gt;</span>outp<span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the C code doesn’t do any error checking, e.g. if we
<code>get</code> from an empty queue then we’ll get back uninitialised
memory.</p>
<h5 id="model-1">Model</h5>
<p>The circular buffer implementation is very efficient, because it
reuses the allocated memory as we go around in circles, but it’s not
obviously correct.</p>
<p>To model queues we’ll use a more straight forward non-circular
implementation. This is less efficient (doesn’t matter as it’s merely
used during testing), but hopefully more obviously correct.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FQueue</span> <span class="ot">=</span> <span class="dt">FQueue</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> fqElems ::</span> [<span class="dt">Int</span>]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> fqSize  ::</span> <span class="dt">Int</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>In the <code>Counter</code> example above we only had one counter, so
the model was merely a single integer. In this example, because of
<code>new</code> returning a queue, we need to be able to model
arbitrary many queues. We can do this using symbolic references
(<code>data Var a = Var Int</code>) as follows:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Map</span> (<span class="dt">Var</span> <span class="dt">Queue</span>) <span class="dt">FQueue</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyState ::</span> <span class="dt">State</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>emptyState <span class="ot">=</span> Map.empty</span></code></pre></div>
<p>Where <code>Queue</code> is the Haskell data type that corresponds to
the C <code>Queue</code> and the <code>Var a</code> data type is
provided by the library and is a symbolic reference to <code>a</code>
(just an <code>Int</code>eger). The idea being that in the model we
don’t have access to real <code>Queue</code>s, merely symbolic
references to them. This might seem a bit strange, but I hope that it
will become more clear when we model <code>new</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FakeOp</span> a <span class="ot">=</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> (<span class="dt">State</span>, a)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fNew ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> (<span class="dt">Var</span> <span class="dt">Queue</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>fNew sz s <span class="ot">=</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    v  <span class="ot">=</span> <span class="dt">Var</span> (Map.size s)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    s&#39; <span class="ot">=</span> Map.insert v (<span class="dt">FQueue</span> [] sz) s</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (s&#39;, v)</span></code></pre></div>
<p>As we have access to the state when defining our model, we can create
new unique symbolic references by simply counting how many symbolic
references we’ve created previously (using <code>Map.size</code>)<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<p>As we said before, in the C code we don’t do any error checking. In
the model we do check that, for example, the queue is non-empty before
we <code>fGet</code> an item. These are our preconditions.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Err</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">QueueDoesNotExist</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">QueueIsEmpty</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fPut ::</span> <span class="dt">Var</span> <span class="dt">Queue</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> ()</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>fPut q i s</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> q <span class="ot">`Map.notMember`</span> s <span class="ot">=</span> <span class="dt">Left</span> <span class="dt">QueueDoesNotExist</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">return</span> (Map.adjust (\fq <span class="ot">-&gt;</span> fq { fqElems <span class="ot">=</span> fqElems fq <span class="op">++</span> [i] }) q s, ())</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="ot">fGet ::</span> <span class="dt">Var</span> <span class="dt">Queue</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> <span class="dt">Int</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>fGet q s</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> q <span class="ot">`Map.notMember`</span> s <span class="ot">=</span> <span class="dt">Left</span> <span class="dt">QueueDoesNotExist</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">case</span> fqElems (s <span class="op">Map.!</span> q) <span class="kw">of</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>      []     <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="dt">QueueIsEmpty</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>      i <span class="op">:</span> is <span class="ot">-&gt;</span> <span class="fu">return</span> (Map.adjust (\fq <span class="ot">-&gt;</span> fq { fqElems <span class="ot">=</span> is }) q s, i)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="ot">fSize ::</span> <span class="dt">Var</span> <span class="dt">Queue</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> <span class="dt">Int</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>fSize q s</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> q <span class="ot">`Map.notMember`</span> s <span class="ot">=</span> <span class="dt">Left</span> <span class="dt">QueueDoesNotExist</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>           <span class="ot">=</span> <span class="fu">return</span> (s, <span class="fu">length</span> (fqElems (s <span class="op">Map.!</span> q)))</span></code></pre></div>
<p>Recall that we won’t generate a get operation unless the precondition
holds in the state that we are currently in, i.e. we will never generate
gets if the queue is empty and thus we’ll never execute the C code for
<code>get</code> which gives back uninitialised memory.</p>
<p>Having defined our model the interface implementation is almost
mechanical.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
<p>The only new thing worth paying attention to is the <code>q</code> in
<code>Command</code> and <code>Response</code>, which is parametrised so
that it works for both symbolic and real references. The
<code>Functor</code> instance let’s us to substitution, while
<code>Foldable</code> let’s us extract all new references from a
response, so that we can substitute them in later
<code>Command</code>s.</p>
<h5 id="testing">Testing</h5>
<p>Having implemented the interface, we can write our property as
follows.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_queue ::</span> <span class="dt">Commands</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>prop_queue cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span></code></pre></div>
<p>When we run it, using <code>quickCheck prop_queue</code>, we get the
following error.</p>
<pre><code>   *** Failed! Assertion failed (after 7 tests and 5 shrinks):
    Commands {unCommands = [New 1,Put (Var 0) 0,Put (Var 0) 1,Get (Var 0)]}
    New 1 --&gt; New_ (Queue 0x00000000016e9010)
    Put (Var 0) 0 --&gt; Put_ ()
    Put (Var 0) 1 --&gt; Put_ ()
    Get (Var 0) --&gt; Get_ 1
    Expected: Get_ 0
    Got: Get_ 1</code></pre>
<p>So we create a new queue of size <code>1</code>, put two items
(<code>0</code> and <code>1</code>) into it, and finally we read a value
from the queue and this is where the assertion fails. Or model returns
<code>0</code>, because it’s a FIFO queue, but the C code returns
<code>1</code>. The reason for this is that in the C code there’s no
error checking, so writing a value to a full queue simply overwrites the
oldest value. So there’s actually nothing wrong with the implementation,
but rather the model is wrong. We’ve forgotten a precondition:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a> data Err</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>   = QueueDoesNotExist</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>   | QueueIsEmpty</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="va">+  | QueueIsFull</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>fPut :: Var Queue -&gt; Int -&gt; State -&gt; Either Err (State, ())</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>fPut q i s</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  | q `Map.notMember` s = Left QueueDoesNotExist</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="va">+ | length (fqElems (s Map.! q)) &gt;= fqSize (s Map.! q) = Left QueueIsFull</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  | otherwise = return (Map.adjust (\fq -&gt; fq { fqElems = fqElems fq ++ [i] }) q s, ())</span></code></pre></div>
<p>We can add the counterexample that we got as a regression test to our
test suite as follows:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit_queueFull ::</span> <span class="dt">IO</span> ()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>unit_queueFull <span class="ot">=</span> quickCheck (withMaxSuccess <span class="dv">1</span> (expectFailure (prop_queue cmds)))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    cmds <span class="ot">=</span> <span class="dt">Commands</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">New</span> <span class="dv">1</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Put</span> (<span class="dt">Var</span> <span class="dv">0</span>) <span class="dv">1</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Put</span> (<span class="dt">Var</span> <span class="dv">0</span>) <span class="dv">0</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Get</span> (<span class="dt">Var</span> <span class="dv">0</span>)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>Notice that we can basically copy-paste <code>cmds</code> from
QuickCheck’s output, but I’ve done some formatting here to make it more
readable.</p>
<p>After fixing the precondition for <code>fPut</code>,
<code>unit_queueFull</code> fails as follows:</p>
<pre><code>+++ OK, failed as expected. Assertion failed (after 1 test):
New 1 --&gt; New_ (Queue 0x00000000006f6d20)
Put (Var 0) 1 --&gt; Put_ ()
Preconditon failed: QueueIsFull</code></pre>
<p>When we rerun <code>quickCheck prop_queue</code> we will not generate
this example again, because all preconditions need to hold, and the
property passes:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
+++ OK, passed 100 tests:
95% New
86% Put
67% Get

Commands (2497 in total):
44.13% New
41.25% Put
14.62% Get</code></pre>
<p>However as we can see in the output there’s no coverage for
<code>Size</code>! The reason for this is because we’ve forgot to add it
to our generator:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  generateCommand s</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    | Map.null s = New . getPositive &lt;$&gt; arbitrary</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    | otherwise  = oneof</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>      [ New . getPositive &lt;$&gt; arbitrary</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>      , Put  &lt;$&gt; arbitraryQueue &lt;*&gt; arbitrary</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>      , Get  &lt;$&gt; arbitraryQueue</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="va">+     , Size &lt;$&gt; arbitraryQueue</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>After adding it and rerunning the property, we get the following
error:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
*** Failed! Assertion failed (after 25 tests and 8 shrinks):
Commands {unCommands = [New 1,Put (Var 0) 0,Size (Var 0)]}
New 1 --&gt; New_ (Queue 0x0000000001444220)
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ 0
Expected: Size_ 1
Got: Size_ 0</code></pre>
<p>Size should return how many items are in the queue, so after we put
one item into a queue we expect it to return <code>1</code>, but in the
above counterexample it returns <code>0</code>.</p>
<p>To understand why this happens we have to look at how
<code>put</code> and <code>size</code> are implemented:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> put<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>buf<span class="op">[</span>q<span class="op">-&gt;</span>inp<span class="op">]</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>inp <span class="op">=</span> <span class="op">(</span>q<span class="op">-&gt;</span>inp <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>q<span class="op">-&gt;</span>inp <span class="op">-</span> q<span class="op">-&gt;</span>outp<span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In <code>put</code> when we do
<code>q-&gt;inp = (q-&gt;inp + 1) % q-&gt;size</code> we get
<code>q-&gt;inp = (0 + 1) % 1 == 0</code> and then when we calculate the
<code>size</code> we get <code>(0 - 0) % 1 == 0</code>. One way to fix
this is to make <code>q-&gt;size</code> be <code>n + 1</code> rather
than <code>n</code> where <code>n</code> is the size parameter of
<code>new</code>, that way <code>put</code> will do
<code>q-&gt;inp = (0 + 1) % 2 == 1</code> instead and size will be
<code>1 - 0 % 2 == 1</code> which is correct. Here’s the diff:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>  Queue *new(int n) {</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="st">-   int *buff = malloc(n*sizeof(int));</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="st">-   Queue q = {buff,0,0,n};</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="va">+   int *buff = malloc((n + 1)*sizeof(int));</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="va">+   Queue q = {buff,0,0,n + 1};</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    Queue *qptr = malloc(sizeof(Queue));</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    *qptr = q;</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    return qptr;</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>As before, we can add a regression test for the size issue as
follows:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit_queueSize ::</span> <span class="dt">IO</span> ()</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>unit_queueSize <span class="ot">=</span> quickCheck (withMaxSuccess <span class="dv">1</span> (prop_queue cmds))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    cmds <span class="ot">=</span> <span class="dt">Commands</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">New</span> <span class="dv">1</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Put</span> (<span class="dt">Var</span> <span class="dv">0</span>) <span class="dv">0</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Size</span> (<span class="dt">Var</span> <span class="dv">0</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>After the change to <code>new</code> this test passes, but if we
rerun the property we get the following error:</p>
<pre><code>*** Failed! Assertion failed (after 38 tests and 12 shrinks):
Commands {unCommands = [New 1,Put (Var 0) 0,Get (Var 0),Put (Var 0) 0,Size (Var 0)]}
New 1 --&gt; New_ (Queue 0x00007fd47c00a920)
Put (Var 0) 0 --&gt; Put_ ()
Get (Var 0) --&gt; Get_ 0
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ (-1)
Expected: Size_ 1
Got: Size_ (-1)</code></pre>
<p>After the second <code>put</code> we’ll have
<code>q-&gt;inp = (1 + 1) % 2 == 0</code> while
<code>q-&gt;outp = 1</code> due to the <code>get</code> and so when we
call <code>size</code> we get <code>0 - 1 % 2 == -1</code>. Taking the
absolute value:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  int size(Queue *q) {</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="st">-   return (q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="va">+   return abs(q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Makes this test case pass, and in fact it also makes the property
pass:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
+++ OK, passed 100 tests:
93% New
79% Put
74% Size
59% Get

Commands (2340 in total):
32.09% New
29.06% Size
28.25% Put
10.60% Get</code></pre>
<p>John says that at this point most programmers would probably be happy
and believe that their implementation works, but if we rerun it again
(or increase the amount of tests generated), we get:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
*** Failed! Assertion failed (after 56 tests and 19 shrinks):
Commands {unCommands = [New 2,Put (Var 0) 0,Put (Var 0) 0,Get (Var 0),Put (Var 0) 0,Size (Var 0)]}
New 2 --&gt; New_ (Queue 0x00007fbf4c006490)
Put (Var 0) 0 --&gt; Put_ ()
Put (Var 0) 0 --&gt; Put_ ()
Get (Var 0) --&gt; Get_ 0
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ 1
Expected: Size_ 2
Got: Size_ 1</code></pre>
<p>We can see that all queues of size <code>1</code> now work, because
this test starts by creating a queue of size <code>2</code>, so we’ve
made progress. But taking the absolute value isn’t the correct way to
calculate the size (even though it works for queues of size
<code>1</code>), the following is the correct way to do it:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>  int size(Queue *q) {</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="st">-   return abs(q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="va">+   return (q-&gt;inp - q-&gt;outp + q-&gt;size) % q-&gt;size;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>With this final tweak, the property passes. I hope that this somewhat
long example gives you a feel for how property-based testing drives the
development and debugging of the code.</p>
<h4 id="example-jug-puzzle-from-die-hard-3">Example: jug puzzle from Die
Hard 3</h4>
<p>In the movie Die Hard 3 there’s an <a
href="https://www.youtube.com/watch?v=BVtQNK_ZUJg">scene</a> where Bruce
Willis and Samuel L. Jackson have to solve a puzzle in order to stop a
bomb from going off. The puzzle is: given a 3L and a 5L jug, how can you
measure exactly 4L?</p>
<p>I first saw this example solved using TLA+ and I wanted to include it
here because it shows that we don’t necessarily need a real
implementation, merely running the model/fake can be useful.</p>
<p>The main idea is to model the two jugs and all actions we can do with
them and then throw an exception when the big jug contains 4L. This will
fail the test and output the shrunk sequence of actions that resulted in
the failure, giving us the solution to the puzzle.</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Model</span> <span class="ot">=</span> <span class="dt">Model</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> bigJug   ::</span> <span class="dt">Int</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> smallJug ::</span> <span class="dt">Int</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> <span class="dt">Model</span> <span class="kw">where</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>  initialState <span class="ot">=</span> <span class="dt">Model</span> <span class="dv">0</span> <span class="dv">0</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span> <span class="dt">Model</span> <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span> <span class="dt">Model</span> r</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">FillBig</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">FillSmall</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">EmptyBig</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">EmptySmall</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">SmallIntoBig</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">BigIntoSmall</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span> <span class="dt">Model</span> r <span class="ot">=</span> <span class="dt">Done</span> <span class="op">|</span> <span class="dt">BigJugIs4</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommand ::</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> <span class="dt">Model</span> r)</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>  generateCommand _s <span class="ot">=</span> elements [<span class="fu">minBound</span> <span class="op">..</span>]</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a><span class="ot">  runFake ::</span> <span class="dt">Command</span> <span class="dt">Model</span> r <span class="ot">-&gt;</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> void (<span class="dt">Model</span>, <span class="dt">Response</span> <span class="dt">Model</span> r)</span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">FillBig</span>      s <span class="ot">=</span> done s { bigJug   <span class="ot">=</span> <span class="dv">5</span> }</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">FillSmall</span>    s <span class="ot">=</span> done s { smallJug <span class="ot">=</span> <span class="dv">3</span> }</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">EmptyBig</span>     s <span class="ot">=</span> done s { bigJug   <span class="ot">=</span> <span class="dv">0</span> }</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">EmptySmall</span>   s <span class="ot">=</span> done s { smallJug <span class="ot">=</span> <span class="dv">0</span> }</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">SmallIntoBig</span> (<span class="dt">Model</span> big small) <span class="ot">=</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> big&#39; <span class="ot">=</span> <span class="fu">min</span> <span class="dv">5</span> (big <span class="op">+</span> small) <span class="kw">in</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>    done (<span class="dt">Model</span> { bigJug <span class="ot">=</span> big&#39;</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>                , smallJug <span class="ot">=</span> small <span class="op">-</span> (big&#39; <span class="op">-</span> big) })</span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">BigIntoSmall</span> (<span class="dt">Model</span> big small) <span class="ot">=</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> small&#39; <span class="ot">=</span> <span class="fu">min</span> <span class="dv">3</span> (big <span class="op">+</span> small) <span class="kw">in</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>    done (<span class="dt">Model</span> { bigJug <span class="ot">=</span> big <span class="op">-</span> (small&#39; <span class="op">-</span> small)</span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>                , smallJug <span class="ot">=</span> small&#39;</span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>                })</span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a><span class="ot">  runReal ::</span> <span class="dt">Command</span> <span class="dt">Model</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">Model</span> (<span class="dt">Reference</span> <span class="dt">Model</span>))</span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a>  runReal _cmd <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Done</span></span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a><span class="ot">  monitoring ::</span> (<span class="dt">Model</span>, <span class="dt">Model</span>) <span class="ot">-&gt;</span> <span class="dt">Command</span> <span class="dt">Model</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="dt">Model</span> <span class="dt">Void</span></span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Property</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>  monitoring (_s, s&#39;) _cmd _resp <span class="ot">=</span></span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a>    counterexample <span class="op">$</span> <span class="st">&quot;\n    State: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s&#39; <span class="op">++</span> <span class="st">&quot;\n&quot;</span></span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-51"><a href="#cb47-51" aria-hidden="true" tabindex="-1"></a><span class="ot">done ::</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> void (<span class="dt">Model</span>, <span class="dt">Response</span> <span class="dt">Model</span> ref)</span>
<span id="cb47-52"><a href="#cb47-52" aria-hidden="true" tabindex="-1"></a>done s&#39; <span class="op">|</span> bigJug s&#39; <span class="op">==</span> <span class="dv">4</span> <span class="ot">=</span> <span class="fu">return</span> (s&#39;, <span class="dt">BigJugIs4</span>)</span>
<span id="cb47-53"><a href="#cb47-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="fu">return</span> (s&#39;, <span class="dt">Done</span>)</span>
<span id="cb47-54"><a href="#cb47-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-55"><a href="#cb47-55" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_dieHard ::</span> <span class="dt">Commands</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb47-56"><a href="#cb47-56" aria-hidden="true" tabindex="-1"></a>prop_dieHard cmds <span class="ot">=</span> withMaxSuccess <span class="dv">10000</span> <span class="op">$</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb47-57"><a href="#cb47-57" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb47-58"><a href="#cb47-58" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span></code></pre></div>
<p>When we run <code>quickcheck prop_dieHard</code> we get the following
output:</p>
<pre><code>   +++ OK, failed as expected. Assertion failed (after 199 tests and 11 shrinks):
    Commands [FillBig,BigIntoSmall,EmptySmall,BigIntoSmall,FillBig,BigIntoSmall]
    FillBig --&gt; Done

        State: Model {bigJug = 5, smallJug = 0}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 2, smallJug = 3}

    EmptySmall --&gt; Done

        State: Model {bigJug = 2, smallJug = 0}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 0, smallJug = 2}

    FillBig --&gt; Done

        State: Model {bigJug = 5, smallJug = 2}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 4, smallJug = 3}

    Expected: BigJugIs4
    Got: Done</code></pre>
<p>Notice how the trace shows the intermediate states, making it easy to
verify that it’s indeed a correct solution to the puzzle<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<h3 id="parallel-property-based-testing-in-230-loc">Parallel
property-based testing in ~230 LOC</h3>
<p>Let’s now turn our focus to parallel property-based testing.</p>
<p>Debugging buggy concurrent code is not fun. The main reason for this
is that the threads interleave in different ways between executions,
making it hard to reproduce the bug and hard to verify that a bug fix
actually worked.</p>
<p>Ideally we’d like to make working with concurrent code as pleasant as
the sequential stateful case and without the user having to write any
additional test code.</p>
<p>In order to explain how we can achieve this, we need to first
understand how we can test concurrent code in a reproducible way.</p>
<p>Recall our <code>Counter</code> that we looked at in the sequential
testing case. Here we’ll be using a slight generalisation where the
<code>incr</code> takes an integer parameter which specifies by how much
we want to increment (as opposed to always incrementing by
<code>1</code>).</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> incr <span class="dv">1</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> incr <span class="dv">2</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> get</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<p>When we interact with the counter sequentially, i.e. one command at
the time, then it appears to count correctly.</p>
<p>But if we instead concurrently issue the <code>incr</code>ements , we
see something strange:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span> forM_ [<span class="dv">0</span><span class="op">..</span><span class="dv">100000</span>] <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span>   c <span class="ot">&lt;-</span> newCounter</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span>   concurrently_ (incr c <span class="dv">1</span>) (incr c <span class="dv">2</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span>   x <span class="ot">&lt;-</span> get c</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span>   <span class="kw">if</span> x <span class="op">==</span> <span class="dv">3</span> <span class="kw">then</span> <span class="fu">return</span> () <span class="kw">else</span> <span class="fu">error</span> (<span class="st">&quot;i = &quot;</span> <span class="op">++</span> <span class="fu">show</span> i <span class="op">++</span> <span class="st">&quot;, x = &quot;</span> <span class="op">++</span> <span class="fu">show</span> x)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a> <span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> i <span class="ot">=</span> <span class="dv">29768</span>, x <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>After 29768 iterations we get back <code>1</code> rather than the
expected <code>3</code>! The reason for this is because there’s a race
condition in the implementation of <code>incr</code>:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a> incr i <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>   j <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>   writeIORef gLOBAL_COUNTER (i <span class="op">+</span> j)</span></code></pre></div>
<p>Because we first read the old value and <em>then</em> write the new
incremented value in an non-atomic way, it’s possible that if two
threads do this at the same time they overwrite each others increment.
For example:</p>
<pre><code>   thread 1, incr 1     |  thread 2, incr 2
   ---------------------+------------------
    0 &lt;- readIORef      |
                        | 0 &lt;- readIORef
                        | writeIORef (2 + 0)
    writeIORef (1 + 0)  |
                        |
                        v
                       time</code></pre>
<p>If we read from the counter after the two increments are done we get
<code>1</code> instead of the expected <code>3</code>. The fix to this
problem is to do an atomic update using <code>atomicModifyIORef'</code>,
instead of first reading and then writing to the <code>IORef</code>.</p>
<p>The concurrent test that we just wrote is not only specific to the
counter example but also only uses three fixed commands, the two
concurrent <code>incr</code>ements followed by a <code>get</code>. While
it was enough to find this race condition, in general we’d like to try
arbitrary combinations of commands and possibly involving more than two
threads.</p>
<p>The key concept we need in order to accomplish that is that of
<em>concurrent history</em>, which is perhaps easiest to explain in
terms of a more familiar concept: a sequence diagram.</p>
<p>Consider the following sequence diagram:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/sequence-diagram.svg"
width=60%></p>
<p>Here we see that the first and second thread concurrently increment,
the first thread then reads the counter concurrently with the second
thread’s increment that’s still going on. The second thread’s increment
finishes and a third thread does a read which is concurrent with the
first thread’s read.</p>
<p>We can abstract away the arrows and merely focus on the intervals of
the commands:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/history-from-sequence-diagram.svg"
width=60%></p>
<p>If we rotate the intervals we get the concurrent history:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter.svg"
width=60%></p>
<p>Note that the execution of some commands overlap in time, this is
what’s meant by concurrent and arguably it’s easier to see the overlap
here than in the original sequence diagram.</p>
<p>We’ve also abstracted away the counter, it’s a black box from the
perspective of the threads. The only thing we know for sure is when we
invoked the operation and when it returned, which is what our interval
captures. We also know that the effect of the operation must have
happened sometime within that interval.</p>
<p>One such concurrent history can have different interleavings,
depending on when exactly the effect of the commands happen. Here are
two possible interleavings, where the red cross symbolises when the
effect happened (i.e. when exactly the counter update its state).</p>
<p>The first corresponds to the sequential history
<code>&lt; incr 1, get, incr 2, get &gt;</code>:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter_get_1_3.svg"
width=60%></p>
<p>and the other interleaving corresponds to the sequential history
<code>&lt; incr 1, incr 2, get, get &gt;</code>:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter_get_3_3.svg"
width=60%></p>
<p>One last thing we’ve left out from the concurrent history so far is
the responses. In this example, the only interesting responses are those
of the <code>get</code>s.</p>
<p>Let’s say that the <code>get</code>s returned <code>1</code> and
<code>3</code> respectively. Is this a correct concurrent outcome? Yes,
according to linearisability it’s enough to find a single interleaving
for which the sequential state machine model can explain the outcome and
in this case the first interleaving above
<code>&lt; incr 1, get, incr 2, get &gt;</code> does that.</p>
<p>What if the <code>get</code>s both returned <code>3</code>? That’s
also correct and witnessed by the second interleaving
<code>&lt; incr 1, incr 2, get, get &gt;</code>. When we can find a
sequential interleaving that supports the outcome of a concurrent
execution we say that the concurrent history linearises.</p>
<p>If the <code>get</code> on the third thread returned <code>1</code>
or <code>2</code> however, then it would be a non-linearisable outcome.
We can see visually that that <code>get</code> happens after both
<code>incr</code>, so no matter where we choose to place the red crosses
on the <code>incr</code>s the effects will happen before that
<code>get</code> so it must return <code>3</code>. Is it even possible
that <code>1</code> or <code>2</code> are returned? It’s, imagine if
<code>incr</code> is implemented by first reading the current value then
storing the incremented value, in that case there can be a race where
the <code>incr</code>s overwrite each other.</p>
<p>So to summarise, we execute commands concurrently using several
threads and gather a concurrent history of the execution. We then try to
find a sequential interleaving (a choice of where the red crosses in the
diagrams should be) which respects the a sequential state machine model
specification. If we find a single one that does, then we say that the
history linearises and that the concurrent execution is correct, if we
cannot find a sequential interleaving that respects the model then the
history doesn’t linearise and we have found a problem.</p>
<h4 id="parallel-library-implementation">Parallel library
implementation</h4>
<p>Let’s try to implement the above. We’ll split up the implementation
in three parts. First we’ll show how to generate and shrink parallel
commands, these will be different than the sequential commands as we
have more than one thread that does the execution. Second we’ll
implement linearisability checking by trying to find an interleaving of
the concurrent history which respects the sequential model. Finally,
we’ll have a look at how to execute the generated parallel commands to
produce a concurrent history.</p>
<h5 id="parallel-program-generation-and-shrinking">Parallel program
generation and shrinking</h5>
<p>First we need define what a parallel program is:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ParallelCommands</span> state <span class="ot">=</span> <span class="dt">ParallelCommands</span> [<span class="dt">Fork</span> state]</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fork</span> state <span class="ot">=</span> <span class="dt">Fork</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span></code></pre></div>
<p>The idea is that the commands inside <code>Fork</code>s get executed
in parallel, this list will only be between one and three commands long,
i.e. capturing single, double or triple threaded execution. The amount
of <code>Fork</code>s themselves vary with the size of the test case,
just like when we were doing the sequential testing.</p>
<p>Depending on the order in which the commands in the
<code>Fork</code>s get executed, we can potentially get different
models. For example
<code>Fork [Write "a" "foo", Write "a" "bar"]</code>, depending on which
branch of the <code>Fork</code> gets executed first we might end up with
either <code>"foo"</code> or <code>"bar"</code> being written to
<code>"a"</code>.</p>
<p>Because of this, we have generalised generation and shrinking to work
on a set of states rather than just a single state:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">StateModel</span> state, <span class="dt">Ord</span> state) <span class="ot">=&gt;</span> <span class="dt">ParallelModel</span> state <span class="kw">where</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommandParallel ::</span> [state] <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  generateCommandParallel ss <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    s <span class="ot">&lt;-</span> elements ss</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    generateCommand s</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  shrinkCommandParallel ::</span> [state] <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>                        <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>  shrinkCommandParallel ss cmd <span class="ot">=</span> shrinkCommand (<span class="fu">maximum</span> ss) cmd</span></code></pre></div>
<p>Notice that the default implementation for generation, which should
be good enough for most examples, picks an arbitrary state and reuses
the generation function from the sequential case. Similar shrinking
picks the biggest state (determined by the <code>Ord</code> instance) as
the default implementation. The user is able to override these defaults,
in case generation or shrinking depends on some more specific state.</p>
<p>We can now write a generator for parallel programs.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> (<span class="dt">ParallelCommands</span> state)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> <span class="dt">ParallelCommands</span> <span class="op">&lt;$&gt;</span> go [initialState]</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      go ::</span> [state] <span class="ot">-&gt;</span> <span class="dt">Gen</span> [<span class="dt">Fork</span> state]</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>      go ss <span class="ot">=</span> sized <span class="op">$</span> \n <span class="ot">-&gt;</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>          w <span class="ot">=</span> n <span class="ot">`div`</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>          frequency</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>            [ (<span class="dv">1</span>, <span class="fu">return</span> [])</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>            , (w, <span class="kw">do</span> k <span class="ot">&lt;-</span> frequency [ (<span class="dv">50</span>, <span class="fu">return</span> <span class="dv">1</span>) <span class="co">-- 50% single threaded</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>                                    , (<span class="dv">30</span>, <span class="fu">return</span> <span class="dv">2</span>) <span class="co">-- 30% double threaded</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>                                    , (<span class="dv">20</span>, <span class="fu">return</span> <span class="dv">3</span>) <span class="co">-- 20% triple threaded</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>                                    ]</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>                     mCmds <span class="ot">&lt;-</span> vectorOf k (generateCommandParallel ss)</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>                                <span class="ot">`suchThatMaybe`</span> (parallelSafe ss <span class="op">.</span> <span class="dt">Fork</span>)</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">case</span> mCmds <span class="kw">of</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="fu">return</span> []</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Just</span> cmds <span class="ot">-&gt;</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>                         (<span class="dt">Fork</span> cmds <span class="op">:</span>) <span class="op">&lt;$&gt;</span> go (nextStates ss cmds))</span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>            ]</span></code></pre></div>
<p>Where <code>nextStates</code> gives all potential next states and is
defined as follows.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nextStates ::</span> (<span class="dt">StateModel</span> state, <span class="dt">Ord</span> state)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=&gt;</span> [state] <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))] <span class="ot">-&gt;</span> [state]</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>nextStates ss cmds <span class="ot">=</span> nubOrd [ foldl&#39; nextState s cmds <span class="op">|</span> s <span class="ot">&lt;-</span> ss ]</span></code></pre></div>
<p>The other helper function that we need for generation is
<code>parallelSafe</code>, which requires a bit of background.</p>
<p>In the sequential case a precondition is a contract that needs to be
fulfilled by the client before the command is issued. In the parallel
case there are multiple clients, so it could be the case that one client
unknowingly breaks another clients precondition.</p>
<p>E.g. <code>Fork [Write "a" "foo", Delete "a"]</code>, where the
precondition for both commands is that <code>"a"</code> exists. If
<code>Delete</code> gets executed first then it would break
<code>Write</code>’s precondition.</p>
<p>One idea might be to drop all preconditions in the parallel case and
make all commands be able to fail gracefully instead of crashing, e.g.
<code>Write_ (Either DoesntExist ())</code>.</p>
<p>XXX: make counter or queue example into one of such examples:</p>
<p>The problem with this approach is that examples such as the ticket
dispenser have initialisation commands such as <code>New</code> which
create a ticket dispenser reference upon which the later commands depend
on, so without preconditions forbidding more than one <code>New</code>
we can end up generating: <code>Fork New New</code>, which doesn’t make
sense. It should also be noted that making <code>New</code> fail
gracefully when a <code>New</code> has already been executed would need
a global boolean flag, which is ugly.</p>
<p>The solution to the precondition problem is to check that they hold
in all possible interleavings of a <code>Fork</code>, which is what
<code>parallelSafe</code> does:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parallelSafe ::</span> <span class="dt">ParallelModel</span> state <span class="ot">=&gt;</span> [state] <span class="ot">-&gt;</span> <span class="dt">Fork</span> state <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>parallelSafe ss (<span class="dt">Fork</span> cmds0) <span class="ot">=</span> <span class="fu">and</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  [ preconditionsHold s cmds <span class="op">|</span> s <span class="ot">&lt;-</span> toList ss, cmds <span class="ot">&lt;-</span> permutations cmds0 ]</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    preconditionsHold s0 <span class="ot">=</span> <span class="fu">all</span> (go s0) <span class="op">.</span> permutations</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        go _s [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        go  s (cmd <span class="op">:</span> cmds)</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> precondition s cmd <span class="ot">=</span> go (nextState s cmd) cmds</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span>          <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>While shrinking we also use <code>parallelSafe</code>:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  shrink ::</span> <span class="dt">ParallelCommands</span> state <span class="ot">-&gt;</span> [<span class="dt">ParallelCommands</span> state]</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  shrink <span class="ot">=</span> pruneShrinks <span class="op">.</span> possibleShrinks</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      possibleShrinks ::</span> <span class="dt">ParallelCommands</span> state <span class="ot">-&gt;</span> [<span class="dt">ParallelCommands</span> state]</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>      possibleShrinks</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">=</span> <span class="fu">map</span> (coerce <span class="op">.</span> <span class="fu">map</span> (<span class="fu">map</span> <span class="fu">fst</span>))</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span> shrinkList (shrinkList shrinker) <span class="op">.</span> withParStates <span class="op">.</span> unParallelCommands</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="ot">          withParStates ::</span> (<span class="dt">StateModel</span> state, <span class="dt">Ord</span> state)</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>                        <span class="ot">=&gt;</span> [<span class="dt">Fork</span> state]</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>                        <span class="ot">-&gt;</span> [[(<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)), [state])]]</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>          withParStates <span class="ot">=</span> go [initialState] [] <span class="op">.</span> coerce</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>              go _ss acc []             <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>              go  ss acc (cmds <span class="op">:</span> cmdss) <span class="ot">=</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>                go (nextStates ss cmds) (<span class="fu">map</span> (\cmd <span class="ot">-&gt;</span> (cmd, ss)) cmds <span class="op">:</span> acc) cmdss</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a><span class="ot">          shrinker ::</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)), [state])</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">-&gt;</span> [(<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)), [state])]</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>          shrinker (cmd, ss) <span class="ot">=</span> [ (cmd&#39;, ss) <span class="op">|</span> cmd&#39; <span class="ot">&lt;-</span> shrinkCommandParallel ss cmd ]</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a><span class="ot">      pruneShrinks ::</span> [<span class="dt">ParallelCommands</span> state] <span class="ot">-&gt;</span> [<span class="dt">ParallelCommands</span> state]</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>      pruneShrinks <span class="ot">=</span> coerce <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span>)</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>                   <span class="op">.</span> <span class="fu">map</span> (go [initialState] Set.empty [] <span class="op">.</span> unParallelCommands)</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a><span class="ot">          go ::</span> [state] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Var</span> (<span class="dt">Reference</span> state)) <span class="ot">-&gt;</span> [<span class="dt">Fork</span> state] <span class="ot">-&gt;</span> [<span class="dt">Fork</span> state] <span class="ot">-&gt;</span> [<span class="dt">Fork</span> state]</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>          go _ss _vars acc [] <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>          go  ss  vars acc (fork<span class="op">@</span>(<span class="dt">Fork</span> cmds) <span class="op">:</span> forks)</span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">all</span> (scopeCheck vars) cmds</span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>            , parallelSafe ss fork <span class="ot">=</span></span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span></span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>                ss&#39;   <span class="ot">=</span> nextStates ss cmds</span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>                vars&#39; <span class="ot">=</span> getReturnedVars (<span class="fu">head</span> ss) vars cmds <span class="co">-- </span><span class="al">NOTE</span><span class="co">: head is safe</span></span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span></span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a>                go ss&#39; vars&#39; (fork <span class="op">:</span> acc) forks</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>            <span class="ot">=</span> go ss vars acc forks</span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-38"><a href="#cb58-38" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- It doesn&#39;t matter which of the possible states we start in, as all</span></span>
<span id="cb58-39"><a href="#cb58-39" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- commands in a fork pass their preconditions in all states. It also</span></span>
<span id="cb58-40"><a href="#cb58-40" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- doesn&#39;t matter in which interleaving we gather the responses, as</span></span>
<span id="cb58-41"><a href="#cb58-41" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- all we do is collect the `Var`s that get returned into an unordered</span></span>
<span id="cb58-42"><a href="#cb58-42" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- `Set`.</span></span>
<span id="cb58-43"><a href="#cb58-43" aria-hidden="true" tabindex="-1"></a>          getReturnedVars _s vars [] <span class="ot">=</span> vars</span>
<span id="cb58-44"><a href="#cb58-44" aria-hidden="true" tabindex="-1"></a>          getReturnedVars s vars (cmd <span class="op">:</span> cmds) <span class="ot">=</span> <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb58-45"><a href="#cb58-45" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Left</span> _preconditionFailed <span class="ot">-&gt;</span></span>
<span id="cb58-46"><a href="#cb58-46" aria-hidden="true" tabindex="-1"></a>              <span class="fu">error</span> <span class="st">&quot;getReturnedVars: impossible, parallelSafe checks that all preconditions hold&quot;</span></span>
<span id="cb58-47"><a href="#cb58-47" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Right</span> (_s&#39;, resp) <span class="ot">-&gt;</span></span>
<span id="cb58-48"><a href="#cb58-48" aria-hidden="true" tabindex="-1"></a>              getReturnedVars s (vars <span class="ot">`Set.union`</span> Set.fromList (toList resp)) cmds</span></code></pre></div>
<p>In addition we also check that shrinking doesn’t create any scoping
issues, i.e. if we remove a command which creates a symbolic variable we
also need to remove any fork that contains a command which uses said
symbolic variable.</p>
<p>Another option is to skip the scope checking and instead require the
user to explicitly require preconditions which ensure the scope.</p>
<h5 id="parallel-running">Parallel running</h5>
<p>One final difference in the parallel case is that because of the use
of threads to achieve parallel execution, and the fact we can only spawn
threads of things of type <code>IO</code>, we also need to be able to
interpret our <code>CommandMonad</code> into <code>IO</code>, which is
what <code>runCommandMonad</code> does.</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- If another command monad is used we need to provide a way run it inside the</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- IO monad. This is only needed for parallel testing, because IO is the only</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- monad we can execute on different threads.</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  runCommandMonad ::</span> proxy state <span class="ot">-&gt;</span> <span class="dt">CommandMonad</span> state a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>We can now implement parallel execution of commands as follows:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">History</span> state <span class="ot">=</span> <span class="dt">History</span> [<span class="dt">Event</span> state]</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> stock <span class="kw">instance</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>   (<span class="dt">Show</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))),</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Show</span> (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">History</span> state)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Event</span> state</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Invoke</span> <span class="dt">Pid</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Ok</span>     <span class="dt">Pid</span> (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> stock <span class="kw">instance</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Show</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))),</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Show</span> (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Event</span> state)</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Pid</span> <span class="ot">=</span> <span class="dt">Pid</span> <span class="dt">Int</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> <span class="dt">Enum</span></span></code></pre></div>
<div class="sourceCode" id="cb61"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runParallelCommands ::</span> <span class="kw">forall</span> state<span class="op">.</span> <span class="dt">ParallelModel</span> state</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">=&gt;</span> <span class="dt">ParallelCommands</span> state <span class="ot">-&gt;</span> <span class="dt">PropertyM</span> <span class="dt">IO</span> ()</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>runParallelCommands cmds0<span class="op">@</span>(<span class="dt">ParallelCommands</span> forks0) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  forM_ (parallelCommands cmds0) <span class="op">$</span> \cmd <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> name <span class="ot">=</span> commandName cmd</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    monitor (tabulate <span class="st">&quot;Commands&quot;</span> [name] <span class="op">.</span> classify <span class="dt">True</span> name)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  monitor (tabulate <span class="st">&quot;Concurrency&quot;</span> (<span class="fu">map</span> (<span class="fu">show</span> <span class="op">.</span> <span class="fu">length</span> <span class="op">.</span> unFork) forks0))</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  q   <span class="ot">&lt;-</span> liftIO newTQueueIO</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>  c   <span class="ot">&lt;-</span> liftIO newAtomicCounter</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  env <span class="ot">&lt;-</span> liftIO (runForks q c emptyEnv forks0)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  hist <span class="ot">&lt;-</span> <span class="dt">History</span> <span class="op">&lt;$&gt;</span> liftIO (atomically (flushTQueue q))</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ok <span class="ot">=</span> linearisable env (interleavings hist)</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>  unless ok (monitor (counterexample (<span class="fu">show</span> hist)))</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>  assert ok</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    runForks ::</span> <span class="dt">TQueue</span> (<span class="dt">Event</span> state) <span class="ot">-&gt;</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> state <span class="ot">-&gt;</span> [<span class="dt">Fork</span> state]</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Env</span> state)</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>    runForks _q _c env [] <span class="ot">=</span> <span class="fu">return</span> env</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    runForks  q  c env (<span class="dt">Fork</span> cmds <span class="op">:</span> forks) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>      envs <span class="ot">&lt;-</span> liftIO <span class="op">$</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>        mapConcurrently (runParallelReal q c env) (<span class="fu">zip</span> [<span class="dt">Pid</span> <span class="dv">0</span><span class="op">..</span>] cmds)</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> env&#39; <span class="ot">=</span> combineEnvs (env <span class="op">:</span> envs)</span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>      runForks q c env&#39; forks</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a><span class="ot">    runParallelReal ::</span> <span class="dt">TQueue</span> (<span class="dt">Event</span> state) <span class="ot">-&gt;</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> state</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">-&gt;</span> (<span class="dt">Pid</span>, <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Env</span> state)</span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>    runParallelReal q c env (pid, cmd) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>      atomically (writeTQueue q (<span class="dt">Invoke</span> pid cmd))</span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>      eResp <span class="ot">&lt;-</span> try (runCommandMonad (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> state) (runReal (<span class="fu">fmap</span> (lookupEnv env) cmd)))</span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> eResp <span class="kw">of</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> (<span class="ot">err ::</span> <span class="dt">SomeException</span>) <span class="ot">-&gt;</span></span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>          <span class="fu">error</span> (<span class="st">&quot;runParallelReal: &quot;</span> <span class="op">++</span> displayException err)</span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> resp <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- </span><span class="al">NOTE</span><span class="co">: It&#39;s important that we extend the environment before writing `Ok`</span></span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- to the history, otherwise we might get scope issues.</span></span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- XXX: Move outside of mapConcurrently? How do we assign the right `Var`</span></span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- with each `Reference`? Perhaps this would be easier if we had a prefix</span></span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- and N suffixes?</span></span>
<span id="cb61-40"><a href="#cb61-40" aria-hidden="true" tabindex="-1"></a>          env&#39; <span class="ot">&lt;-</span> extendEnvParallel env c (toList resp)</span>
<span id="cb61-41"><a href="#cb61-41" aria-hidden="true" tabindex="-1"></a>          atomically (writeTQueue q (<span class="dt">Ok</span> pid resp))</span>
<span id="cb61-42"><a href="#cb61-42" aria-hidden="true" tabindex="-1"></a>          <span class="fu">return</span> env&#39;</span></code></pre></div>
<p>Extending the environment in the parallel case requires an atomic
counter in order to avoid more than one thread adding the same
variable:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">AtomicCounter</span> <span class="ot">=</span> <span class="dt">AtomicCounter</span> (<span class="dt">IORef</span> <span class="dt">Int</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="ot">newAtomicCounter ::</span> <span class="dt">IO</span> <span class="dt">AtomicCounter</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>newAtomicCounter <span class="ot">=</span> <span class="dt">AtomicCounter</span> <span class="op">&lt;$&gt;</span> newIORef <span class="dv">0</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Returns old value.</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="ot">incrAtomicCounter ::</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>incrAtomicCounter (<span class="dt">AtomicCounter</span> ioRef) n <span class="ot">=</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>  atomicModifyIORef&#39; ioRef (\old <span class="ot">-&gt;</span> (old <span class="op">+</span> n, old))</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span class="ot">extendEnvParallel ::</span> <span class="dt">Env</span> state <span class="ot">-&gt;</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> [<span class="dt">Reference</span> state] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Env</span> state)</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>extendEnvParallel env c refs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> incrAtomicCounter c (<span class="fu">length</span> refs)</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (extendEnv env (<span class="fu">zip</span> [i<span class="op">..</span>] refs))</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a><span class="ot">combineEnvs ::</span> [<span class="dt">Env</span> state] <span class="ot">-&gt;</span> <span class="dt">Env</span> state</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>combineEnvs <span class="ot">=</span> <span class="dt">Env</span> <span class="op">.</span> IntMap.unions <span class="op">.</span> <span class="fu">map</span> unEnv</span></code></pre></div>
<p>Hopefully the execution part is clear, next let’s have a look at how
we check the result of an execution.</p>
<h5 id="linearisability-checking">Linearisability checking</h5>
<p>Recall from our parallel counter example in the introduction to
parallel testing that it’s enough to find <em>any</em> possible
interleaving which respects the sequential model. So let’s start by
enumerating all possible interleavings using a <a
href="https://hackage.haskell.org/package/containers-0.7/docs/Data-Tree.html"><code>Rose</code>
tree</a> data structure:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Op</span> state <span class="ot">=</span> <span class="dt">Op</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>                   (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="ot">interleavings ::</span> <span class="dt">History</span> state <span class="ot">-&gt;</span> <span class="dt">Forest</span> (<span class="dt">Op</span> state)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>interleavings (<span class="dt">History</span> [])  <span class="ot">=</span> []</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>interleavings (<span class="dt">History</span> evs0) <span class="ot">=</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">Node</span> (<span class="dt">Op</span> cmd resp) (interleavings (<span class="dt">History</span> evs&#39;))</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> (tid, cmd)   <span class="ot">&lt;-</span> takeInvocations evs0</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>  , (resp, evs&#39;) <span class="ot">&lt;-</span> findResponse tid</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>                      (filter1 (<span class="fu">not</span> <span class="op">.</span> matchInvocation tid) evs0)</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    takeInvocations ::</span> [<span class="dt">Event</span> state] <span class="ot">-&gt;</span> [(<span class="dt">Pid</span>, <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))]</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>    takeInvocations []                         <span class="ot">=</span> []</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>    takeInvocations ((<span class="dt">Invoke</span> pid cmd)   <span class="op">:</span> evs) <span class="ot">=</span> (pid, cmd) <span class="op">:</span> takeInvocations evs</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    takeInvocations ((<span class="dt">Ok</span>    _pid _resp) <span class="op">:</span> _)   <span class="ot">=</span> []</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a><span class="ot">    findResponse ::</span> <span class="dt">Pid</span> <span class="ot">-&gt;</span> [<span class="dt">Event</span> state] <span class="ot">-&gt;</span> [(<span class="dt">Response</span> state (<span class="dt">Reference</span> state), [<span class="dt">Event</span> state])]</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    findResponse _pid []                                   <span class="ot">=</span> []</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>    findResponse  pid ((<span class="dt">Ok</span> pid&#39; resp) <span class="op">:</span> evs) <span class="op">|</span> pid <span class="op">==</span> pid&#39; <span class="ot">=</span> [(resp, evs)]</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>    findResponse  pid (ev             <span class="op">:</span> evs)               <span class="ot">=</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>      [ (resp, ev <span class="op">:</span> evs&#39;) <span class="op">|</span> (resp, evs&#39;) <span class="ot">&lt;-</span> findResponse pid evs ]</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a><span class="ot">    matchInvocation ::</span> <span class="dt">Pid</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> state <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>    matchInvocation pid (<span class="dt">Invoke</span> pid&#39; _cmd) <span class="ot">=</span> pid <span class="op">==</span> pid&#39;</span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>    matchInvocation _   _                  <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a><span class="ot">    filter1 ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>    filter1 _ []                   <span class="ot">=</span> []</span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>    filter1 p (x <span class="op">:</span> xs) <span class="op">|</span> p x       <span class="ot">=</span> x <span class="op">:</span> filter1 p xs</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>                       <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> xs</span></code></pre></div>
<p>We can then check if there is a path through this rose tree which
agrees with the sequential model:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearisable ::</span> <span class="kw">forall</span> state<span class="op">.</span> <span class="dt">StateModel</span> state</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">=&gt;</span> <span class="dt">Env</span> state <span class="ot">-&gt;</span> <span class="dt">Forest</span> (<span class="dt">Op</span> state) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>linearisable env <span class="ot">=</span> any&#39; (go initialState)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> state <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">Op</span> state) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    go s (<span class="dt">Node</span> (<span class="dt">Op</span> cmd cresp) ts) <span class="ot">=</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> _preconditionFailure <span class="ot">-&gt;</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>          <span class="fu">error</span> <span class="st">&quot;linearisable: impossible, all precondtions are satisifed during generation&quot;</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> (s&#39;, resp) <span class="ot">-&gt;</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>          cresp <span class="op">==</span> <span class="fu">fmap</span> (lookupEnv env) resp <span class="op">&amp;&amp;</span> any&#39; (go s&#39;) ts</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    any&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    any&#39; _p [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    any&#39;  p xs <span class="ot">=</span> <span class="fu">any</span> p xs</span></code></pre></div>
<h4 id="example-parallel-counter">Example: parallel counter</h4>
<p>This is the only new code we need to add to enable parallel testing
of our <code>Counter</code> example<a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a> from before:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ParallelModel</span> <span class="dt">Counter</span> <span class="kw">where</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The command monad is IO, so we don&#39;t need to do anything here.</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  runCommandMonad _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_parallelCounter ::</span> <span class="dt">ParallelCommands</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>prop_parallelCounter cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  replicateM_ <span class="dv">10</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    run reset</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    runParallelCommands cmds</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span></code></pre></div>
<p>If we run the above property with <code>runReal</code></p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>  runReal <span class="dt">Incr</span> <span class="ot">=</span> <span class="dt">Incr_</span> <span class="op">&lt;$&gt;</span> incrRaceCondition</span></code></pre></div>
<p>being implemented using an increment with a race condition:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">incrRaceCondition ::</span> <span class="dt">IO</span> ()</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>incrRaceCondition <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>then a failure is found:</p>
<pre><code> Assertion failed (after 36 tests and 1 shrink):
      ParallelCommands [Fork [Incr,Incr],Fork [Incr],Fork [Get,Get,Get],Fork [Incr],Fork [Get,Get],Fork [Get,Get],Fork [Incr],Fork [Get,Get,Incr],Fork [Incr],Fork [Get,Get,Get],Fork [Incr,Incr],Fork [Incr,Get],Fork [Incr,Incr],Fork [Get],Fork [Incr]]</code></pre>
<p>But shrinking didn’t work very well. The reason for this is that
QuickCheck tries a smaller test case (which still has the race
condition), but because of a different interleaving of threads the race
doesn’t get triggered and so QuickCheck thinks it found the minimal test
case (because the smaller test case, that the shrinker picked,
passes).</p>
<p>The proper solution to this problem is to use a deterministic thread
scheduler, this is what they do the parallel testing paper. A simpler
workaround is to introduce a small sleep after each read or write to
shared memory, this will make it more likely that the same interleaving
happens when we shrink the test:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">incrRaceCondition ::</span> <span class="dt">IO</span> ()</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>incrRaceCondition <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  threadDelay <span class="dv">100</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>  threadDelay <span class="dv">100</span></span></code></pre></div>
<p>With this change we get the minimal test case that triggers the race
condition:</p>
<pre><code>Assertion failed (after 6 tests and 4 shrinks):
      ParallelCommands [Fork [Incr,Incr],Fork [Get]]</code></pre>
<p>We can avoid having to sprinkle sleeps around our interaction with
shared state by creating a module with the same operations as on shared
memory where the sleep is already included:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">SleepyIORef</span> (<span class="kw">module</span> <span class="dt">SleepyIORef</span>, <span class="dt">IORef</span>) <span class="kw">where</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span> (threadDelay)</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IORef</span> (<span class="dt">IORef</span>)</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.IORef</span> <span class="kw">as</span> <span class="dt">IORef</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="co">------------------------------------------------------------------------</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a><span class="ot">readIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>readIORef ref <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>  threadDelay <span class="dv">1000</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>  IORef.readIORef ref</span></code></pre></div>
<p>That way if we find a race, we can change the import from
<code>import Data.IORef</code> to <code>import SleepyIORef</code> and
rerun the tests and get better shrinking.</p>
<p>This situation is not ideal, but save us the trouble of having to
re-implement a scheduler.</p>
<p>It’s worth stressing that the race is found in the unmodified code
and the introduction of sleep is only needed to make the counterexample
smaller.</p>
<h4 id="example-process-registry">Example: process registry</h4>
<p>For a slightly more complicated example containing race conditions,
let’s have a look at an implementation of the Erlang process registry<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>.</p>
<h5 id="software-under-test-2">Software under test</h5>
<p>The idea behind Erlang’s process registry is that you can spawn
threads, register the <code>ThreadId</code> to some name of type string,
and then lookup the thread by name rather than its thread id. Threads
can also be unregistered and killed.</p>
<p>This is useful if threads die and get restarted and register the same
name, then other threads can easily find the thread id of the new thread
using the registry.</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alive ::</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>alive tid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  s <span class="ot">&lt;-</span> threadStatus tid</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> s <span class="op">/=</span> <span class="dt">ThreadFinished</span> <span class="op">&amp;&amp;</span> s <span class="op">/=</span> <span class="dt">ThreadDied</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE registry #-}</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="ot">registry ::</span> <span class="dt">IORef</span> [(<span class="dt">String</span>,<span class="dt">ThreadId</span>)]</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>registry <span class="ot">=</span> unsafePerformIO (newIORef [])</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span class="ot">spawn ::</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>spawn <span class="ot">=</span> forkIO (threadDelay <span class="dv">100000000</span>)</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a><span class="ot">whereis ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">ThreadId</span>)</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>whereis name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>  reg <span class="ot">&lt;-</span> readRegistry</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">lookup</span> name reg</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a><span class="ot">register ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>register name tid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>  ok <span class="ot">&lt;-</span> alive tid</span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>  reg <span class="ot">&lt;-</span> readRegistry</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> ok <span class="op">&amp;&amp;</span> name <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">fst</span> reg <span class="op">&amp;&amp;</span> tid <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">snd</span> reg</span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef registry <span class="op">$</span> \reg&#39; <span class="ot">-&gt;</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>           <span class="kw">if</span> name <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">fst</span> reg&#39; <span class="op">&amp;&amp;</span> tid <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">snd</span> reg&#39;</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>             <span class="kw">then</span> ((name,tid)<span class="op">:</span>reg&#39;,())</span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>             <span class="kw">else</span> (reg&#39;,badarg)</span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> badarg</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a><span class="ot">unregister ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>unregister name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>  reg <span class="ot">&lt;-</span> readRegistry</span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> name <span class="ot">`elem`</span> <span class="fu">map</span> <span class="fu">fst</span> reg</span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> atomicModifyIORef registry <span class="op">$</span> \reg&#39; <span class="ot">-&gt;</span></span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>           (<span class="fu">filter</span> ((<span class="op">/=</span>name)<span class="op">.</span><span class="fu">fst</span>) reg&#39;,</span>
<span id="cb72-36"><a href="#cb72-36" aria-hidden="true" tabindex="-1"></a>            ())</span>
<span id="cb72-37"><a href="#cb72-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> badarg</span>
<span id="cb72-38"><a href="#cb72-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-39"><a href="#cb72-39" aria-hidden="true" tabindex="-1"></a><span class="ot">readRegistry ::</span> <span class="dt">IO</span> [(<span class="dt">String</span>, <span class="dt">ThreadId</span>)]</span>
<span id="cb72-40"><a href="#cb72-40" aria-hidden="true" tabindex="-1"></a>readRegistry <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-41"><a href="#cb72-41" aria-hidden="true" tabindex="-1"></a>  reg <span class="ot">&lt;-</span> readIORef registry</span>
<span id="cb72-42"><a href="#cb72-42" aria-hidden="true" tabindex="-1"></a>  garbage <span class="ot">&lt;-</span> filterM (<span class="fu">fmap</span> <span class="fu">not</span><span class="op">.</span>alive) (<span class="fu">map</span> <span class="fu">snd</span> reg)</span>
<span id="cb72-43"><a href="#cb72-43" aria-hidden="true" tabindex="-1"></a>  atomicModifyIORef&#39; registry <span class="op">$</span> \reg&#39; <span class="ot">-&gt;</span></span>
<span id="cb72-44"><a href="#cb72-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> reg&#39;&#39; <span class="ot">=</span> <span class="fu">filter</span> ((<span class="ot">`notElem`</span> garbage)<span class="op">.</span><span class="fu">snd</span>) reg&#39; <span class="kw">in</span> (reg&#39;&#39;,reg&#39;&#39;)</span>
<span id="cb72-45"><a href="#cb72-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-46"><a href="#cb72-46" aria-hidden="true" tabindex="-1"></a><span class="ot">badarg ::</span> a</span>
<span id="cb72-47"><a href="#cb72-47" aria-hidden="true" tabindex="-1"></a>badarg <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;bad argument&quot;</span></span>
<span id="cb72-48"><a href="#cb72-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-49"><a href="#cb72-49" aria-hidden="true" tabindex="-1"></a><span class="ot">kill ::</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb72-50"><a href="#cb72-50" aria-hidden="true" tabindex="-1"></a>kill tid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-51"><a href="#cb72-51" aria-hidden="true" tabindex="-1"></a>  killThread tid</span>
<span id="cb72-52"><a href="#cb72-52" aria-hidden="true" tabindex="-1"></a>  waitUntilDead <span class="dv">1000</span></span>
<span id="cb72-53"><a href="#cb72-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb72-54"><a href="#cb72-54" aria-hidden="true" tabindex="-1"></a><span class="ot">    waitUntilDead ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb72-55"><a href="#cb72-55" aria-hidden="true" tabindex="-1"></a>    waitUntilDead <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;kill: thread didn&#39;t die&quot;</span></span>
<span id="cb72-56"><a href="#cb72-56" aria-hidden="true" tabindex="-1"></a>    waitUntilDead n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-57"><a href="#cb72-57" aria-hidden="true" tabindex="-1"></a>      b <span class="ot">&lt;-</span> alive tid</span>
<span id="cb72-58"><a href="#cb72-58" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> b</span>
<span id="cb72-59"><a href="#cb72-59" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb72-60"><a href="#cb72-60" aria-hidden="true" tabindex="-1"></a>        threadDelay <span class="dv">1000</span></span>
<span id="cb72-61"><a href="#cb72-61" aria-hidden="true" tabindex="-1"></a>        waitUntilDead (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb72-62"><a href="#cb72-62" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="fu">return</span> ()</span></code></pre></div>
<h5 id="model-2">Model</h5>
<div class="sourceCode" id="cb73"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RegState</span> <span class="ot">=</span> <span class="dt">RegState</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tids   ::</span> [<span class="dt">Var</span> <span class="dt">ThreadId</span>]</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> regs   ::</span> [(<span class="dt">String</span>, <span class="dt">Var</span> (<span class="dt">ThreadId</span>))]</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> killed ::</span> [<span class="dt">Var</span> <span class="dt">ThreadId</span>]</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> <span class="dt">RegState</span> <span class="kw">where</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  initialState ::</span> <span class="dt">RegState</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>  initialState <span class="ot">=</span> <span class="dt">RegState</span> [] [] []</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span> <span class="dt">RegState</span> <span class="ot">=</span> <span class="dt">ThreadId</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span> <span class="dt">RegState</span> tid</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Spawn</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">WhereIs</span> <span class="dt">String</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Register</span> <span class="dt">String</span> tid</span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Unregister</span> <span class="dt">String</span></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Kill</span> tid</span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span> <span class="dt">RegState</span> tid</span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Spawn_</span> tid</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">WhereIs_</span> (<span class="dt">NonFoldable</span> (<span class="dt">Maybe</span> tid))</span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Register_</span> (<span class="dt">Either</span> <span class="dt">ErrorCall</span> ())</span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Unregister_</span> (<span class="dt">Either</span> <span class="dt">ErrorCall</span> ())</span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Kill_</span> ()</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommand ::</span> <span class="dt">RegState</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> <span class="dt">RegState</span> (<span class="dt">Var</span> <span class="dt">ThreadId</span>))</span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a>  generateCommand s <span class="ot">=</span> oneof <span class="op">$</span></span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a>    [ <span class="fu">return</span> <span class="dt">Spawn</span> ] <span class="op">++</span></span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">Register</span> <span class="op">&lt;$&gt;</span> arbitraryName <span class="op">&lt;*&gt;</span> elements (tids s) <span class="op">|</span> <span class="fu">not</span> (<span class="fu">null</span> (tids s)) ] <span class="op">++</span></span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">Unregister</span> <span class="op">&lt;$&gt;</span> arbitraryName</span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a>    , <span class="dt">WhereIs</span> <span class="op">&lt;$&gt;</span> arbitraryName</span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a>    ] <span class="op">++</span></span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">Kill</span> <span class="op">&lt;$&gt;</span> elements (tids s) <span class="op">|</span> <span class="fu">not</span> (<span class="fu">null</span> (tids s)) ]</span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a><span class="ot">      arbitraryName ::</span> <span class="dt">Gen</span> <span class="dt">String</span></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a>      arbitraryName <span class="ot">=</span> elements allNames</span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a><span class="ot">  runFake ::</span> <span class="dt">Command</span> <span class="dt">RegState</span> (<span class="dt">Var</span> <span class="dt">ThreadId</span>)<span class="ot">-&gt;</span> <span class="dt">RegState</span></span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Either</span> void (<span class="dt">RegState</span>, <span class="dt">Response</span> <span class="dt">RegState</span> (<span class="dt">Var</span> <span class="dt">ThreadId</span>))</span>
<span id="cb73-45"><a href="#cb73-45" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">Spawn</span>               s <span class="ot">=</span> <span class="kw">let</span> tid <span class="ot">=</span> <span class="dt">Var</span> (<span class="fu">length</span> (tids s)) <span class="kw">in</span></span>
<span id="cb73-46"><a href="#cb73-46" aria-hidden="true" tabindex="-1"></a>                                  <span class="fu">return</span> (s { tids <span class="ot">=</span> tids s <span class="op">++</span> [tid] }, <span class="dt">Spawn_</span> tid)</span>
<span id="cb73-47"><a href="#cb73-47" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">WhereIs</span> name)      s <span class="ot">=</span> <span class="fu">return</span> (s, <span class="dt">WhereIs_</span> (<span class="dt">NonFoldable</span> (<span class="fu">lookup</span> name (regs s))))</span>
<span id="cb73-48"><a href="#cb73-48" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Register</span> name tid) s</span>
<span id="cb73-49"><a href="#cb73-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> tid <span class="ot">`elem`</span> tids s</span>
<span id="cb73-50"><a href="#cb73-50" aria-hidden="true" tabindex="-1"></a>    , name <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">fst</span> (regs s)</span>
<span id="cb73-51"><a href="#cb73-51" aria-hidden="true" tabindex="-1"></a>    , tid <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">snd</span> (regs s)</span>
<span id="cb73-52"><a href="#cb73-52" aria-hidden="true" tabindex="-1"></a>    , tid <span class="ot">`notElem`</span> killed s</span>
<span id="cb73-53"><a href="#cb73-53" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="fu">return</span> (s { regs <span class="ot">=</span> (name, tid) <span class="op">:</span> regs s }, <span class="dt">Register_</span> (<span class="dt">Right</span> ()))</span>
<span id="cb73-54"><a href="#cb73-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-55"><a href="#cb73-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span></span>
<span id="cb73-56"><a href="#cb73-56" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="fu">return</span> (s, <span class="dt">Register_</span> (<span class="dt">Left</span> (<span class="dt">ErrorCall</span> <span class="st">&quot;bad argument&quot;</span>)))</span>
<span id="cb73-57"><a href="#cb73-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-58"><a href="#cb73-58" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Unregister</span> name)   s</span>
<span id="cb73-59"><a href="#cb73-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> name <span class="ot">`elem`</span> <span class="fu">map</span> <span class="fu">fst</span> (regs s) <span class="ot">=</span></span>
<span id="cb73-60"><a href="#cb73-60" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (s { regs <span class="ot">=</span> remove name (regs s) }, <span class="dt">Unregister_</span> (<span class="dt">Right</span> ()))</span>
<span id="cb73-61"><a href="#cb73-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">return</span> (s, <span class="dt">Unregister_</span> (<span class="dt">Left</span> (<span class="dt">ErrorCall</span> <span class="st">&quot;bad argument&quot;</span>)))</span>
<span id="cb73-62"><a href="#cb73-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb73-63"><a href="#cb73-63" aria-hidden="true" tabindex="-1"></a>      remove x <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">/=</span> x) <span class="op">.</span> <span class="fu">fst</span>)</span>
<span id="cb73-64"><a href="#cb73-64" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Kill</span> tid) s <span class="ot">=</span> <span class="fu">return</span> (s { killed <span class="ot">=</span> tid <span class="op">:</span> killed s</span>
<span id="cb73-65"><a href="#cb73-65" aria-hidden="true" tabindex="-1"></a>                                   , regs   <span class="ot">=</span> remove tid (regs s)}, <span class="dt">Kill_</span> ())</span>
<span id="cb73-66"><a href="#cb73-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb73-67"><a href="#cb73-67" aria-hidden="true" tabindex="-1"></a>      remove x <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">/=</span> x) <span class="op">.</span> <span class="fu">snd</span>)</span>
<span id="cb73-68"><a href="#cb73-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-69"><a href="#cb73-69" aria-hidden="true" tabindex="-1"></a><span class="ot">  runReal ::</span> <span class="dt">Command</span> <span class="dt">RegState</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">RegState</span> <span class="dt">ThreadId</span>)</span>
<span id="cb73-70"><a href="#cb73-70" aria-hidden="true" tabindex="-1"></a>  runReal <span class="dt">Spawn</span>               <span class="ot">=</span> <span class="dt">Spawn_</span>      <span class="op">&lt;$&gt;</span> spawn</span>
<span id="cb73-71"><a href="#cb73-71" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">WhereIs</span> name)      <span class="ot">=</span> <span class="dt">WhereIs_</span> <span class="op">.</span> <span class="dt">NonFoldable</span> <span class="op">&lt;$&gt;</span> whereis name</span>
<span id="cb73-72"><a href="#cb73-72" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Register</span> name tid) <span class="ot">=</span> <span class="dt">Register_</span>   <span class="op">&lt;$&gt;</span> <span class="fu">fmap</span> (left abstractError) (try (register name tid))</span>
<span id="cb73-73"><a href="#cb73-73" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Unregister</span> name)   <span class="ot">=</span> <span class="dt">Unregister_</span> <span class="op">&lt;$&gt;</span> <span class="fu">fmap</span> (left abstractError) (try (unregister name))</span>
<span id="cb73-74"><a href="#cb73-74" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Kill</span> tid)          <span class="ot">=</span> <span class="dt">Kill_</span>       <span class="op">&lt;$&gt;</span> kill tid</span>
<span id="cb73-75"><a href="#cb73-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-76"><a href="#cb73-76" aria-hidden="true" tabindex="-1"></a><span class="ot">  monitoring ::</span> (<span class="dt">RegState</span>, <span class="dt">RegState</span>) <span class="ot">-&gt;</span> <span class="dt">Command</span> <span class="dt">RegState</span> <span class="dt">ThreadId</span></span>
<span id="cb73-77"><a href="#cb73-77" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="dt">RegState</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">Property</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb73-78"><a href="#cb73-78" aria-hidden="true" tabindex="-1"></a>  monitoring (_s, s&#39;) cmd resp <span class="ot">=</span></span>
<span id="cb73-79"><a href="#cb73-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb73-80"><a href="#cb73-80" aria-hidden="true" tabindex="-1"></a>      aux tag <span class="ot">=</span> classify <span class="dt">True</span> (<span class="fu">show</span> tag)</span>
<span id="cb73-81"><a href="#cb73-81" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span> counterexample (<span class="st">&quot;\n    State: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s&#39; <span class="op">++</span> <span class="st">&quot;\n&quot;</span>)</span>
<span id="cb73-82"><a href="#cb73-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb73-83"><a href="#cb73-83" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> (cmd, resp) <span class="kw">of</span></span>
<span id="cb73-84"><a href="#cb73-84" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Register</span>   {}, <span class="dt">Register_</span>   (<span class="dt">Left</span> _))  <span class="ot">-&gt;</span> aux <span class="dt">RegisterFailed</span></span>
<span id="cb73-85"><a href="#cb73-85" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Register</span>   {}, <span class="dt">Register_</span>   (<span class="dt">Right</span> _)) <span class="ot">-&gt;</span> aux <span class="dt">RegisterSucceeded</span></span>
<span id="cb73-86"><a href="#cb73-86" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Unregister</span> {}, <span class="dt">Unregister_</span> (<span class="dt">Left</span> _))  <span class="ot">-&gt;</span> aux <span class="dt">UnregisterFailed</span></span>
<span id="cb73-87"><a href="#cb73-87" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Unregister</span> {}, <span class="dt">Unregister_</span> (<span class="dt">Right</span> _)) <span class="ot">-&gt;</span> aux <span class="dt">UnregisterSucceeded</span></span>
<span id="cb73-88"><a href="#cb73-88" aria-hidden="true" tabindex="-1"></a>        _otherwise <span class="ot">-&gt;</span> counterexample <span class="op">$</span> <span class="st">&quot;\n    State: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s&#39; <span class="op">++</span> <span class="st">&quot;\n&quot;</span></span>
<span id="cb73-89"><a href="#cb73-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-90"><a href="#cb73-90" aria-hidden="true" tabindex="-1"></a><span class="co">-- Throws away the location information from the error, so that it matches up</span></span>
<span id="cb73-91"><a href="#cb73-91" aria-hidden="true" tabindex="-1"></a><span class="co">-- with the fake.</span></span>
<span id="cb73-92"><a href="#cb73-92" aria-hidden="true" tabindex="-1"></a><span class="ot">abstractError ::</span> <span class="dt">ErrorCall</span> <span class="ot">-&gt;</span> <span class="dt">ErrorCall</span></span>
<span id="cb73-93"><a href="#cb73-93" aria-hidden="true" tabindex="-1"></a>abstractError (<span class="dt">ErrorCallWithLocation</span> msg _loc) <span class="ot">=</span> <span class="dt">ErrorCall</span> msg</span>
<span id="cb73-94"><a href="#cb73-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-95"><a href="#cb73-95" aria-hidden="true" tabindex="-1"></a><span class="ot">allNames ::</span> [<span class="dt">String</span>]</span>
<span id="cb73-96"><a href="#cb73-96" aria-hidden="true" tabindex="-1"></a>allNames <span class="ot">=</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;e&quot;</span>]</span>
<span id="cb73-97"><a href="#cb73-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-98"><a href="#cb73-98" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tag</span> <span class="ot">=</span> <span class="dt">RegisterFailed</span> <span class="op">|</span> <span class="dt">RegisterSucceeded</span> <span class="op">|</span> <span class="dt">UnregisterFailed</span> <span class="op">|</span> <span class="dt">UnregisterSucceeded</span></span>
<span id="cb73-99"><a href="#cb73-99" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb73-100"><a href="#cb73-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-101"><a href="#cb73-101" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_registry ::</span> <span class="dt">Commands</span> <span class="dt">RegState</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb73-102"><a href="#cb73-102" aria-hidden="true" tabindex="-1"></a>prop_registry cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb73-103"><a href="#cb73-103" aria-hidden="true" tabindex="-1"></a>  void (run cleanUp)</span>
<span id="cb73-104"><a href="#cb73-104" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb73-105"><a href="#cb73-105" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span>
<span id="cb73-106"><a href="#cb73-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-107"><a href="#cb73-107" aria-hidden="true" tabindex="-1"></a><span class="ot">cleanUp ::</span> <span class="dt">IO</span> [<span class="dt">Either</span> <span class="dt">ErrorCall</span> ()]</span>
<span id="cb73-108"><a href="#cb73-108" aria-hidden="true" tabindex="-1"></a>cleanUp <span class="ot">=</span> <span class="fu">sequence</span></span>
<span id="cb73-109"><a href="#cb73-109" aria-hidden="true" tabindex="-1"></a>  [ try (unregister name)<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ErrorCall</span> ())</span>
<span id="cb73-110"><a href="#cb73-110" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> name <span class="ot">&lt;-</span> allNames</span>
<span id="cb73-111"><a href="#cb73-111" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>One new thing to note here is that <code>WhereIs_</code> returns the
thread id that we wanted to look up, but thread ids also happen to be
references. The way we implemented extending the environment with new
references is that we call <code>Data.Foldable.toList</code> on all
responses, which gives us all references from the responses. In the
<code>Spawn_</code> case this does the right thing, since spawn returns
a reference to the newly spawned thread id, but in this case the thread
id from <code>WhereIs_</code> is not a new reference (it’s merely a
reference to the thread id we wanted to look up), so we shouldn’t extend
the environment with the reference that <code>WhereIs_</code> returns.
We solve this problem with wrapping the response of
<code>WhereIs_</code> in <code>NonFoldable</code> which has a
<code>toList</code> which doesn’t return anything.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">NonFoldable</span> a <span class="ot">=</span> <span class="dt">NonFoldable</span> a</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">NonFoldable</span> <span class="kw">where</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">NonFoldable</span> x) <span class="ot">=</span> <span class="dt">NonFoldable</span> (f x)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">NonFoldable</span> <span class="kw">where</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldMap</span> _f (<span class="dt">NonFoldable</span> _x) <span class="ot">=</span> <span class="fu">mempty</span></span></code></pre></div>
<h6 id="testing-1">Testing</h6>
<p>The above passes the sequential tests and we can see that we got good
coverage of failing commands as well:</p>
<pre><code>  +++ OK, passed 100 tests:
  83% Spawn
  82% WhereIs
  79% Unregister
  78% UnregisterFailed
  70% Kill
  70% Register
  62% RegisterFailed
  59% RegisterSucceeded
  29% UnregisterSucceeded</code></pre>
<p>To make sure everything works as expected, let’s introduce a bug on
purpose:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>  register :: String -&gt; ThreadId -&gt; IO ()</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>  register name tid = do</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    ok &lt;- alive tid</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    reg &lt;- readRegistry</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>    if ok &amp;&amp; name `notElem` map fst reg &amp;&amp; tid `notElem` map snd reg</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>      then atomicModifyIORef&#39; registry $ \reg&#39; -&gt;</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>             if name `notElem` map fst reg&#39; &amp;&amp; tid `notElem` map snd reg&#39;</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a><span class="st">-              then ((name,tid):reg&#39;,())</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a><span class="va">+              then ([(name,tid)],())</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>               else (reg&#39;,badarg)</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>      else badarg</span></code></pre></div>
<p>If we rerun the tests with this bug in place, we get test failures
like the following:</p>
<pre><code>     *** Failed! Assertion failed (after 30 tests and 7 shrinks):
      Commands {unCommands = [Spawn,Spawn,Register &quot;e&quot; (Var 1),Register &quot;d&quot; (Var 0),Unregister &quot;e&quot;]}
      Spawn --&gt; Spawn_ (ThreadId 154)

          State: RegState {tids = [Var 0], regs = [], killed = []}

      Spawn --&gt; Spawn_ (ThreadId 155)

          State: RegState {tids = [Var 0,Var 1], regs = [], killed = []}

      Register &quot;e&quot; (Var 1) --&gt; Register_ (Right ())

          State: RegState {tids = [Var 0,Var 1], regs = [(&quot;e&quot;,Var 1)], killed = []}

      Register &quot;d&quot; (Var 0) --&gt; Register_ (Right ())

          State: RegState {tids = [Var 0,Var 1], regs = [(&quot;d&quot;,Var 0),(&quot;e&quot;,Var 1)], killed = []}

      Unregister &quot;e&quot; --&gt; Unregister_ (Left bad argument)

          State: RegState {tids = [Var 0,Var 1], regs = [(&quot;d&quot;,Var 0)], killed = []}

      Expected: Unregister_ (Right ())
      Got: Unregister_ (Left bad argument)</code></pre>
<p>As we can see unregister fails, when it in fact so should succeed
(we’ve registered <code>"e"</code> so we should be allowed to unregister
it, but the real implementation has due to the bug forgot that the
registration happened).</p>
<p>Let’s move on to the parallel tests, all we need to add is:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ParallelModel</span> <span class="dt">RegState</span> <span class="kw">where</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  runCommandMonad _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_parallelRegistry ::</span> <span class="dt">ParallelCommands</span> <span class="dt">RegState</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>prop_parallelRegistry cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>  replicateM_ <span class="dv">10</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>    void (run cleanUp)</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>    runParallelCommands cmds</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- start snippet ParallelRegistry</span></span></code></pre></div>
<p>When we run the tests we get rather long counterexamples:</p>
<pre><code>      *** Failed! (after 24 tests and 7 shrinks):
      Exception:
        bad argument
        CallStack (from HasCallStack):
          error, called at src/Example/Registry/Real.hs:69:10 in stateful-pbt-with-fakes-0.0.0-inplace:Example.Registry.Real
      ParallelCommands [Fork [Spawn,WhereIs &quot;a&quot;],Fork [Spawn],
                        Fork [Register &quot;c&quot; (Var 1),Spawn],Fork [Register &quot;e&quot; (Var 2),Register &quot;a&quot; (Var 2)]]</code></pre>
<p>But if we replace our shared memory operations with version that do a
bit of sleep beforehand:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="st">- import Data.IORef</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ import SleepyIORef</span></span></code></pre></div>
<p>We get better shrinking results:</p>
<pre><code>      *** Failed! (after 5 tests and 5 shrinks):
      Exception:
        bad argument
        CallStack (from HasCallStack):
          error, called at src/Example/Registry/Real.hs:69:10 in stateful-pbt-with-fakes-0.0.0-inplace:Example.Registry.Real
      ParallelCommands [Fork [Spawn],Fork [Register &quot;b&quot; (Var 0),Register &quot;c&quot; (Var 0)]]</code></pre>
<p>Here we see clearly that there’s some problem in
<code>Register</code>, as that’s the only thing that happens in
parallel. If we look at the implementation of <code>register</code> it’s
obvious where the race condition is, for example we are using
<code>atomicModifyIORef</code> to update the registry. The problem is
that we call <code>readRegistry</code> to check if a name has already
been registered and then call <code>atomicModifyIORef</code>, so the
race can be if another thread sneaks in between those two calls.</p>
<p>We can fix this problem by adding a global lock around
<code>register</code>:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE lock #-}</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="ot">lock ::</span> <span class="dt">MVar</span> ()</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>lock <span class="ot">=</span> unsafePerformIO (newMVar ())</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="ot">registerNoRace ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>registerNoRace name tid <span class="ot">=</span> withMVar lock <span class="op">$</span> \_ <span class="ot">-&gt;</span> register name tid</span></code></pre></div>
<p>When rerunning the tests with this fixed version of
<code>registry</code>, we get:</p>
<pre><code>      *** Failed! Assertion failed (after 30 tests and 13 shrinks):
      ParallelCommands [Fork [Spawn],Fork [Spawn],Fork [Spawn],
                        Fork [Register &quot;d&quot; (Var 2)],Fork [Unregister &quot;d&quot;,Unregister &quot;d&quot;]]</code></pre>
<p>Which seems to suggest that we have a similar problem with
<code>unregister</code>, which is indeed the case. After applying the
same fix to <code>unregister</code>, we get:</p>
<pre><code>      *** Failed! Assertion failed (after 15 tests and 4 shrinks):
      ParallelCommands [Fork [Spawn],Fork [Register &quot;d&quot; (Var 0)],
                        Fork [Kill (Var 0),Register &quot;e&quot; (Var 0)]]</code></pre>
<p>Killing a thread will unregister it, so we get a similar problem
again. If we take the lock before calling <code>kill</code>, then the
parallel tests finally pass.</p>
<h3 id="integration-testing-with-contract-tested-fakes">Integration
testing with contract tested fakes</h3>
<p>Throughout this post we’ve used in-memory models, or fakes, as
reference implementations to test against.</p>
<p>The use of fakes diverges from the original work on Erlang
QuickCheck, where a more traditional state machine specification is used
with post-conditions.</p>
<p>As far as I know, Edsko de Vries’ <a
href="https://www.well-typed.com/blog/2019/01/qsm-in-depth/">post</a>
(2019) was the first to propose the use of fakes instead of state
machine specifications with post-conditions. Edsko also showed how one
can implement fake-based specifications on top of a library that uses
state machine specifications.</p>
<p>XXX: Post-conditions are more general than fakes? Relational vs
functional?</p>
<p>Fake instead of state machine spec is not only easier for programmers
unfamiliar with formal specification</p>
<p>But there are other advantages to having a fake, for example we can
use this fake in integration tests with components that depend on the
software that we tested with the fake.</p>
<p>One of the problems with integration testing against fakes is that
the fake can be wrong. The standard solution to solve that problem is to
<a href="https://martinfowler.com/bliki/ContractTest.html">contract
test</a> the fake to make sure that it is faithful to the software it’s
supposed to be a fake of. We don’t have this problem, because our tests
assure that the fake is faithful.</p>
<p>This, final, section is about unpacking and giving examples of how
integration testing against fakes works.</p>
<h4 id="example-queue-again">Example: queue (again)</h4>
<p>As our first example of integration testing, let’s recall our queue
example from the section on stateful testing. We can introduce an
interface for it as follows:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IQueue</span> q <span class="ot">=</span> <span class="dt">IQueue</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> iNew  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> q</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iPut  ::</span> q <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iGet  ::</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iSize ::</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The real implementation can instantiate this interface in a
straightforward way:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="ot">real ::</span> <span class="dt">IQueue</span> <span class="dt">Queue</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>real <span class="ot">=</span> <span class="dt">IQueue</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>  { iNew  <span class="ot">=</span> new</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>  , iPut  <span class="ot">=</span> put</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>  , iGet  <span class="ot">=</span> get</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>  , iSize <span class="ot">=</span> size</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The interesting part is that our fake can also instantiate the same
interface by storing the state in a mutable reference
(<code>IORef</code>) as follows.</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fake ::</span> <span class="dt">IO</span> (<span class="dt">IQueue</span> (<span class="dt">Var</span> <span class="dt">Queue</span>))</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>fake <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>  ref <span class="ot">&lt;-</span> newIORef emptyState</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">IQueue</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    { iNew  <span class="ot">=</span> \n   <span class="ot">-&gt;</span> updateIORef ref (fNew n)</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    , iPut  <span class="ot">=</span> \q i <span class="ot">-&gt;</span> updateIORef ref (fPut q i)</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    , iGet  <span class="ot">=</span> \q   <span class="ot">-&gt;</span> updateIORef ref (fGet q)</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>    , iSize <span class="ot">=</span> \q   <span class="ot">-&gt;</span> updateIORef ref (fSize q)</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    updateIORef ::</span> <span class="dt">IORef</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    updateIORef ref op <span class="ot">=</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef&#39; ref (\fs <span class="ot">-&gt;</span> assoc fs (op fs)) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwIO err</span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> x  <span class="ot">-&gt;</span> <span class="fu">return</span> x</span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>        assoc fs  (<span class="dt">Left</span> err)       <span class="ot">=</span> (fs,  <span class="dt">Left</span> err)</span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>        assoc _fs (<span class="dt">Right</span> (fs&#39;, x)) <span class="ot">=</span> (fs&#39;, <span class="dt">Right</span> x)</span></code></pre></div>
<p>We can now write components or services <em>against</em> this
interface:</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prog ::</span> <span class="dt">IQueue</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>prog iq <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>  q <span class="ot">&lt;-</span> iNew iq <span class="dv">3</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span class="dv">0</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span class="dv">1</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span class="dv">2</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> iGet iq q</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>  assert (x <span class="op">==</span> <span class="dv">0</span>) (<span class="fu">return</span> ())</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>  sz <span class="ot">&lt;-</span> iSize iq q</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>  assert (sz <span class="op">==</span> <span class="dv">2</span>) (<span class="fu">return</span> ())</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> prog <span class="op">=&lt;&lt;</span> fake</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> <span class="dt">IO</span> ()</span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>deploy <span class="ot">=</span> prog real</span></code></pre></div>
<p>When we integration test our new component we can use the
<code>fake</code> instance to make the tests fast and deterministic,
while when we deploy we use the <code>real</code> instance and because
of our stateful property-based tests we know that the fake is faithful
to the real implementation.</p>
<h4 id="example-file-system">Example: file system</h4>
<p>The next example is a file system, first used by Edsko de Vries in
the <a
href="https://www.well-typed.com/blog/2019/01/qsm-in-depth/">post</a>
(2019) that also introduced using fakes as models.</p>
<p>The interface is parametrised by a file handle. We can create
directories, open files to get a hold of a file handle, file handles can
then be read from and written to, and finally closed:</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IFileSystem</span> h <span class="ot">=</span> <span class="dt">IFileSystem</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> iMkDir ::</span> <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iOpen  ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> h</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iWrite ::</span> h <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iClose ::</span> h <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iRead  ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The real implementation of this interface uses the real file system.
In order to isolate the tests all operations will be relative to some
<code>root</code> directory:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="ot">root ::</span> <span class="dt">FilePath</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>root <span class="ot">=</span> <span class="st">&quot;/tmp/qc-test&quot;</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rMkDir ::</span> <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>rMkDir d <span class="ot">=</span> createDirectory (dirFP root d)</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="ot">rOpen ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Handle</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>rOpen f <span class="ot">=</span> openFile (fileFP root f) <span class="dt">AppendMode</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a><span class="ot">rWrite ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>rWrite h s <span class="ot">=</span> hPutStr h s</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a><span class="ot">rClose ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>rClose h <span class="ot">=</span> hClose h</span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a><span class="ot">rRead ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>rRead f <span class="ot">=</span> <span class="fu">readFile</span> (fileFP root f)</span></code></pre></div>
<div class="sourceCode" id="cb91"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="ot">real ::</span> <span class="dt">IFileSystem</span> <span class="dt">Handle</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>real <span class="ot">=</span> <span class="dt">IFileSystem</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>  { iMkDir <span class="ot">=</span> rMkDir</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  , iOpen  <span class="ot">=</span> rOpen</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>  , iWrite <span class="ot">=</span> rWrite</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>  , iClose <span class="ot">=</span> rClose</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>  , iRead  <span class="ot">=</span> rRead</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The fake implementation of the interface is, as usual, implemented
using an in-memory data structure:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FHandle</span> <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Handle</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FakeFS</span> <span class="ot">=</span> <span class="dt">F</span> {</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    dirs  ::</span> <span class="dt">Set</span> <span class="dt">Dir</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> files ::</span> <span class="dt">Map</span> <span class="dt">File</span> <span class="dt">String</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> open  ::</span> <span class="dt">Map</span> <span class="dt">FHandle</span> <span class="dt">File</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> next  ::</span> <span class="dt">FHandle</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyFakeFS ::</span> <span class="dt">FakeFS</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>emptyFakeFS <span class="ot">=</span> <span class="dt">F</span> (Set.singleton (<span class="dt">Dir</span> [])) Map.empty Map.empty (<span class="dt">Var</span> <span class="dv">0</span>)</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FakeOp</span> a <span class="ot">=</span> <span class="dt">FakeFS</span> <span class="ot">-&gt;</span> (<span class="dt">Either</span> <span class="dt">PrecondFail</span> a, <span class="dt">FakeFS</span>)</span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a><span class="ot">fMkDir ::</span> <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> ()</span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a>fMkDir d m<span class="op">@</span>(<span class="dt">F</span> ds fs hs n)</span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> d        <span class="ot">`Set.member`</span>    ds <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">AlreadyExists</span>, m)</span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> parent d <span class="ot">`Set.notMember`</span> ds <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">DoesNotExist</span>, m)</span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>                   <span class="ot">=</span> (<span class="dt">Right</span> (), <span class="dt">F</span> (Set.insert d ds) fs hs n)</span>
<span id="cb92-21"><a href="#cb92-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-22"><a href="#cb92-22" aria-hidden="true" tabindex="-1"></a><span class="ot">fOpen ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> <span class="dt">FHandle</span></span>
<span id="cb92-23"><a href="#cb92-23" aria-hidden="true" tabindex="-1"></a>fOpen f m<span class="op">@</span>(<span class="dt">F</span> ds fs hs n<span class="op">@</span>(<span class="dt">Var</span> n_))</span>
<span id="cb92-24"><a href="#cb92-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> alreadyOpen   <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">Busy</span>, m)</span>
<span id="cb92-25"><a href="#cb92-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">not</span> dirExists <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">DoesNotExist</span>, m)</span>
<span id="cb92-26"><a href="#cb92-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> fileExists    <span class="ot">=</span> (<span class="dt">Right</span> n, <span class="dt">F</span> ds fs hs&#39; n&#39;)</span>
<span id="cb92-27"><a href="#cb92-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">=</span> (<span class="dt">Right</span> n, <span class="dt">F</span> ds (Map.insert f <span class="st">&quot;&quot;</span> fs) hs&#39; n&#39;)</span>
<span id="cb92-28"><a href="#cb92-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb92-29"><a href="#cb92-29" aria-hidden="true" tabindex="-1"></a>    hs&#39; <span class="ot">=</span> Map.insert n f hs</span>
<span id="cb92-30"><a href="#cb92-30" aria-hidden="true" tabindex="-1"></a>    n&#39;  <span class="ot">=</span> <span class="dt">Var</span> (<span class="fu">succ</span> n_)</span>
<span id="cb92-31"><a href="#cb92-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-32"><a href="#cb92-32" aria-hidden="true" tabindex="-1"></a>    fileExists  <span class="ot">=</span>         f <span class="ot">`Map.member`</span> fs</span>
<span id="cb92-33"><a href="#cb92-33" aria-hidden="true" tabindex="-1"></a>    dirExists   <span class="ot">=</span> fileDir f <span class="ot">`Set.member`</span> ds</span>
<span id="cb92-34"><a href="#cb92-34" aria-hidden="true" tabindex="-1"></a>    alreadyOpen <span class="ot">=</span> f <span class="ot">`List.elem`</span> Map.elems hs</span>
<span id="cb92-35"><a href="#cb92-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-36"><a href="#cb92-36" aria-hidden="true" tabindex="-1"></a><span class="ot">fWrite ::</span> <span class="dt">FHandle</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> ()</span>
<span id="cb92-37"><a href="#cb92-37" aria-hidden="true" tabindex="-1"></a>fWrite h s m<span class="op">@</span>(<span class="dt">F</span> ds fs hs n)</span>
<span id="cb92-38"><a href="#cb92-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> f <span class="ot">&lt;-</span> Map.lookup h hs <span class="ot">=</span> (<span class="dt">Right</span> (), <span class="dt">F</span> ds (Map.adjust (<span class="op">++</span> s) f fs) hs n)</span>
<span id="cb92-39"><a href="#cb92-39" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>                 <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">HandleClosed</span>, m)</span>
<span id="cb92-40"><a href="#cb92-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-41"><a href="#cb92-41" aria-hidden="true" tabindex="-1"></a><span class="ot">fClose ::</span> <span class="dt">FHandle</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> ()</span>
<span id="cb92-42"><a href="#cb92-42" aria-hidden="true" tabindex="-1"></a>fClose h (<span class="dt">F</span> ds fs hs n) <span class="ot">=</span> (<span class="dt">Right</span> (), <span class="dt">F</span> ds fs (Map.delete h hs) n)</span>
<span id="cb92-43"><a href="#cb92-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-44"><a href="#cb92-44" aria-hidden="true" tabindex="-1"></a><span class="ot">fRead ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> <span class="dt">String</span></span>
<span id="cb92-45"><a href="#cb92-45" aria-hidden="true" tabindex="-1"></a>fRead f m<span class="op">@</span>(<span class="dt">F</span> _ fs hs _)</span>
<span id="cb92-46"><a href="#cb92-46" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> alreadyOpen               <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">Busy</span>         , m)</span>
<span id="cb92-47"><a href="#cb92-47" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> s <span class="ot">&lt;-</span> Map.lookup f fs <span class="ot">=</span> (<span class="dt">Right</span> s           , m)</span>
<span id="cb92-48"><a href="#cb92-48" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>                 <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">DoesNotExist</span> , m)</span>
<span id="cb92-49"><a href="#cb92-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb92-50"><a href="#cb92-50" aria-hidden="true" tabindex="-1"></a>    alreadyOpen <span class="ot">=</span> f <span class="ot">`List.elem`</span> Map.elems hs</span></code></pre></div>
<div class="sourceCode" id="cb93"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fake ::</span> <span class="dt">IO</span> (<span class="dt">IFileSystem</span> <span class="dt">FHandle</span>)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>fake <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  ref <span class="ot">&lt;-</span> newIORef emptyFakeFS</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">IFileSystem</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    { iMkDir <span class="ot">=</span> \d   <span class="ot">-&gt;</span> updateIORef ref (fMkDir d)</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    , iOpen  <span class="ot">=</span> \f   <span class="ot">-&gt;</span> updateIORef ref (fOpen f)</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    , iWrite <span class="ot">=</span> \h s <span class="ot">-&gt;</span> updateIORef ref (fWrite h s)</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    , iClose <span class="ot">=</span> \h   <span class="ot">-&gt;</span> updateIORef ref (fClose h)</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>    , iRead  <span class="ot">=</span> \f   <span class="ot">-&gt;</span> updateIORef ref (fRead f)</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    updateIORef ::</span> <span class="dt">IORef</span> <span class="dt">FakeFS</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>    updateIORef ref op <span class="ot">=</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef&#39; ref (\fs <span class="ot">-&gt;</span> swap (op fs)) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwIO err</span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> x  <span class="ot">-&gt;</span> <span class="fu">return</span> x</span>
<span id="cb93-17"><a href="#cb93-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb93-18"><a href="#cb93-18" aria-hidden="true" tabindex="-1"></a>        swap (x, y) <span class="ot">=</span> (y, x)</span></code></pre></div>
<p>Assuming we’ve tested that the fake file system is faithful to the
real one, we can depend on the interface in all components of our system
that need the file system:</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prog ::</span> <span class="dt">IFileSystem</span> h <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>prog ifs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> d <span class="ot">=</span> <span class="dt">Dir</span> [<span class="st">&quot;foo&quot;</span>]</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>  iMkDir ifs d</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> f <span class="ot">=</span> <span class="dt">File</span> d <span class="st">&quot;bar&quot;</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> iOpen ifs f</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>  iWrite ifs h <span class="st">&quot;baz&quot;</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>  iClose ifs h</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">=&lt;&lt;</span> iRead ifs f</span></code></pre></div>
<p>We can then use the fake file system when we integration test and
thus get fast and deterministic tests, and then use the real file system
when we deploy.</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> prog <span class="op">=&lt;&lt;</span> fake</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> <span class="dt">IO</span> ()</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>deploy <span class="ot">=</span> prog real</span></code></pre></div>
<p>Because of the fact that we know that the fake is faithful to the
real file system implementation, we can be relatively sure that swapping
in the real file system instead of the fake one when deploying will not
introduce bugs. If it does introduce a bug then we have a mismatch
between the fake and the real implementation and we need to investigate
how it slipped through our stateful property-based <a
href="https://github.com/stevana/stateful-pbt-with-fakes/blob/main/src/Example/FileSystem/Test.hs">tests</a>.</p>
<p>Note that <code>prog</code> is just a silly example, in a real system
the component that uses the file system can be more complex, for example
in the system that Edsko worked on the component that depended on the
file system is a database. In such cases it makes sense to write a whole
new stateful and parallel property-based test suite using database
commands and responses, it’s those tests that do the integration testing
between the database and the fake file system, while the stateful and
parallel property-based tests of the file system alone do the contract
tests that ensure that the file system fake is faithful to the real file
system.</p>
<h4 id="example-bigger-system-of-components">Example: bigger system of
components</h4>
<p>The examples given above, a queue and a file system, might not seems
necessary to fake<a href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a> so to finish of let’s sketch how the
same technique scales to a bigger system of components or services.</p>
<p>Imagine we have three components or services, where component
<em>A</em> depends on component <em>B</em> which depends on component
<em>C</em>:</p>
<pre><code>  +---+      +---+      +---+
  |   |      |   |      |   |
  | A +-----&gt;| B +-----&gt;| C |
  |   |      |   |      |   |
  +---+      +---+      +---+</code></pre>
<p>Following the pattern that we did for the queue and file system
example, we’d define three interfaces:</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IA</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IB</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IC</span> <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>And the dependencies are made clear when we instantiate the
interfaces:</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="ot">iC ::</span> <span class="dt">IO</span> <span class="dt">IC</span>       <span class="co">-- C has no dependencies.</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="ot">iB ::</span> <span class="dt">IC</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">IB</span> <span class="co">-- B depends on C.</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="ot">iA ::</span> <span class="dt">IB</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">IA</span> <span class="co">-- A depends on B.</span></span></code></pre></div>
<p>The testing strategy is then as follows:</p>
<ol type="1">
<li>Stateful and parallel test C, this gives us a fake of C which is
contract tested;</li>
<li>Use C fake when integration testing B;</li>
<li>Use B fake (which uses the C fake) when testing A.</li>
</ol>
<p>Hopefully it should be clear that this strategy scales to more
components or services<a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>.</p>
<h2 id="conclusion-and-future-work">Conclusion and future work</h2>
<p>We’ve seen how stateful and parallel property-based testing can be
implemented in about 400 lines of code, which is comparable to the 300
lines of code of the first version of QuickCheck (which didn’t have
shrinking). We’ve also had a look at several examples of how we can use
fakes as models and how to test bigger systems in a compositional manner
by reusing the fakes.</p>
<p>I hope that this is enough material to get people curious and
experimenting in other programming languages. I used Haskell, because
it’s what the original QuickCheck library is written in, but I think it
would be good to translate code to other programming language paradigms,
thus making it easier for others to learn and experiment. If anyone is
interested in starting such a port to a different language, then I’d be
happy to help. Feel free to open issues and ask questions in the the <a
href="https://github.com/stevana/stateful-pbt-with-fakes">code
repository</a> of this post.</p>
<p>I’ve also writen down a bunch of <a
href="https://github.com/stevana/stateful-pbt-with-fakes/blob/main/TODO.md">ideas</a>
for improvements and further exploration, in case anyone’s interested in
digging deeper into this topic (again, happy to elaborate, feel free to
get <a href="https://stevana.github.io/about.html">in touch</a>).</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>I’d like to thank Daniel Gustafsson for helping implement the
<code>quickcheck-state-machine</code> library with me seven years ago,
discussing a fix for parallel commands generation <a
href="https://github.com/stevana/quickcheck-state-machine/issues/51">issue</a>
that I found while writing this post, and for proofreading.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Is there a source for this story? I can’t remember where
I’ve heard it. This short <a
href="http://www.erlang-factory.com/conference/London2011/speakers/JohnHughes">biography</a>
gives some of the details:</p>
<blockquote>
<p>“From 2002-2005 he led a major research project in software
verification, funded by the Swedish Strategic Research Foundation. This
led to the development of Quviq QuickCheck in Erlang.”</p>
</blockquote>
<p>I believe <a
href="https://strategiska.se/forskning/genomford-forskning/ramanslag-inom-it-omradet/projekt/2010/">this</a>
must be the project mentioned above.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>There’s some room for error here from the users side,
e.g. the user could create non-unique references. In a proper library
one might want to introduce a <code>genSym</code> construct which
guarantees uniqueness.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>So stateful property-based testing with a trivial
<code>runReal</code> can be seen as crude version of a random path
exploring “model checker”. One could perhaps implement something closer
to TLC (the model checker for TLA+), which enumerates all paths up to
some depth, by using <code>smallcheck</code> rather than
<code>QuickCheck</code>. If this topic interests you, you might also
want to have a look at Gabriella Gonzalez’s <a
href="https://github.com/Gabriella439/HasCal">HasCal</a>.</p>
<p>I don’t have an example for this, but I guess one can also think of
stateful property-based testing with a trivial <code>runFake</code> as a
crude version of a fuzzer (without coverage guidance). For more on this
and how to add coverage guidance, see <a
href="https://dl.acm.org/doi/10.1145/3360607"><em>Coverage guided,
property based testing</em></a> (2019).<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>The parallel counter example is very similar to the
ticket dispenser example that appears in <a
href="https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"><em>Testing
the hard stuff and staying sane</em></a> (2014).<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The sequential variant of the process registry example
first appeared in the paper <a
href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5ae25681ff881430797268c5787d7d9ee6cf542c"><em>QuickCheck
testing for fun and profit</em></a> (2007) and is also part of John’s
Midlands Graduate School course (2019). The parallel tests were
introduced in <a
href="https://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf"><em>Finding
Race Conditions in Erlang with QuickCheck and PULSE</em></a> (2009).<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Unless we want to test what happens when failures, such
as the disk being full etc. <a
href="http://www.eecg.toronto.edu/~yuan/papers/failure_analysis_osdi14.pdf">Research</a>
shows that “almost all (92%) of the catastrophic system failures are the
result of incorrect handling of non-fatal errors explicitly signaled in
software. […] in 58% of the catastrophic failures, the underlying faults
could easily have been detected through simple testing of error handling
code.”. Fakes make it easier to inject faults, but that’s a story for
another day.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>See the talk <a
href="https://www.youtube.com/watch?v=fhFa4tkFUFw">Integrated Tests Are
A Scam</a> by J.B. Rainsberger for a longer presentation of this idea.<a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
