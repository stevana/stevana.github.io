<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>Coverage-guided property-based testing</title>
  <link rel="stylesheet" href="style.css?modified=2025-02-23" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/coverage-guided_property-based_testing.html&t=Coverage-guided property-based testing">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About / <span class="work-with-me">Work with me</span></a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>Coverage-guided property-based testing</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#background-and-prior-work"
id="toc-background-and-prior-work">Background and prior work</a>
<ul>
<li><a href="#before-2015" id="toc-before-2015">Before 2015</a></li>
<li><a href="#after-2015" id="toc-after-2015">After 2015</a></li>
</ul></li>
<li><a href="#prototype-implementation"
id="toc-prototype-implementation">Prototype implementation</a>
<ul>
<li><a href="#getting-the-coverage-information"
id="toc-getting-the-coverage-information">Getting the coverage
information</a></li>
<li><a href="#the-first-version-of-quickcheck"
id="toc-the-first-version-of-quickcheck">The first version of
QuickCheck</a>
<ul>
<li><a href="#generating-input-data"
id="toc-generating-input-data">Generating input data</a></li>
<li><a href="#specifying-properties"
id="toc-specifying-properties">Specifying properties</a></li>
<li><a href="#collecting-statistics"
id="toc-collecting-statistics">Collecting statistics</a></li>
<li><a href="#running-the-tests" id="toc-running-the-tests">Running the
tests</a></li>
</ul></li>
<li><a href="#example-traditional-use-of-coverage"
id="toc-example-traditional-use-of-coverage">Example: traditional use of
coverage</a></li>
<li><a href="#the-extension-to-add-coverage-guidance"
id="toc-the-extension-to-add-coverage-guidance">The extension to add
coverage-guidance</a></li>
<li><a href="#example-using-coverage-to-guide-generation"
id="toc-example-using-coverage-to-guide-generation">Example: using
coverage to guide generation</a></li>
</ul></li>
<li><a href="#conclusion-and-further-work"
id="toc-conclusion-and-further-work">Conclusion and further
work</a></li>
</ul>
</nav>
<div class="date">Posted on Sep 25, 2024</div>
<p><em>Work in progress, please don’t share, but do feel free to get
involved!</em></p>
<p>Almost ten years ago, back in 2015, Dan Luu wrote a <a
href="https://danluu.com/testing/">post</a> asking why coverage-guided
property-based testing wasn’t a thing.</p>
<p>In this post I’ll survey the coverage-guided landscape, looking at
what was there before Dan’s post and what has happened since. I’ll also
show how to add basic coverage-guidance to the first version of the
original property-based testing tool, QuickCheck, in about 35 lines of
code.</p>
<p>Unlike many previous implementations of this idea, the technique used
to implement coverage-guidance is programming language agnostic and
doesn’t rely on any language-specific instrumentation of the software
under test.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>Before we start, let me try to motivate why one would want to combine
coverage-guided fuzzing and property-based testing to begin with.</p>
<p>Consider the following example<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>, where an error is
triggered if some input byte array starts with the bytes
<code>"bad!"</code>:</p>
<pre><code>func sut(input []byte) {
    if input[0] == &#39;b&#39; {
        if input[1] == &#39;a&#39; {
            if input[2] == &#39;d&#39; {
                if input[3] == &#39;!&#39; {
                    panic(&quot;input must not be bad!&quot;)
                }
            }
        }
    }
}</code></pre>
<p>What are the odds that a property-based testing tool (without
coverage-guidance) would be able to find the error?</p>
<p>To make the calculation easier, let’s say that we always generate
arrays of length <span class="math inline">\(4\)</span>. A byte consists
of eight bits, so it has <span class="math inline">\(2^8\)</span>
possible values. That means that the probability is <span
class="math inline">\(\frac{1}{2^8} \cdot \frac{1}{2^8} \cdot
\frac{1}{2^8} \cdot \frac{1}{2^8} = (\frac{1}{2^8})^4 =
\frac{1}{2^{32}}\)</span> which is approximately <span
class="math inline">\(1\)</span> in <span
class="math inline">\(4\)</span> billion. In a realistic test suite, we
wouldn’t restrict the length of the array to be <span
class="math inline">\(4\)</span>, and hence the probability will be even
worse.</p>
<p>With coverage-guidance we keep track of inputs that resulted in
increased coverage. So, for example, if we generate the array
<code>[]byte{'b'}</code> we get further into the nested ifs, and so we
take note of that and start generating longer arrays that start with
<code>'b'</code> and see if we get even further, etc. By building on
previous successes in getting more coverage, we can effectively reduce
the problem to only need <span class="math inline">\(\frac{1}{2^8} +
\frac{1}{2^8} + \frac{1}{2^8} + \frac{1}{2^8} = \frac{1}{2^8} \cdot 4 =
\frac{1}{2^{10}} = \frac{1}{1024}\)</span>.</p>
<p>In other words coverage-guidance turns an exponential problem into a
polynomial problem!</p>
</section>
<section id="background-and-prior-work" class="level2">
<h2><a href="#background-and-prior-work"
title="Background and prior work">Background and prior work</a></h2>
<p>There’s a lot to cover here, so I’ll split it up in before and after
Dan’s post.</p>
<section id="before-2015" class="level3">
<h3><a href="#before-2015" title="Before 2015">Before 2015</a></h3>
<p>Fuzzing has an interesting origin. It started as a class <a
href="http://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf">project</a>
in an advanced operating systems course taught by Barton Miller at the
University of Wisconsin in 1988.</p>
<p>The project was inspired by the observation that back then, if you
logged into your workstation via a dail-up modem from home and it
rained, then frequently random characters would appear in the terminal.
The line noise wasn’t the surprising thing, but rather that the extra
characters would sometimes crash the program that they tried to invoke.
Among these programs were basic utilities such as <code>vi</code>,
<code>mail</code>, <code>cc</code>, <code>make</code>, <code>sed</code>,
<code>awk</code>, <code>sort</code>, etc, and it was reasonable to
expect that these would give an error message rather than crash and core
dump if fed with some extra characters caused by the rain.</p>
<p>So the project set out to basically recreate what the rain did, but
more effectively, but essentially generating random noise (stream of
bytes) and feeding that to different utilities and see if they crashed.
A couple of years later Barton et al published <a
href="https://dl.acm.org/doi/10.1145/96267.96279"><em>An empirical study
of the reliability of UNIX utilities</em></a> (1990) which documents
their findings.</p>
<p>Inserting random characters was effective in finding corner cases
where the programmers forgot to properly validate the input from the
user. However it wouldn’t trigger bugs hiding deeper under the surface,
such as the <code>"bad!"</code> example from the previous section.</p>
<p>This changed around 2007 when people <a
href="https://lcamtuf.coredump.cx/afl/historical_notes.txt">started
thinking</a> about how fuzzing can be combined with <a
href="https://en.wikipedia.org/wiki/Evolutionary_algorithm">evolutionary
algorithms</a>. The idea being that instead of generating random bytes
all the time as with classical fuzzing, we can use coverage information
from one test to mutate the input for the next test. Or to use the
evolution metaphor: seeds that lead to better coverage are mutated with
the hope that they will lead to even better coverage.</p>
<p>One of the first, and perhaps still most widely known, such
<em>coverage-guided</em> fuzzers is Michał Zalewski’s <a
href="https://lcamtuf.coredump.cx/afl/">AFL</a> (2013). To get a feel
for how effective AFL-style coverage-guidance is, check out the list of
<a href="https://lcamtuf.coredump.cx/afl/#bugs">bugs</a> that it found
and this post about how it manages to figure out the <a
href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">jpeg
format</a> on its own<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<p>Since AFL is the tool that Dan explicitly mentions in his post, let’s
stop at this point and go back to his point, before looking at what
happened since with coverage-guided fuzzers.</p>
<p>Recall that Dan was asking why this idea of coverage-guidance wasn’t
present in property-based testing tools. I’ve written about the <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html#the-history-of-property-based-testing">history</a>
of property-based testing and explained how it <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html#pure-property-based-testing-recap">works</a>
already, so I won’t take up space by repeating myself here. Let’s just
note that the <a
href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">original
paper</a> on property-based testing was published in 2000. So when Dan
wrote asking about this question property-based testing would have been
fifteen and AFL two years old.</p>
<p>The main difference between property-based testing and fuzzing is
that fuzzing requires less work by the user. Simply hook up the byte
generator to the function that expects bytes as input and off it goes
looking for crashes. Property-based testing on the other hand can test
functions that take arbitrary data structures as input (not just bytes),
but you have to describe how to generate such inputs.</p>
<p>Fuzzing only looks for crashes, while property-based testing lets you
specify arbitrary relations that should hold between the input and
output of the system under test. For example, we can generate binary
search trees and check that after we insert something into an arbitrary
binary search tree then it will remain sorted (when we do an inorder
traversal). Fuzzing can’t check such properties, and furthermore because
they generate random bytes it’s unlikely that they’ll even generate a
valid binary search tree to begin with (without lots of coverage-driven
testing).</p>
<p>On the other hand, the coverage of property-based tests is only as
good as the user provided generators. Corner cases where slightly
modified data leads to e.g. exception handling is not explored
automatically, and coverage information is not used to guide the input
generation process.</p>
<p>By now we should have enough background to see that the idea of
combining coverage-guidance and property-based testing makes sense.
Basically what we’d like is to:</p>
<ol type="1">
<li>Use user provided generators to kick start the exploration in the
right direction;</li>
<li>Mutate the generated data, while preserving its type, to surface
bugs that user provided generators alone wouldn’t have found;</li>
<li>Use coverage information to iteratively get deeper into the state
space of the system under test, like in the “bad!” example from the
motivation.</li>
</ol>
</section>
<section id="after-2015" class="level3">
<h3><a href="#after-2015" title="After 2015">After 2015</a></h3>
<p>Having covered what had happened before Dan’s post, let’s have a look
at what has happened in the ten years since his post. First off, it’s
worth noting that at some point Dan added an update to his post:</p>
<blockquote>
<p>“Update: Dmitry Vyukov’s Go-fuzz, which looks like it was started a
month after this post was written, uses the approach from the proof of
concept in this post of combining the sort of logic seen in AFL with a
QuickCheck-like framework, and has been shown to be quite effective. I
believe David R. MacIver is also planning to use this approach in the
next version of hypothesis.”</p>
</blockquote>
<p>So let’s start there, with Go-fuzz. At a first glance, all functions
that are tested with Go-fuzz need to take an array of bytes as input. My
initial thought was, how can I write properties which involve generating
more interesting data structures? But it turns out it’s <a
href="https://news.ycombinator.com/item?id=40876822">possible</a>, as
somebody pointed out in the comments of an old post of mine. Furthermore
there are also <a
href="https://adalogics.com/blog/structure-aware-go-fuzzing-complex-types">ways</a>
of making the fuzzer aware of more complex data structures. I haven’t
played around enough with this to be able to compare how well shrinking
works yet though, but overall I’d say this ticks the box of being a
property-based testing tool that is also coverage-guided.</p>
<p>Next up Dan mentions Python’s Hypothesis. I was searching through the
documentation trying to find out how coverage-guidance works, but I
couldn’t find anything. Searching through the repository I found the
following <a
href="https://github.com/HypothesisWorks/hypothesis/pull/1564/commits/dcbea9148be3446392bc3af8892d49f3cc74fbe3">release
note</a> (2018):</p>
<blockquote>
<p>“This release deprecates the coverage-guided testing functionality,
as it has proven brittle and does not really pull its weight.</p>
<p>We intend to replace it with something more useful in the future, but
the feature in its current form does not seem to be worth the cost of
using, and whatever replaces it will likely look very different.”</p>
</blockquote>
<p>As far as I can tell, it hasn’t been reintroduced since. However it’s
possible to hook Hypothesis up to <a
href="https://hypothesis.readthedocs.io/en/latest/details.html#use-with-external-fuzzers">use
external fuzzers</a>. Hypothesis already uses random bytes as basis for
its generators, unlike QuickCheck which uses an integer seed, so I
suppose that the external fuzzers essentially fuzz the random input
bytes that in turn are used to generate more structured input.</p>
<p>Traditional fuzzers are usually designed to target a single binary,
where as the test suite which uses property-based testing typically has
many properties. The <a
href="https://hypofuzz.com/docs/features.html#fuzzer-details">HypoFuzz</a>
tool works around this mismatch by scheduling fuzzing time among the
many Hypothesis properties in your test suite.</p>
<p>What else has happened since Dan’s post?</p>
<p>One of the first things I noticed is that AFL is no longer <a
href="https://lcamtuf.coredump.cx/afl/">maintained</a>:</p>
<blockquote>
<p>“Note: AFL hasn’t been updated for a couple of years; while it should
still work fine, a more complex fork with a variety of improvements and
additional features, known as AFL++, is available from other members of
the community and is worth checking out.”</p>
</blockquote>
<p>Whereas AFL is based on a single idea of how the fuzzer does its
exploration with very few knobs, <a
href="https://www.usenix.org/system/files/woot20-paper-fioraldi.pdf">AFL++</a>
(2020) keeps the basic AFL evolutionary algorithm structure, but
incorporates a lot of new research on other ways to explore the state
space. For example, which seed gets scheduled and how many times it gets
mutated per round are <a
href="https://mboehme.github.io/paper/CCS16.pdf">two new parameters</a>
that can be tweaked to achieve different paths of exploration throughout
the system under test.</p>
<p>The next thing I did was to search for “coverage-guided
property-based testing” in the academic literature.</p>
<p>One of the first papers I found was <a
href="https://dl.acm.org/doi/10.1145/3360607"><em>Coverage guided,
property based testing</em></a> by Leonidas Lampropoulos, Michael Hicks,
Benjamin C. Pierce (2019). In this paper FuzzChick, Coq/Rocq library,
that adds AFL-style coverage instrumentation to QuickChick (a Rocq
QuickCheck clone) is presented. Unfortunately the only source code I
could find lives in an <a
href="https://github.com/QuickChick/QuickChick/compare/master...FuzzChick">unmaintained
branch</a> that <a
href="https://github.com/QuickChick/QuickChick/issues/277">doesn’t
compile</a>.</p>
<p>The related works section of the paper has a couple of interesting
references though.</p>
<p>The main inspiration for FuzzChick seems to have been Stephen Dolan
et al’s OCaml library called <a
href="https://github.com/ocaml/ocaml.org-media/blob/086fc25105cbccb188c28ec74126d72962921ff8/meetings/ocaml/2017/extended-abstract__2017__stephen-dolan_mindy-preston__testing-with-crowbar.pdf">Crowbar</a>
(2017). Crowbar uses a stream of bytes to drive its generators, similar
to Hypothesis, and it’s this stream that AFL is hooked up to. This
indirection is Crowbar’s (and by extension, I guess, also HypoFuzz’s)
biggest weakness.</p>
<p>AFL is good at manipulating this byte stream, but because the bytes
are not used directly to test the system under test, but rather to
generate data which in turn is used for testing, some of its
effectiveness is lost. This becomes particularly obvious when data
structures with sparse pre-conditions, e.g. sorted list or a binary
search tree. That’s what the authors of FuzzChick say at least, while
claiming that they addressed this weakness by doing type-aware
mutations.</p>
<p>The other libraries that the paper mentions are from the imperative
language community.</p>
<p>For example <a href="https://github.com/rohanpadhye/jqf"><em>JQF +
Zest: Coverage-guided semantic fuzzing for Java</em></a>, <a
href="https://llvm.org/docs/LibFuzzer.html">libfuzzer</a> and it’s
successor <a href="https://github.com/google/fuzztest">FuzzTest</a>
(2022?) for C++.</p>
<p>Rust’s <code>cargo fuzz</code> seems to build upon libfuzzer, see the
chapter on <a
href="https://rust-fuzz.github.io/book/cargo-fuzz/structure-aware-fuzzing.html"><em>Structure-aware
fuzzing using libfuzzer-sys in Rust</em></a> in the Rust Fuzz Book.</p>
<p>The FuzzTest README claims “It is a first-of-its-kind tool that
bridges the gap between fuzzing and property-based testing”. I can’t
tell why they would claim that, given that it appears to have been
released in 2022 and many of the tools we looked at above seem to have
successfully combined the two approaches before that. For example, how
is it different from Go-fuzz?</p>
<p>In my search I also found the paper <a
href="https://www.mista.me/assets/pdf/icst23-preprint.pdf"><em>MUTAGEN:
Reliable Coverage-Guided, Property-Based Testing using Exhaustive
Mutations</em></a> by Agustín Mista and Alejandro Russo (2023). This
paper seems to build upon the FuzzChick paper, however it swaps out the
AFL-style coverage instrumentation for the use of a GHC <a
href="https://github.com/OctopiChalmers/mutagen/blob/main/src/Test/Mutagen/Tracer/Plugin.hs">plugin</a>
to annotate source code with coverage information of: function clauses,
case statements, and each branch of if-then-else expressions.</p>
<p>Imperative languages such as Go, Python, C++, Rust, and Java seem
ahead of functional languages when it comes to combining coverage-guided
fuzzing and property-based testing.</p>
<p>Let’s try to change that by implementing a small functional
programming version, based on the original property-based testing
implementation.</p>
</section>
</section>
<section id="prototype-implementation" class="level2">
<h2><a href="#prototype-implementation"
title="Prototype implementation">Prototype implementation</a></h2>
<section id="getting-the-coverage-information" class="level3">
<h3><a href="#getting-the-coverage-information"
title="Getting the coverage information">Getting the coverage
information</a></h3>
<p>One key question we need to answer in order to be able to implement
anything that’s coverage-guided is: where do we get the coverage
information from?</p>
<p>When I’ve been thinking about how to implement coverage-guided
property-based testing in the past, I always got stuck thinking that
parsing the coverage output from the compiler in between test case
generation rounds would be annoying and slow.</p>
<p>I thought that in the best case scenario the compiler might provide a
library which exposes the coverage information<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<p>It wasn’t until I started researching this post that I realised that
AFL, and most coverage-guided fuzzers since, actually inject custom
coverage capturing code into compiled programs at every branch point or
<a href="https://en.wikipedia.org/wiki/Basic_block">basic block</a>.
It’s explained in more detail in the <a
href="https://lcamtuf.coredump.cx/afl/technical_details.txt">whitepaper</a>.</p>
<p>The main reason they do it is because of performance, not because
it’s necessarily easier, in fact I still don’t understand exactly how it
works.</p>
<p>It wasn’t until I read about Antithesis’ <a
href="https://antithesis.com/docs/best_practices/sometimes_assertions.html">“sometimes
assertions”</a> that I started seeing a simple solution to the problem
of collecting coverage information.</p>
<p>To understand how “sometimes assertions” work let’s first recall how
regular assertions, or “always assertions”, work. If we add
<code>assert b "message"</code> somewhere in the code base and the
boolean <code>b</code> evaluates to false at run-time then the program
will fail with <code>"message"</code>.</p>
<p>“Sometimes assertions” are different in that they don’t need to
always hold. Consider the example:</p>
<pre><code>for (1..10000) {
  c := flipCoin()
  sometimesAssert (c == Heads) &quot;probably an unfair coin&quot;
}</code></pre>
<p>Above the “sometimes assertion” will only fail if we flip 10000
tails.</p>
<p>How is this related to coverage though? If we sprinkle “sometimes
assertions” at every branch point:</p>
<pre><code>if b {
  sometimesAssert True &quot;true branch&quot;
} else {
  sometimesAssert True &quot;false branch&quot;
}</code></pre>
<p>Then we’ll get a failure when some branch hasn’t been covered! The
neat thing about “sometimes assertions” is that we don’t need to
annotate every single branch, we can annotate <em>interesting</em>
points in our program, that’s why we can think of “sometimes assertions”
as generalised coverage.</p>
<p>The final piece of the puzzle, and I think this is the only original
idea that this post adds<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>, is that property-based testing
already has functionality for implementing “sometimes assertions”: the
machinery for gathering run-time statistics of the generated data!</p>
<p>This machinery is <a
href="https://www.youtube.com/watch?v=NcJOiQlzlXQ">crucial</a> for
writing good tests and has been part of the QuickCheck implementation
since the very first version<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p>So the question is: can we implement coverage-guided property-based
testing using the internal notion of coverage that property-based
testing already has?</p>
</section>
<section id="the-first-version-of-quickcheck" class="level3">
<h3><a href="#the-first-version-of-quickcheck"
title="The first version of QuickCheck">The first version of
QuickCheck</a></h3>
<p>Before we answer the above question, let’s remind ourselves of how a
property-based testing library is implemented. For the sake of
self-containment, let’s reproduce the essential parts of QuickCheck as
defined in the appendix of the original <a
href="https://dl.acm.org/doi/10.1145/351240.351266">paper</a> that first
introduced property-based testing (ICFP, 2000).</p>
<section id="generating-input-data" class="level4">
<h4><a href="#generating-input-data"
title="Generating input data">Generating input data</a></h4>
<p>Let’s start with the generator<a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a>, which is used to
generate random inputs to the software under test:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="ot">=</span> <span class="dt">Gen</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> a)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">generate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>generate n rnd (<span class="dt">Gen</span> m) <span class="ot">=</span> m size rnd&#39;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  (size, rnd&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, n) rnd</span></code></pre></div>
<p>So a <code>Gen a</code> is basically a function from a size and a
pseudo-random number generator into <code>a</code>. The pseudo-random
number generator and size can be accessed using the following two
functions:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rand ::</span> <span class="dt">Gen</span> <span class="dt">StdGen</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>rand <span class="ot">=</span> <span class="dt">Gen</span> (\_n r <span class="ot">-&gt;</span> r)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">sized ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>sized fgen <span class="ot">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">Gen</span> m <span class="ot">=</span> fgen n <span class="kw">in</span> m n r)</span></code></pre></div>
<p>Using these together with the <code>Functor</code>,
<code>Applicative</code> and <code>Monad</code> instances of
<code>Gen</code> we can derive other useful combinators for generating
data:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">choose ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>choose bounds <span class="ot">=</span> (<span class="fu">fst</span> <span class="op">.</span> randomR bounds) <span class="ot">`fmap`</span> rand</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">elements ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>elements xs <span class="ot">=</span> (xs <span class="op">!!</span>) <span class="ot">`fmap`</span> choose (<span class="dv">0</span>, <span class="fu">length</span> xs <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ot">vector ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> [a]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>vector n <span class="ot">=</span> <span class="fu">sequence</span> [ arbitrary <span class="op">|</span> _i <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>n] ]</span></code></pre></div>
<p>Instead of defining generators directly for different datatypes,
QuickCheck first wraps generators in a type class called
<code>Arbitrary</code><a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> elements [<span class="dt">True</span>, <span class="dt">False</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Avoids generating control characters.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> choose (<span class="dv">32</span>,<span class="dv">126</span>) <span class="op">&gt;&gt;=</span> \n <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="fu">chr</span> n)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> sized <span class="op">$</span> \n <span class="ot">-&gt;</span> choose (<span class="op">-</span>n,n)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> sized (\n <span class="ot">-&gt;</span> choose (<span class="dv">0</span>,n) <span class="op">&gt;&gt;=</span> vector)</span></code></pre></div>
</section>
<section id="specifying-properties" class="level4">
<h4><a href="#specifying-properties"
title="Specifying properties">Specifying properties</a></h4>
<p>Next up, let’s look at how properties are expressed. The
<code>Property</code> type is a wrapper around
<code>Gen Result</code>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Property</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Prop</span> (<span class="dt">Gen</span> <span class="dt">Result</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">result ::</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>result res <span class="ot">=</span> <span class="dt">Prop</span> (<span class="fu">return</span> res)</span></code></pre></div>
<p>Where <code>Result</code> is defined as follows:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Result</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Result</span> {<span class="ot"> ok ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>,<span class="ot"> stamp ::</span> [<span class="dt">String</span>],<span class="ot"> arguments ::</span> [<span class="dt">String</span>] }</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">nothing ::</span> <span class="dt">Result</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>nothing <span class="ot">=</span> <span class="dt">Result</span>{ ok <span class="ot">=</span> <span class="dt">Nothing</span>, stamp <span class="ot">=</span> [], arguments <span class="ot">=</span> [] }</span></code></pre></div>
<p>The idea being that <code>ok :: Maybe Bool</code> is
<code>Nothing</code> if the input gets discarded and otherwise the
boolean indicates whether the property passed or not. The
<code>stamp</code> field is used to collect statistics about the
generated test cases, while <code>arguments</code> contains all the
generated inputs (or arguments) to the property.</p>
<p>In order to allow the user to write properties of varying arity
another type class is introduced:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Testable</span> a <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  property ::</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> () <span class="kw">where</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  property _ <span class="ot">=</span> result nothing</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  property b <span class="ot">=</span> result (nothing{ ok <span class="ot">=</span> <span class="dt">Just</span> b })</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Result</span> <span class="kw">where</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  property res <span class="ot">=</span> result res</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Property</span> <span class="kw">where</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  property prop <span class="ot">=</span> prop</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  property f <span class="ot">=</span> forAll arbitrary f</span></code></pre></div>
<p>The key ingredient in the function instance of <code>Testable</code>
is <code>forAll</code>:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forAll ::</span> (<span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>forAll gen body <span class="ot">=</span> <span class="dt">Prop</span> <span class="op">$</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> a   <span class="ot">&lt;-</span> gen</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>     res <span class="ot">&lt;-</span> evaluate (body a)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> (argument a res)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  argument a res <span class="ot">=</span> res{ arguments <span class="ot">=</span> <span class="fu">show</span> a <span class="op">:</span> arguments res }</span></code></pre></div>
<p>Which in turn depends on:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evaluate ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>evaluate a <span class="ot">=</span> gen <span class="kw">where</span> <span class="dt">Prop</span> gen <span class="ot">=</span> property a</span></code></pre></div>
<p>One last construct for writing properties that we need is the ability
to add assumptions or pre-conditions about the input:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(==&gt;) ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span>  <span class="op">==&gt;</span> a <span class="ot">=</span> property a</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span> <span class="op">==&gt;</span> a <span class="ot">=</span> property ()</span></code></pre></div>
<p>Notice how if the input doesn’t pass this test, then it will be
discarded.</p>
</section>
<section id="collecting-statistics" class="level4">
<h4><a href="#collecting-statistics"
title="Collecting statistics">Collecting statistics</a></h4>
<p>The way we collect statistics about the generated data is through
these two functions:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">label ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>label s a <span class="ot">=</span> <span class="dt">Prop</span> (add <span class="ot">`fmap`</span> evaluate a)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  add res <span class="ot">=</span> res{ stamp <span class="ot">=</span> s <span class="op">:</span> stamp res }</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">classify ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>classify <span class="dt">True</span>  name <span class="ot">=</span> label name</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>classify <span class="dt">False</span> _    <span class="ot">=</span> property</span></code></pre></div>
</section>
<section id="running-the-tests" class="level4">
<h4><a href="#running-the-tests" title="Running the tests">Running the
tests</a></h4>
<p>Finally we have all the pieces we need to be able to actually run the
tests. The testing can be configured:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> maxTest ::</span> <span class="dt">Int</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> maxFail ::</span> <span class="dt">Int</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> size    ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> every   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="ot">quick ::</span> <span class="dt">Config</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>quick <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  { maxTest <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  , maxFail <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  , size    <span class="ot">=</span> (<span class="op">+</span> <span class="dv">3</span>) <span class="op">.</span> (<span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  , every   <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="fu">show</span> n <span class="kw">in</span> s <span class="op">++</span> [ <span class="ch">&#39;\b&#39;</span> <span class="op">|</span> _ <span class="ot">&lt;-</span> s ]</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="ot">verbose ::</span> <span class="dt">Config</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>verbose <span class="ot">=</span> quick</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>  { every <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="fu">show</span> n <span class="op">++</span> <span class="st">&quot;:\n&quot;</span> <span class="op">++</span> <span class="fu">unlines</span> args</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Where <code>maxTest</code> is the amount of passing test cases that
will be run, <code>maxFail</code> is the amount of tests that are
allowed to be discarded, <code>size</code> is how the size parameter to
the generator changes between tests, and <code>every</code> is used to
print something (or not) between each test.</p>
<p>The tests themselves can now be run as follows:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>test, quickCheck,<span class="ot"> verboseCheck ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>test         <span class="ot">=</span> check quick</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>quickCheck   <span class="ot">=</span> check quick</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>verboseCheck <span class="ot">=</span> check verbose</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="ot">check ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>check config a <span class="ot">=</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> rnd <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>     tests config (evaluate a) rnd <span class="dv">0</span> <span class="dv">0</span> []</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="ot">tests ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>tests config gen rnd0 ntest nfail stamps</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ntest <span class="op">==</span> maxTest config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;OK, passed&quot;</span> ntest stamps</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nfail <span class="op">==</span> maxFail config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;Arguments exhausted after&quot;</span> ntest stamps</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> <span class="fu">putStr</span> (every config ntest (arguments result))</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>         <span class="kw">case</span> ok result <span class="kw">of</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Nothing</span>    <span class="ot">-&gt;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>             tests config gen rnd1 ntest (nfail<span class="op">+</span><span class="dv">1</span>) stamps</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>             tests config gen rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail (stamp result<span class="op">:</span>stamps)</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>             <span class="fu">putStr</span> ( <span class="st">&quot;Falsifiable, after &quot;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">show</span> ntest</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="st">&quot; tests:\n&quot;</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">unlines</span> (arguments result)</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>     <span class="kw">where</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>      result      <span class="ot">=</span> generate (size config ntest) rnd2 gen</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>      (rnd1,rnd2) <span class="ot">=</span> split rnd0</span></code></pre></div>
</section>
</section>
<section id="example-traditional-use-of-coverage" class="level3">
<h3><a href="#example-traditional-use-of-coverage"
title="Example: traditional use of coverage">Example: traditional use of
coverage</a></h3>
<p>Okay, so the above is the first version of the original
property-based testing tool, QuickCheck.</p>
<p>Before we extend it with coverage-guidance, let’s have a look at an
example property and how collecting statistics is typically used to
ensure good coverage.</p>
<p>The example we’ll have a look at is <code>insert</code>ing into an
already sorted list (from which insertion sort can be implemented):</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>insert x [] <span class="ot">=</span> [x]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>insert x (y <span class="op">:</span> xs) <span class="op">|</span> x <span class="op">&lt;=</span> y    <span class="ot">=</span> x <span class="op">:</span> y <span class="op">:</span> xs</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> y <span class="op">:</span> insert x xs</span></code></pre></div>
<p>If we do so, then we resulting list should remain sorted:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>prop_insert x xs <span class="ot">=</span> isSorted xs <span class="op">==&gt;</span> isSorted (insert x xs)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">isSorted ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>isSorted xs <span class="ot">=</span> <span class="fu">sort</span> xs <span class="op">==</span> xs</span></code></pre></div>
<p>This test passes:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_insert
OK, passed 100 tests.</code></pre>
<p>What do the test cases that are generated look like? This is where
<code>classify</code> comes in:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_insert&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>prop_insert&#39; x xs <span class="ot">=</span> isSorted xs <span class="op">==&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  classify (<span class="fu">null</span> xs) <span class="st">&quot;empty&quot;</span> <span class="op">$</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  classify (<span class="fu">length</span> xs <span class="op">==</span> <span class="dv">1</span>) <span class="st">&quot;singleton&quot;</span> <span class="op">$</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  classify (<span class="fu">length</span> xs <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> <span class="fu">length</span> xs <span class="op">&lt;=</span> <span class="dv">3</span>) <span class="st">&quot;short&quot;</span> <span class="op">$</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  classify (<span class="fu">length</span> xs <span class="op">&gt;</span> <span class="dv">3</span>) <span class="st">&quot;longer&quot;</span> <span class="op">$</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    isSorted (insert x xs)</span></code></pre></div>
<p>Running this property, we get some statistics about the generated
data:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_insert&#39;
OK, passed 100 tests.
54% empty.
27% singleton.
19% short.</code></pre>
<p>As we can see, all of the lists that get generated are less than 3
elements long! This is perhaps not what we expected. However if we
consider that precondition says that the list must be sorted, then it
should become clear that it’s unlikely to generate such longer such
lists completely by random<a href="#fn8" class="footnote-ref"
id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
</section>
<section id="the-extension-to-add-coverage-guidance" class="level3">
<h3><a href="#the-extension-to-add-coverage-guidance"
title="The extension to add coverage-guidance">The extension to add
coverage-guidance</a></h3>
<p>Now let’s add coverage-guidance to it using the machinery for
collecting statistics about the generated data.</p>
<p>The function that checks a property with coverage-guidance slight
different from <code>quickCheck</code><a href="#fn9"
class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">coverCheck ::</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>)  <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>coverCheck config prop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  rnd <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  testsC config arbitrary prop [] <span class="dv">0</span> rnd <span class="dv">0</span> <span class="dv">0</span> []</span></code></pre></div>
<p>In particular notice that instead of <code>Testable a</code> we use
an explicit predicate on a list of <code>a</code>,
<code>[a] -&gt; Property</code>. The reason for using a list in the
predicate is so that we can iteratively make progress, using the
coverage information. We see this more clearly if we look at the
coverage-guided analogue of the <code>tests</code> function, in
particular the <code>xs</code> parameter:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testsC ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>testsC config gen prop xs cov rnd0 ntest nfail stamps</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ntest <span class="op">==</span> maxTest config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;OK, passed&quot;</span> ntest stamps</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nfail <span class="op">==</span> maxFail config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;Arguments exhausted after&quot;</span> ntest stamps</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> <span class="fu">putStr</span> (every config ntest (arguments result))</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>         <span class="kw">case</span> ok result <span class="kw">of</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Nothing</span>    <span class="ot">-&gt;</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>             testsC config gen prop xs cov rnd1 ntest (nfail<span class="op">+</span><span class="dv">1</span>) stamps</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> stamps&#39; <span class="ot">=</span> stamp result <span class="op">:</span> stamps</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>                 cov&#39;    <span class="ot">=</span> <span class="fu">length</span> (nub (<span class="fu">concat</span> stamps&#39;))</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> cov&#39; <span class="op">&gt;</span> cov</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>             <span class="kw">then</span> testsC config gen prop xs&#39; cov&#39; rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail stamps&#39;</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>             <span class="kw">else</span> testsC config gen prop xs  cov  rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail stamps&#39;</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>             <span class="fu">putStrLn</span> ( <span class="st">&quot;Falsifiable, after &quot;</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">show</span> ntest</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="st">&quot; tests:\n&quot;</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">head</span> (arguments result)</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>     <span class="kw">where</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>       x              <span class="ot">=</span> generate (size config ntest) rnd3 gen</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>       xs&#39;            <span class="ot">=</span> xs <span class="op">++</span> [x]</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>       <span class="dt">Prop</span> genResult <span class="ot">=</span> prop xs&#39;</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>       result_        <span class="ot">=</span> generate (size config ntest) rnd4 genResult</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>       result         <span class="ot">=</span> result_ {arguments <span class="ot">=</span> <span class="fu">show</span> xs&#39; <span class="op">:</span> arguments result_ }</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>       (rnd1,rnd2)    <span class="ot">=</span> split rnd0</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>       (rnd3,rnd4)    <span class="ot">=</span> split rnd2</span></code></pre></div>
<p>The other important difference is the <code>cov</code>erage
parameter, which keeps track of how many things have been
<code>classify</code>ed (the <code>stamps</code> parameter). Notice how
we only add the newly generated input, <code>x</code>, if the
<code>cov</code>erage increases.</p>
</section>
<section id="example-using-coverage-to-guide-generation" class="level3">
<h3><a href="#example-using-coverage-to-guide-generation"
title="Example: using coverage to guide generation">Example: using
coverage to guide generation</a></h3>
<p>We now have all the pieces to test the example from the <a
href="#motivation">motivation</a> section:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>bad s <span class="ot">=</span> coverage <span class="dv">0</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">1</span> <span class="ch">&#39;a&#39;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">2</span> <span class="ch">&#39;d&#39;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">3</span> <span class="ch">&#39;!&#39;</span> <span class="op">$</span> <span class="kw">if</span> s <span class="op">==</span> <span class="st">&quot;bad!&quot;</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    coverage ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    coverage i ch <span class="ot">=</span> classify (s <span class="op">!?</span> i <span class="op">==</span> <span class="dt">Just</span> ch) [ch]</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    (!?) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">!?</span> i <span class="op">|</span> i <span class="op">&lt;</span> <span class="fu">length</span> xs <span class="ot">=</span> <span class="dt">Just</span> (xs <span class="op">!!</span> i)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This property basically says that there’s no string that’s equal to
<code>"bad!"</code>, which is obviously false. If we try to test this
property using the unmodified first version of QuickCheck:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testBad ::</span> <span class="dt">IO</span> ()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>testBad <span class="ot">=</span> check config bad</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    config <span class="ot">=</span> quick { maxTest <span class="ot">=</span> (<span class="dv">2</span><span class="op">^</span><span class="dv">8</span>)<span class="op">^</span><span class="dv">4</span> }</span></code></pre></div>
<p>We’ll see spin away, but not actually find the bad string:</p>
<pre><code>&gt;&gt;&gt; testBad
32301
^CInterrupted.</code></pre>
<p>I stopped it after about 32k tries, in theory we’d need more than 4
billion attempts to find the bad string using this approach.</p>
<p>Whereas if we use coverage-guided generation:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testBad&#39; ::</span> <span class="dt">IO</span> ()</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>testBad&#39; <span class="ot">=</span> coverCheck config bad</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    config <span class="ot">=</span> verbose</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>      { maxTest <span class="ot">=</span> (<span class="dv">2</span><span class="op">^</span><span class="dv">8</span>)<span class="op">*</span><span class="dv">4</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>      , every <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="fu">show</span> n <span class="op">++</span> <span class="st">&quot;: &quot;</span> <span class="op">++</span> <span class="fu">unlines</span> args</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>      }</span></code></pre></div>
<p>We find the bad string pretty quickly. I’m using verbose output here
so you can see how it first find the <code>"b"</code>, then
<code>"ba"</code>, etc<a href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a>:</p>
<pre><code>&gt;&gt;&gt; testBad&#39;
0: &quot;n&quot;          23: &quot;#&quot;         46: &quot;bai&quot;       69: &quot;badb&quot;
1: &quot;T&quot;          24: &quot;T&quot;         47: &quot;ba}&quot;       70: &quot;bad~&quot;
2: &quot;L&quot;          25: &quot;T&quot;         48: &quot;bay&quot;       71: &quot;bada&quot;
3: &quot;|&quot;          26: &quot;_&quot;         49: &quot;bac&quot;       72: &quot;bad%&quot;
4: &quot;X&quot;          27: &quot;@&quot;         50: &quot;bak&quot;       73: &quot;bad9&quot;
5: &quot;\&quot;&quot;         28: &quot;}&quot;         51: &quot;ba`&quot;       74: &quot;badE&quot;
6: &quot;e&quot;          29: &quot;y&quot;         52: &quot;bad&quot;       75: &quot;bad8&quot;
7: &quot;G&quot;          30: &quot;-&quot;         53: &quot;bad8&quot;      76: &quot;bad{&quot;
8: &quot;R&quot;          31: &quot;s&quot;         54: &quot;bade&quot;      77: &quot;badS&quot;
9: &quot;}&quot;          32: &quot;b&quot;         55: &quot;bad0&quot;      78: &quot;badn&quot;
10: &quot;C&quot;         33: &quot;bx&quot;        56: &quot;badA&quot;      79: &quot;bad?&quot;
11: &quot;3&quot;         34: &quot;b9&quot;        57: &quot;badP&quot;      80: &quot;badn&quot;
12: &quot;&gt;&quot;         35: &quot;bf&quot;        58: &quot;badQ&quot;      81: &quot;badq&quot;
13: &quot;C&quot;         36: &quot;bl&quot;        59: &quot;bad0&quot;      82: &quot;bady&quot;
14: &quot;J&quot;         37: &quot;ba&quot;        60: &quot;bade&quot;      83: &quot;badA&quot;
15: &quot;9&quot;         38: &quot;baC&quot;       61: &quot;bad)&quot;      84: &quot;bad4&quot;
16: &quot;=&quot;         39: &quot;baX&quot;       62: &quot;bado&quot;      85: &quot;bad;&quot;
17: &quot;9&quot;         40: &quot;baA&quot;       63: &quot;badE&quot;      86: &quot;bad9&quot;
18: &quot;L&quot;         41: &quot;baE&quot;       64: &quot;bad\&quot;&quot;     87: &quot;badU&quot;
19: &quot;)&quot;         42: &quot;bay&quot;       65: &quot;bad@&quot;      88: &quot;bad!&quot;
20: &quot;5&quot;         43: &quot;baX&quot;       66: &quot;bad{&quot;
21: &quot;6&quot;         44: &quot;ba6&quot;       67: &quot;badX&quot;
22: &quot;x&quot;         45: &quot;ba@&quot;       68: &quot;bado&quot;
Falsifiable, after 88 tests:
&quot;bad!&quot;</code></pre>
<p>The full source code is available <a
href="https://github.com/stevana/coverage-guided-pbt/blob/main/src/QuickCheckV1.hs">here</a>.</p>
</section>
</section>
<section id="conclusion-and-further-work" class="level2">
<h2><a href="#conclusion-and-further-work"
title="Conclusion and further work">Conclusion and further work</a></h2>
<p>We’ve seen how to add converage-guidance to the first version of the
first property-based testing tool, QuickCheck, in about 35 lines of
code.</p>
<p>Coverage-guidance effectively reduced a exponential problem into a
polynomial one, by building on previous test runs’ successes in
increasing the coverage.</p>
<p>The solution does change the QuickCheck API slightly by requring a
property on a list of <code>a</code>, rather than merely <code>a</code>,
so it’s not suitable for all properties.</p>
<p>I think this limitation isn’t so important, because going further I’d
like to apply coverage-guidance to testing stateful systems. When
testing stateful systems, which I’ve written about <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html">here</a>,
one always generates a list of commands anyway, so the limitation
doesn’t matter.</p>
<p>A more serious limitation with the current approach is that it’s too
greedy and will seek to maximise coverage, without ever backtracking.
This means that it can easily get stuck in local maxima. Consider the
example:</p>
<pre><code>if input[0] == &#39;o&#39;
  if input[1] == &#39;k&#39;
    return
if input[0] == &#39;b&#39;
  if input[1] == &#39;a&#39;
    if input[2] == &#39;d&#39;
      error</code></pre>
<p>If we generate an input that starts with ‘o’ (rather than ‘b’), then
we’ll get stuck never finding the error.</p>
<p>Real coverage-guided tools, like AFL, will not get stuck like that.
While I have a variant of the code that can cope with this, I chose to
present the above greedy version because it’s simpler.</p>
<p>I might write another post with a more AFL-like solution at some
later point, but I’d also like to encourge others to port these ideas to
your favorite language and experiment!</p>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This example is due to Dmitry Vyukov, the main author of
<a href="https://github.com/dvyukov/go-fuzz">go-fuzz</a>, but it’s
basically an easier to understand version of the example from Dan Luu’s
post. For comparison, here’s Dan’s example in full:</p>
<pre><code>// Checks that a number has its bottom bits set
func some_filter(x int) bool {
    for i := 0; i &lt; 16; i = i + 1 {
        if !(x&amp;1 == 1) {
            return false
        }
        x &gt;&gt;= 1
    }
    return true
}

// Takes an array and returns a non-zero int
func dut(a []int) int {
    if len(a) != 4 {
        return 1
    }

    if some_filter(a[0]) {
        if some_filter(a[1]) {
            if some_filter(a[2]) {
                if some_filter(a[3]) {
                    return 0 // A bug! We failed to return non-zero!
                }
                return 2
            }
            return 3
        }
        return 4
    }
    return 5
}</code></pre>
<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn2"><p>For more details about how it works, see the <a
href="https://lcamtuf.coredump.cx/afl/technical_details.txt">AFL
“whitepaper”</a> and its <a
href="https://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">mutation
heuristics</a>.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>In the case of Haskell, I didn’t know that there was
such a library until read Shae “shapr” Erisson’s post <a
href="https://shapr.github.io/posts/2023-07-30-goldilocks-property-tests.html"><em>Run
property tests until coverage stops increasing</em></a> (2023). Note
that Shae’s post only uses coverage as a stopping condition, not to
actually drive the generation of test cases.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>As I was writing up, I stumbled across the paper <a
href="https://ieeexplore.ieee.org/document/9152719"><em>Ijon: Exploring
Deep State Spaces via Fuzzing</em></a> (2020) which lets the user to add
custom coverage annotations. HypoFuzz also has this <a
href="https://hypofuzz.com/docs/configuration.html#custom-coverage-events">functionality</a>.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>See the appendix of the original <a
href="https://dl.acm.org/doi/10.1145/351240.351266">paper</a> that first
introduced property-based testing. It’s interesting to note that the
collecting statistics functionality is older than shrinking.<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>We’ll not talk about the <code>coarbitrary</code> method
of the <code>Arbitrary</code> type class, which is used to generate
functions, in this post.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>The reason for wrapping <code>Gen</code> in the
<code>Arbitrary</code> type class is so that generators don’t have to be
passed explicitly. Not everyone agrees that this is a good idea, as type
class instances cannot be managed by the module system.<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>The standard workaround here is to introduce a wrapper
type for which we write a custom generator which generates a random list
and then sorts it before returning. That way no pre-condition is needed,
as the input will be sorted by construction so to say.<a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>It might be interesting to note that we can implement
this signature using the original combinators:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testsC&#39; ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>testsC&#39; config gen prop <span class="ot">=</span> tests config genResult</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Prop</span> genResult <span class="ot">=</span> forAll (genList gen) prop</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    genList gen <span class="ot">=</span> sized <span class="op">$</span> \len <span class="ot">-&gt;</span> replicateM len gen</span></code></pre></div>
<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn10"><p>To save vertical space I’ve also arranged the output in
columns rather than one per line.<a href="#fnref10"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
