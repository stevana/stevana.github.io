<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>Coverage-guided property-based testing</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/coverage-guided_property-based_testing.html&t=Coverage-guided property-based testing">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About</a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>Coverage-guided property-based testing</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#background-and-prior-work"
id="toc-background-and-prior-work">Background and prior work</a></li>
<li><a href="#prototype-implementation"
id="toc-prototype-implementation">Prototype implementation</a></li>
<li><a href="#testing-some-examples-with-the-prototype"
id="toc-testing-some-examples-with-the-prototype">Testing some examples
with the prototype</a></li>
<li><a href="#conclusion-and-further-work"
id="toc-conclusion-and-further-work">Conclusion and further
work</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
</ul>
</nav>
<div class="date">Posted on Sep 24, 2024</div>
<p><em>Work in progress, please don’t share, but do feel free to get
involved!</em></p>
<p>Almost ten years ago, back in 2015, Dan Luu wrote a <a
href="https://danluu.com/testing/">post</a> asking why coverage-guided
property-based testing wasn’t a thing.</p>
<p>In this post I’ll show how one can implement such a thing starting
from scratch.</p>
<p>The technique is programming language agnostic and doesn’t rely on
any language-specific instrumentation of the software under test.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>Before we start, let me try to motivate why one would want to combine
coverage-guided fuzzing and property-based testing to begin with.</p>
<p>This example is due to Dmitry Vyukov, the main author of <a
href="https://github.com/dvyukov/go-fuzz">go-fuzz</a>, but it’s
basically an easier to understand version of the example from Dan’s
post<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<pre><code>func sut(input []byte) {
    slice := []int{}
    if input[0] == &#39;A&#39; {
        if input[1] == &#39;B&#39; {
            if input[2] == &#39;C&#39; {
                if input[3] == &#39;D&#39; {
                    slice[input[4]] = 1 // out-of-bounds here
                }
            }
        }
    }
}</code></pre>
<p>Even if we generate random inputs of exactly the length 4, it would
still take <span class="math inline">\(O(2^8 \cdot 2^8 \cdot 2^8 \cdot
2^8) = O((2^8)^4) = O(2^{32}) = 4294967296\)</span> tries to trigger the
bug (and obviously even longer if we tried arrays of varying
length).</p>
<p>With coverage-guidance we keep track of inputs that resulted in
increased coverage. So, for example, if we generate the array
<code>[]byte{'A'}</code> we get further into the nested ifs, and so we
take note of that and start generating longer arrays that start with ‘A’
and see if we get even further, etc.</p>
<p>By building on previous succeses in getting more coverage, we can
effectively reduce the problem to only need <span
class="math inline">\(O(2^8 + 2^8 + 2^8 + 2^8) = O(2^8 \cdot 4) =
O(2^{10}) = 1024\)</span> tries. With other words coverage-guidence
turns an exponential problem into a polynomial problem!</p>
</section>
<section id="background-and-prior-work" class="level2">
<h2><a href="#background-and-prior-work"
title="Background and prior work">Background and prior work</a></h2>
<p>Fuzzing has an interesting origin. It was a class <a
href="http://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf">project</a>
in an advanced operating systems course taught by Barton Miller at the
University of Wisconsin in 1988.</p>
<p>The project was inspired by the observation that back then, if you
logged into your workstation via a dail-up modem from home and it
rained, then frequently random characters would appear in the terminal.
The line noise wasn’t the surprising thing, but rather that the extra
characters would sometimes crash the program that they tried to
invoke.</p>
<p>Among these programs were basic utilities such as vi, mail, cc, make,
sed, awk, sort, etc, and it was reasonable to expect that these would
give an error message rather than crash and core dump if fed with some
extra characters caused by the rain.</p>
<p>So the project set out to basically recreate what the rain did, but
more effectively, but essentially generating random noise (stream of
bytes) and feeding that to different utilities and see if they
crashed.</p>
<p>A couple of years later Barton et al published <a
href="https://dl.acm.org/doi/10.1145/96267.96279"><em>An empirical study
of the reliability of UNIX utilities</em></a> (1990).</p>
<p>Inserting random characters was effective in finding corner cases
where the programmers forgot to properly validate the input from the
user.</p>
<p>However it wouldn’t trigger bugs hiding deeper under the surface.</p>
<p>This changed around 2007 when people <a
href="https://lcamtuf.coredump.cx/afl/historical_notes.txt">started
thinking</a> about how fuzzing can be combined with <a
href="https://en.wikipedia.org/wiki/Evolutionary_algorithm">evolutionary
algorithms</a>.</p>
<p>XXX: The idea being that…</p>
<ul>
<li>AFL (2013),</li>
</ul>
<p>Coverage-guided fuzzers, such as <a
href="https://lcamtuf.coredump.cx/afl/">American Fuzzy Lop</a> (AFL),
have been very successful in finding <a
href="https://lcamtuf.coredump.cx/afl/#bugs">bugs</a> in programs that
take bytes as input. That means any kind of programs that takes user
strings, command line arguments or files as inputs, parsers, but also
arrays of ints, etc.</p>
<ul>
<li><p><a
href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html"
class="uri">https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html</a></p></li>
<li><p><a
href="https://lcamtuf.coredump.cx/afl/technical_details.txt">AFL
“whitepaper”</a></p></li>
<li><p><a
href="https://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">AFL
mutation heuristics</a></p></li>
<li><p>AFL is the tool that Dan Luu explicitly mentions, so let’s stop
here and go back to his point, before looking at else has happened
since</p></li>
<li><p>“Note: AFL hasn’t been updated for a couple of years; while it
should &gt; still work fine, a more complex fork with a variety of
improvements &gt; and additional features, known as AFL++, is available
from other &gt; members of the community and is worth checking out.” –
&gt; <a href="https://lcamtuf.coredump.cx/afl/"
class="uri">https://lcamtuf.coredump.cx/afl/</a></p>
<ul>
<li><a
href="https://www.usenix.org/system/files/woot20-paper-fioraldi.pdf">AFL++</a>
(2020) incorporates all of <a
href="https://mboehme.github.io/paper/CCS16.pdf">AFLFast</a>’s <a
href="https://aflplus.plus/docs/power_schedules/">power schedules</a>
and adds some news ones</li>
<li><a href="https://github.com/mboehme/aflfast"
class="uri">https://github.com/mboehme/aflfast</a></li>
</ul></li>
<li><p>PBT</p></li>
<li><p>I’ve written about the <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html#the-history-of-property-based-testing">history</a>
of property-based testing and explained how it <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html#pure-property-based-testing-recap">works</a>
already, so I won’t take up space by repeating myself here. Let’s just
note that the <a
href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">original
paper</a> on property-based testing was published in 2000.</p></li>
<li><p>The idea of combining coverage-guidance and PBT</p></li>
<li><p>Now let’s have a look at what has happend since Dan’s
post.</p></li>
<li><p>First off, at some point he added an update to his post where he
explicitly mentiones:</p>
<ul>
<li><p>Go-fuzz?</p>
<ul>
<li>writing properties using go-fuzz: <a
href="https://news.ycombinator.com/item?id=40876822"
class="uri">https://news.ycombinator.com/item?id=40876822</a></li>
<li><a
href="https://adalogics.com/blog/structure-aware-go-fuzzing-complex-types"
class="uri">https://adalogics.com/blog/structure-aware-go-fuzzing-complex-types</a></li>
</ul></li>
<li><p>Hypothesis</p>
<ul>
<li>Has notion of coverage: <a
href="https://hypothesis.readthedocs.io/en/latest/details.html#hypothesis.event"
class="uri">https://hypothesis.readthedocs.io/en/latest/details.html#hypothesis.event</a>)</li>
<li>But coverage-guided testing was <a
href="https://github.com/HypothesisWorks/hypothesis/pull/1564/commits/dcbea9148be3446392bc3af8892d49f3cc74fbe3">removed</a></li>
</ul></li>
</ul></li>
<li><p>When you search for coverage guided property-based
testing</p></li>
<li><p><a href="https://dl.acm.org/doi/10.1145/3360607">FuzzChick</a>
(2019). Not released, lives in an <a
href="https://github.com/QuickChick/QuickChick/compare/master...FuzzChick">unmaintained
branch</a> that <a
href="https://github.com/QuickChick/QuickChick/issues/277">doesn’t
compile</a>?</p>
<ul>
<li>coverage info is <a href="https://youtu.be/RR6c_fiMfJQ?t=2226">same
as in AFL</a></li>
</ul></li>
<li><p>FuzzChick, related work mentions:</p></li>
<li><p><a href="https://github.com/rohanpadhye/jqf">JQF + Zest:
Coverage-guided semantic fuzzing for Java</a>?</p></li>
<li><p><a href="https://github.com/stedolan/crowbar">Crowbar</a></p>
<ul>
<li><a
href="https://github.com/ocaml/ocaml.org-media/blob/086fc25105cbccb188c28ec74126d72962921ff8/meetings/ocaml/2017/extended-abstract__2017__stephen-dolan_mindy-preston__testing-with-crowbar.pdf">extended
abstract from OCaml workshop</a>
<ol start="2017" type="1">
<li></li>
</ol></li>
<li>Uses fuzzing indirectly to generate the data?</li>
</ul></li>
<li><p><a href="https://llvm.org/docs/LibFuzzer.html">libfuzzer</a> and
it’s successor <a href="https://github.com/google/fuzztest">FuzzTest</a>
(“It is a first-of-its-kind tool that bridges the gap between fuzzing
and property-based testing”) (2022?)</p></li>
<li><p><a href="https://github.com/google/honggfuzz">honggfuzz</a></p>
<ul>
<li>open PR to add it to cargo fuzz: <a
href="https://github.com/rust-fuzz/book/pull/14"
class="uri">https://github.com/rust-fuzz/book/pull/14</a></li>
</ul></li>
<li><p><a
href="https://rust-fuzz.github.io/book/cargo-fuzz/structure-aware-fuzzing.html">Structure-aware
fuzzing using libfuzzer-sys in Rust</a></p></li>
<li><p><a
href="https://www.mista.me/assets/pdf/icst23-preprint.pdf">MUTAGEN:
Reliable Coverage-Guided, Property-Based Testing using Exhaustive
Mutations</a> (2023)</p>
<ul>
<li><a href="https://github.com/OctopiChalmers/mutagen/"
class="uri">https://github.com/OctopiChalmers/mutagen/</a></li>
<li>Uses GHC <a
href="https://github.com/OctopiChalmers/mutagen/blob/main/src/Test/Mutagen/Tracer/Plugin.hs">plugin</a>
to annotate source code with coverage information of: function clauses,
case statements, multi-way ifs, and each branch of if-then-else
expressions</li>
</ul></li>
</ul>
<p>Imperative languages such as C++, Go, Rust, and Java seem ahead of
functional languages when it comes to combining coverage-guided fuzzing
and property-based testing.</p>
<p>Let’s try to change that by implementing a small functional
programming version, based on the original property-based testing
implementation.</p>
</section>
<section id="prototype-implementation" class="level2">
<h2><a href="#prototype-implementation"
title="Prototype implementation">Prototype implementation</a></h2>
<p>If we want</p>
<p>Great, but where do we get this coverage information from?</p>
<p>AFL and <code>go-fuzz</code> both get it from the compiler.</p>
<p>AFL injects code into every <a
href="https://en.wikipedia.org/wiki/Basic_block">basic block</a>.</p>
<p>When I’ve been thinking about how to implement coverage-guided
property-based testing in the past, I always got stuck thinking that
parsing the coverage output from the compiler in between test case
generation rounds would be annoying and slow.</p>
<p>I didn’t know that you could get this information from a library
provided by the GHC compiler in Haskell, until I read Shae “shapr”
Erisson does in his <a
href="https://shapr.github.io/posts/2023-07-30-goldilocks-property-tests.html">post</a>.</p>
<p>While this certainly makes things easier, it wasn’t until I read
about Antithesis’ <a
href="https://antithesis.com/docs/best_practices/sometimes_assertions.html">“sometime
assertions”</a> that I started seeing a really simple solution to the
problem.</p>
<p>These “sometimes assertions” can be thought of as generalised
coverage, in that if we would annotate every single line, expression or
branch with a sometime assertion we’d get back line-, expression-, or
branch-based coverage.</p>
<p>But the cool thing about “sometimes assertions” is that we don’t need
to annotate every single line, expression or branch, we can annotate
<em>interesting</em> points in our program.</p>
<p>The final piece of the puzzle, and I think this is the only original
idea that this post adds, is that property-based testing already has
functionality for implementing “sometimes assertions”: the
<code>label</code>, <code>classify</code> and <code>collect</code>
machinary for gathering run-time statistics of the generated data!</p>
<p>This machinary is <a
href="https://www.youtube.com/watch?v=NcJOiQlzlXQ">crucial</a> for
writing good tests and has been part of the QuickCheck implementation
since the very first version<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a>!</p>
<p>So the question is: can we implement coverage-guided property-based
testing using the internal notion of coverage that property-based
testing already has?</p>
<ul>
<li><p>QuickCheck as defined in the appendix of the original <a
href="https://dl.acm.org/doi/10.1145/351240.351266">paper</a> (ICFP,
2000)</p>
<ul>
<li>Extended monadic properties</li>
</ul></li>
<li><p>Edsko de Vries’ <a
href="https://www.well-typed.com/blog/2019/05/integrated-shrinking/">Mini-QuickCheck</a></p></li>
</ul>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="ot">=</span> <span class="dt">Gen</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> a)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">generate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>generate n rnd (<span class="dt">Gen</span> m) <span class="ot">=</span> m size rnd&#39;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  (size, rnd&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, n) rnd</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rand ::</span> <span class="dt">Gen</span> <span class="dt">StdGen</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>rand <span class="ot">=</span> <span class="dt">Gen</span> (\_n r <span class="ot">-&gt;</span> r)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sized ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>sized fgen <span class="ot">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">Gen</span> m <span class="ot">=</span> fgen n <span class="kw">in</span> m n r)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">coverCheck ::</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>)  <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>coverCheck config prop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  rnd <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  testsC config arbitrary prop [] <span class="dv">0</span> rnd <span class="dv">0</span> <span class="dv">0</span> []</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">label ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>label s a <span class="ot">=</span> <span class="dt">Prop</span> (add <span class="ot">`fmap`</span> evaluate a)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  add res <span class="ot">=</span> res{ stamp <span class="ot">=</span> s <span class="op">:</span> stamp res }</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">classify ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>classify <span class="dt">True</span>  name <span class="ot">=</span> label name</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>classify <span class="dt">False</span> _    <span class="ot">=</span> property</span></code></pre></div>
<p>The full source code is available <a
href="https://github.com/stevana/coverage-guided-pbt">here</a>.</p>
</section>
<section id="testing-some-examples-with-the-prototype" class="level2">
<h2><a href="#testing-some-examples-with-the-prototype"
title="Testing some examples with the prototype">Testing some examples
with the prototype</a></h2>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>bad s <span class="ot">=</span> coverage <span class="dv">0</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">1</span> <span class="ch">&#39;a&#39;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">2</span> <span class="ch">&#39;d&#39;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">3</span> <span class="ch">&#39;!&#39;</span> <span class="op">$</span> <span class="kw">if</span> s <span class="op">==</span> <span class="st">&quot;bad!&quot;</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    coverage ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    coverage i ch <span class="ot">=</span> classify (s <span class="op">!?</span> i <span class="op">==</span> <span class="dt">Just</span> ch) [ch]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    (!?) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">!?</span> i <span class="op">|</span> i <span class="op">&lt;</span> <span class="fu">length</span> xs <span class="ot">=</span> <span class="dt">Just</span> (xs <span class="op">!!</span> i)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="ot">testBad ::</span> <span class="dt">IO</span> ()</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>testBad <span class="ot">=</span> coverCheck (verbose { maxTest <span class="ot">=</span> <span class="dv">2</span><span class="op">^</span><span class="dv">7</span><span class="op">*</span><span class="dv">4</span><span class="op">*</span><span class="dv">2</span> }) bad</span></code></pre></div>
</section>
<section id="conclusion-and-further-work" class="level2">
<h2><a href="#conclusion-and-further-work"
title="Conclusion and further work">Conclusion and further work</a></h2>
<ul>
<li><p>Makes more sense for stateful systems than pure functions? Or
atleast properties that expect a sequence of inputs?</p></li>
<li><p>Don’t rerun all commands for every newly generate command</p>
<ul>
<li>only reset the system when shrinking</li>
</ul></li>
<li><p>Problem of strategy (pick something as basis for progress):
coverage, logs, value of memory, helps bootstap the process. Generalise
to support more?</p></li>
<li><p>Local maxima?</p></li>
<li><p>Problem of tactics: picking a good input distributed for the
testing problem at hand. Make previous input influence the next input?
Dependent events, e.g. if one packet gets lost, there’s a higher chance
that the next packet will be lost as well.</p></li>
<li><p>Save <code>(Coverage, Mutation, Frequency, Coverage)</code>
stats?</p></li>
<li><p>More realistic example, e.g.: leader election, transaction
rollback, failover?</p></li>
<li><p>Annoying to sprinkle sometimes assertions everywhere?</p>
<ul>
<li>Can it be combined with logging or tracing?</li>
</ul></li>
<li><p>Use size parameter to implement AFL heuristic for choosing
integers? Or just use <code>frequency</code>?</p></li>
<li><p>Type-generic mutation?</p></li>
<li><p>sometimes_each?</p></li>
</ul>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li><a
href="https://carstein.github.io/fuzzing/2020/04/18/writing-simple-fuzzer-1.html"
class="uri">https://carstein.github.io/fuzzing/2020/04/18/writing-simple-fuzzer-1.html</a></li>
<li><a
href="https://carstein.github.io/fuzzing/2020/04/25/writing-simple-fuzzer-2.html"
class="uri">https://carstein.github.io/fuzzing/2020/04/25/writing-simple-fuzzer-2.html</a></li>
<li><a
href="https://carstein.github.io/fuzzing/2020/05/02/writing-simple-fuzzer-3.html"
class="uri">https://carstein.github.io/fuzzing/2020/05/02/writing-simple-fuzzer-3.html</a></li>
<li><a
href="https://carstein.github.io/fuzzing/2020/05/21/writing-simple-fuzzer-4.html"
class="uri">https://carstein.github.io/fuzzing/2020/05/21/writing-simple-fuzzer-4.html</a></li>
<li><a href="https://antithesis.com/blog/sdtalk/">How Antithesis finds
bugs (with help from the Super Mario Bros)</a></li>
<li>Swarm testing</li>
<li>Shae “shapr” Erisson’s post <a
href="https://shapr.github.io/posts/2023-07-30-goldilocks-property-tests.html"><em>Run
property tests until coverage stops increasing</em></a> (2023) and <a
href="https://github.com/shapr/trynocular">trynocular</a> library.
<ul>
<li>This only uses coverage as a stopping condition, not to actually
drive the generation…</li>
</ul></li>
</ul>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Here’s Dan’s example in full:</p>
<pre><code>// Checks that a number has its bottom bits set
func some_filter(x int) bool {
    for i := 0; i &lt; 16; i = i + 1 {
        if !(x&amp;1 == 1) {
            return false
        }
        x &gt;&gt;= 1
    }
    return true
}

// Takes an array and returns a non-zero int
func dut(a []int) int {
    if len(a) != 4 {
        return 1
    }

    if some_filter(a[0]) {
        if some_filter(a[1]) {
            if some_filter(a[2]) {
                if some_filter(a[3]) {
                    return 0 // A bug! We failed to return non-zero!
                }
                return 2
            }
            return 3
        }
        return 4
    }
    return 5
}</code></pre>
<p>As I hope we can agree, it’s very similar to Dmitry’s example, except
it’s a bit less clear what exactly happens in the if statement.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>See the appendix of the original <a
href="https://dl.acm.org/doi/10.1145/351240.351266">paper</a> that first
introduced property-based testing. It’s interesting to note that this
functionality is older than shrinking.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
