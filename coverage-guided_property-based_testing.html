<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>Coverage-guided property-based testing</title>
  <link rel="stylesheet" href="style.css?modified=2024-09-25" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/coverage-guided_property-based_testing.html&t=Coverage-guided property-based testing">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About / <span class="work-with-me">Work with me</span></a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>Coverage-guided property-based testing</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#background-and-prior-work"
id="toc-background-and-prior-work">Background and prior work</a>
<ul>
<li><a href="#before-2015" id="toc-before-2015">Before 2015</a></li>
<li><a href="#after-2015" id="toc-after-2015">After 2015</a></li>
</ul></li>
<li><a href="#prototype-implementation"
id="toc-prototype-implementation">Prototype implementation</a>
<ul>
<li><a href="#getting-the-coverage-information"
id="toc-getting-the-coverage-information">Getting the coverage
information</a></li>
<li><a href="#the-first-version-of-quickcheck"
id="toc-the-first-version-of-quickcheck">The first version of
QuickCheck</a></li>
<li><a href="#the-extension-to-add-coverage-guidance"
id="toc-the-extension-to-add-coverage-guidance">The extension to add
coverage-guidance</a></li>
</ul></li>
<li><a href="#example-test-run-using-the-prototype"
id="toc-example-test-run-using-the-prototype">Example test run using the
prototype</a></li>
<li><a href="#conclusion-and-further-work"
id="toc-conclusion-and-further-work">Conclusion and further
work</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
</ul>
</nav>
<div class="date">Posted on Sep 25, 2024</div>
<p><em>Work in progress, please don’t share, but do feel free to get
involved!</em></p>
<p>Almost ten years ago, back in 2015, Dan Luu wrote a <a
href="https://danluu.com/testing/">post</a> asking why coverage-guided
property-based testing wasn’t a thing.</p>
<p>In this post I’ll survey the coverage-guided landscape, looking at
what was there before Dan’s post and what has happened since.</p>
<p>The short version is: today imperative languages seem to be in the
forefront of combining coverage-guidance and property-based testing.</p>
<p>In an effort to try to help functional programming languages catch
up, I’ll show how coverage-guidence can be added to the first version of
the original property-based testing tool, QuickCheck, in about 35 lines
of code.</p>
<p>The technique is programming language agnostic and doesn’t rely on
any language-specific instrumentation of the software under test (unlike
previous implementations of this idea).</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>Before we start, let me try to motivate why one would want to combine
coverage-guided fuzzing and property-based testing to begin with.</p>
<p>Consider the following example<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>, where an error is
triggered if some input byte array starts with the bytes
<code>"bad!"</code>:</p>
<pre><code>func sut(input []byte) {
    if input[0] == &#39;b&#39; {
        if input[1] == &#39;a&#39; {
            if input[2] == &#39;d&#39; {
                if input[3] == &#39;!&#39; {
                    panic(&quot;input must not be bad!&quot;)
                }
            }
        }
    }
}</code></pre>
<p>If we were to try to test this function with property-based testing,
where we restrict the input to be of exactly length 4, then it would
still take <span class="math inline">\(\mathcal{O}(2^8 \cdot 2^8 \cdot
2^8 \cdot 2^8) = \mathcal{O}((2^8)^4) = \mathcal{O}(2^{32}) \approx
4B\)</span> tries to trigger the bug! A more realistic test wouldn’t fix
the length of the input, which would make the probability of triggering
the bug even lower.</p>
<p>With coverage-guidance we keep track of inputs that resulted in
increased coverage. So, for example, if we generate the array
<code>[]byte{'A'}</code> we get further into the nested ifs, and so we
take note of that and start generating longer arrays that start with ‘A’
and see if we get even further, etc.</p>
<p>By building on previous succeses in getting more coverage, we can
effectively reduce the problem to only need <span
class="math inline">\(\mathcal{O}(2^8 + 2^8 + 2^8 + 2^8) =
\mathcal{O}(2^8 \cdot 4) = \mathcal{O}(2^{10}) = 1024\)</span>
tries.</p>
<p>In other words coverage-guidence turns an exponential problem into a
polynomial problem!</p>
</section>
<section id="background-and-prior-work" class="level2">
<h2><a href="#background-and-prior-work"
title="Background and prior work">Background and prior work</a></h2>
<section id="before-2015" class="level3">
<h3><a href="#before-2015" title="Before 2015">Before 2015</a></h3>
<p>Fuzzing has an interesting origin. It was a class <a
href="http://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf">project</a>
in an advanced operating systems course taught by Barton Miller at the
University of Wisconsin in 1988.</p>
<p>The project was inspired by the observation that back then, if you
logged into your workstation via a dail-up modem from home and it
rained, then frequently random characters would appear in the terminal.
The line noise wasn’t the surprising thing, but rather that the extra
characters would sometimes crash the program that they tried to
invoke.</p>
<p>Among these programs were basic utilities such as <code>vi</code>,
<code>mail</code>, <code>cc</code>, <code>make</code>, <code>sed</code>,
<code>awk</code>, <code>sort</code>, etc, and it was reasonable to
expect that these would give an error message rather than crash and core
dump if fed with some extra characters caused by the rain.</p>
<p>So the project set out to basically recreate what the rain did, but
more effectively, but essentially generating random noise (stream of
bytes) and feeding that to different utilities and see if they
crashed.</p>
<p>A couple of years later Barton et al published <a
href="https://dl.acm.org/doi/10.1145/96267.96279"><em>An empirical study
of the reliability of UNIX utilities</em></a> (1990) which documents
their findings.</p>
<p>Inserting random characters was effective in finding corner cases
where the programmers forgot to properly validate the input from the
user.</p>
<p>However it wouldn’t trigger bugs hiding deeper under the surface,
such as the “bad!” example from the previous section.</p>
<p>This changed around 2007 when people <a
href="https://lcamtuf.coredump.cx/afl/historical_notes.txt">started
thinking</a> about how fuzzing can be combined with <a
href="https://en.wikipedia.org/wiki/Evolutionary_algorithm">evolutionary
algorithms</a>.</p>
<p>The idea being that instead of generating random bytes all the time
as with classical fuzzing, we can use coverage information from one test
to mutate the input for the next test. Or to use the evolution metaphor:
seeds that lead to better coverage are mutated with the hope that they
will lead to even better coverage.</p>
<p>One of the first, and perhaps still most widely known, such
<em>coverage-guided</em> fuzzers is called <a
href="https://lcamtuf.coredump.cx/afl/">AFL</a> (2013).</p>
<p>To give you an idea of how powerful this idea is, check out the list
of <a href="https://lcamtuf.coredump.cx/afl/#bugs">bugs</a> that it
found and this post about how it manages to figure out the <a
href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">jpeg
format</a> on its own.</p>
<p>For more details about how it works, see the <a
href="https://lcamtuf.coredump.cx/afl/technical_details.txt">AFL
“whitepaper”</a> and its <a
href="https://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">mutation
heuristics</a>.</p>
<p>Since AFL is the tool that Dan explicitly mentions in his post, let’s
stop at this point and go back to this point, before looking at what
happened since with coverage-guided fuzzers.</p>
<p>Recall that Dan was asking why this idea of coverage-guidance wasn’t
present in property-based testing tools.</p>
<p>I’ve written about the <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html#the-history-of-property-based-testing">history</a>
of property-based testing and explained how it <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html#pure-property-based-testing-recap">works</a>
already, so I won’t take up space by repeating myself here. Let’s just
note that the <a
href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">original
paper</a> on property-based testing was published in 2000.</p>
<p>So when Dan wrote asking about this question property-based testing
would have been fifteen and AFL two years old.</p>
<p>The main difference between property-based testing and fuzzing is
that fuzzing requires less work by the user. Simply hook up the byte
generator to the function that expects bytes as input and off it goes
looking for crashes.</p>
<p>Property-based testing on the other hand can test functions that take
arbitrary data structures as input (not just bytes), but you have to
describe how to generate such inputs. Fuzzing only looks for crashes,
while property-based testing lets you specify arbitrary relations that
should hold between the input and output of the system under test.</p>
<p>For example, we can generate binary search trees and check that after
we insert something into an arbitrary binary search tree then it will
remain sorted (when we do an inorder traversal). Fuzzing can’t check
such properties, and generating random bytes would seldom lead to valid
binary search trees.</p>
<p>On the other hand, the coverage of property-based tests is only as
good as the user provided generators. Corner cases where slightly
modified data leads to e.g. exception handling is not explored
automatically, and coverage information is not used to guide the input
generation process.</p>
<p>By now we should have enough background to see that the idea of
combining coverage-guidance and property-based testing makes sense. What
if we can use user provided generators to kick start the exploration,
but then mutate the data and use coverage information to find problems
that wouldn’t have been surfaced with the user provided input generators
alone (or recall from the example in the introduction, the probability
of generating the input in a single shot is simply too unlikely).</p>
</section>
<section id="after-2015" class="level3">
<h3><a href="#after-2015" title="After 2015">After 2015</a></h3>
<p>Having covered what had happened before Dan’s post, let’s have a look
at what has happened in the ten years since his post.</p>
<p>First off, it’s worth noting that at some point he added an update to
his post:</p>
<blockquote>
<p>“Update: Dmitry Vyukov’s Go-fuzz, which looks like it was started a
month after this post was written, uses the approach from the proof of
concept in this post of combining the sort of logic seen in AFL with a
QuickCheck-like framework, and has been shown to be quite effective. I
believe David R. MacIver is also planning to use this approach in the
next version of hypothesis.”</p>
</blockquote>
<p>So let’s start there, with Go-fuzz. At a first glance, all functions
that are tested with Go-fuzz need to take an array of bytes as input. My
initial thought was, how can I write properties which involve generating
more interesting data structures? But it turns out it’s <a
href="https://news.ycombinator.com/item?id=40876822">possible</a>, as
somebody pointed out in the comments of an old post of mine. Furthermore
there are also <a
href="https://adalogics.com/blog/structure-aware-go-fuzzing-complex-types">ways</a>
of making the fuzzer aware of more complex data structures. I haven’t
played around enough with this to be able to compare how well shrinking
works yet though, but overall I’d say this ticks the box of being a
property-based testing tool that is also coverage-guided.</p>
<p>Next up Dan mentions Python’s Hypothesis. I was searching through the
documentation trying to find out how coverage-guidance works, but I
couldn’t find anything. Searching through the repository I found the
following <a
href="https://github.com/HypothesisWorks/hypothesis/pull/1564/commits/dcbea9148be3446392bc3af8892d49f3cc74fbe3">release
note</a> (2018):</p>
<blockquote>
<p>“This release deprecates the coverage-guided testing functionality,
as it has proven brittle and does not really pull its weight.</p>
<p>We intend to replace it with something more useful in the future, but
the feature in its current form does not seem to be worth the cost of
using, and whatever replaces it will likely look very different.”</p>
</blockquote>
<p>As far as I can tell, it hasn’t been reintroduced since.</p>
<p>However it’s possible to hook Hypothesis up to <a
href="https://hypothesis.readthedocs.io/en/latest/details.html#use-with-external-fuzzers">use
external fuzzers</a>.</p>
<p>XXX: how does this work? like in Crowbar? What are the disadvantages?
Why isn’t this the default?</p>
<p>What else has happenend since Dan’s post?</p>
<p>One of the first things I noticed is that AFL is no longer <a
href="https://lcamtuf.coredump.cx/afl/">maintained</a>:</p>
<blockquote>
<p>“Note: AFL hasn’t been updated for a couple of years; while it should
still work fine, a more complex fork with a variety of improvements and
additional features, known as AFL++, is available from other members of
the community and is worth checking out.”</p>
</blockquote>
<p><a
href="https://www.usenix.org/system/files/woot20-paper-fioraldi.pdf">AFL++</a>
(2020)</p>
<ul>
<li>incorporates all of <a
href="https://mboehme.github.io/paper/CCS16.pdf">AFLFast</a>’s <a
href="https://aflplus.plus/docs/power_schedules/">power schedules</a>
and adds some new ones</li>
<li>explain what power schedules are?</li>
<li><a href="https://github.com/mboehme/aflfast"
class="uri">https://github.com/mboehme/aflfast</a></li>
</ul>
<!-- -->
<ul>
<li><p>When you search for “coverage-guided property-based testing” in
the academic literature</p></li>
<li><p><a href="https://dl.acm.org/doi/10.1145/3360607"><em>Coverage
guided, property based testing</em></a> by Leonidas Lampropoulos,
Michael Hicks, Benjamin C. Pierce (2019)</p></li>
<li><p>FuzzChick Coq/Rocq library</p></li>
<li><p>Not released, lives in an <a
href="https://github.com/QuickChick/QuickChick/compare/master...FuzzChick">unmaintained
branch</a> that <a
href="https://github.com/QuickChick/QuickChick/issues/277">doesn’t
compile</a>?</p>
<ul>
<li>coverage info is <a href="https://youtu.be/RR6c_fiMfJQ?t=2226">same
as in AFL</a></li>
</ul></li>
<li><p>FuzzChick, related work mentions:</p></li>
<li><p><a href="https://github.com/rohanpadhye/jqf">JQF + Zest:
Coverage-guided semantic fuzzing for Java</a>?</p></li>
<li><p><a href="https://github.com/stedolan/crowbar">Crowbar</a></p>
<ul>
<li><a
href="https://github.com/ocaml/ocaml.org-media/blob/086fc25105cbccb188c28ec74126d72962921ff8/meetings/ocaml/2017/extended-abstract__2017__stephen-dolan_mindy-preston__testing-with-crowbar.pdf">extended
abstract from OCaml workshop</a>
<ol start="2017" type="1">
<li></li>
</ol></li>
<li>Uses fuzzing indirectly to generate the data?</li>
</ul></li>
<li><p><a href="https://llvm.org/docs/LibFuzzer.html">libfuzzer</a> and
it’s successor <a href="https://github.com/google/fuzztest">FuzzTest</a>
(“It is a first-of-its-kind tool that bridges the gap between fuzzing
and property-based testing”) (2022?)</p>
<ul>
<li>Difference to go-fuzz?</li>
</ul></li>
<li><p><a href="https://github.com/google/honggfuzz">honggfuzz</a></p>
<ul>
<li>open PR to add it to cargo fuzz: <a
href="https://github.com/rust-fuzz/book/pull/14"
class="uri">https://github.com/rust-fuzz/book/pull/14</a></li>
</ul></li>
<li><p><a
href="https://rust-fuzz.github.io/book/cargo-fuzz/structure-aware-fuzzing.html">Structure-aware
fuzzing using libfuzzer-sys in Rust</a></p></li>
<li><p><a
href="https://www.mista.me/assets/pdf/icst23-preprint.pdf">MUTAGEN:
Reliable Coverage-Guided, Property-Based Testing using Exhaustive
Mutations</a> (2023)</p>
<ul>
<li><a href="https://github.com/OctopiChalmers/mutagen/"
class="uri">https://github.com/OctopiChalmers/mutagen/</a></li>
<li>Uses GHC <a
href="https://github.com/OctopiChalmers/mutagen/blob/main/src/Test/Mutagen/Tracer/Plugin.hs">plugin</a>
to annotate source code with coverage information of: function clauses,
case statements, multi-way ifs, and each branch of if-then-else
expressions</li>
</ul></li>
</ul>
<p>Imperative languages such as C++, Go, Rust, and Java seem ahead of
functional languages when it comes to combining coverage-guided fuzzing
and property-based testing.</p>
<p>Let’s try to change that by implementing a small functional
programming version, based on the original property-based testing
implementation.</p>
</section>
</section>
<section id="prototype-implementation" class="level2">
<h2><a href="#prototype-implementation"
title="Prototype implementation">Prototype implementation</a></h2>
<p>One key question we need to answer in order to be able to implement
anything that’s coverage-guided is: where do we get the coverage
information from?</p>
<section id="getting-the-coverage-information" class="level3">
<h3><a href="#getting-the-coverage-information"
title="Getting the coverage information">Getting the coverage
information</a></h3>
<p>AFL and <code>go-fuzz</code> both get it from the compiler.</p>
<p>AFL injects code into every <a
href="https://en.wikipedia.org/wiki/Basic_block">basic block</a>.</p>
<p>When I’ve been thinking about how to implement coverage-guided
property-based testing in the past, I always got stuck thinking that
parsing the coverage output from the compiler in between test case
generation rounds would be annoying and slow.</p>
<p>I didn’t know that you could get this information from a library
provided by the GHC compiler in Haskell, until I read Shae “shapr”
Erisson does in his <a
href="https://shapr.github.io/posts/2023-07-30-goldilocks-property-tests.html">post</a>.</p>
<ul>
<li>Footnote? Shae “shapr” Erisson’s post <a
href="https://shapr.github.io/posts/2023-07-30-goldilocks-property-tests.html"><em>Run
property tests until coverage stops increasing</em></a> (2023) and <a
href="https://github.com/shapr/trynocular">trynocular</a> library.
<ul>
<li>This only uses coverage as a stopping condition, not to actually
drive the generation…</li>
</ul></li>
</ul>
<p>While this certainly makes things easier, it wasn’t until I read
about Antithesis’ <a
href="https://antithesis.com/docs/best_practices/sometimes_assertions.html">“sometime
assertions”</a> that I started seeing a really simple solution to the
problem.</p>
<p>These “sometimes assertions” can be thought of as generalised
coverage, in that if we would annotate every single line, expression or
branch with a sometime assertion we’d get back line-, expression-, or
branch-based coverage.</p>
<p>But the cool thing about “sometimes assertions” is that we don’t need
to annotate every single line, expression or branch, we can annotate
<em>interesting</em> points in our program.</p>
<p>The final piece of the puzzle, and I think this is the only original
idea that this post adds, is that property-based testing already has
functionality for implementing “sometimes assertions”: the
<code>label</code>, <code>classify</code> and <code>collect</code>
machinary for gathering run-time statistics of the generated data!</p>
<p>This machinary is <a
href="https://www.youtube.com/watch?v=NcJOiQlzlXQ">crucial</a> for
writing good tests and has been part of the QuickCheck implementation
since the very first version<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a>!</p>
<p>So the question is: can we implement coverage-guided property-based
testing using the internal notion of coverage that property-based
testing already has?</p>
</section>
<section id="the-first-version-of-quickcheck" class="level3">
<h3><a href="#the-first-version-of-quickcheck"
title="The first version of QuickCheck">The first version of
QuickCheck</a></h3>
<ul>
<li>QuickCheck as defined in the appendix of the original <a
href="https://dl.acm.org/doi/10.1145/351240.351266">paper</a> (ICFP,
2000)</li>
</ul>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="ot">=</span> <span class="dt">Gen</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> a)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">generate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>generate n rnd (<span class="dt">Gen</span> m) <span class="ot">=</span> m size rnd&#39;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  (size, rnd&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, n) rnd</span></code></pre></div>
<p>Footnote: We’ll not talk about the coarbitrary, which is used to
generate functions.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rand ::</span> <span class="dt">Gen</span> <span class="dt">StdGen</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>rand <span class="ot">=</span> <span class="dt">Gen</span> (\_n r <span class="ot">-&gt;</span> r)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sized ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>sized fgen <span class="ot">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">Gen</span> m <span class="ot">=</span> fgen n <span class="kw">in</span> m n r)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> elements [<span class="dt">True</span>, <span class="dt">False</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Avoids generating control characters.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> choose (<span class="dv">32</span>,<span class="dv">126</span>) <span class="op">&gt;&gt;=</span> \n <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="fu">chr</span> n)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> sized <span class="op">$</span> \n <span class="ot">-&gt;</span> choose (<span class="op">-</span>n,n)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> sized (\n <span class="ot">-&gt;</span> choose (<span class="dv">0</span>,n) <span class="op">&gt;&gt;=</span> vector)</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Property</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Prop</span> (<span class="dt">Gen</span> <span class="dt">Result</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">result ::</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>result res <span class="ot">=</span> <span class="dt">Prop</span> (<span class="fu">return</span> res)</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Result</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Result</span> {<span class="ot"> ok ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>,<span class="ot"> stamp ::</span> [<span class="dt">String</span>],<span class="ot"> arguments ::</span> [<span class="dt">String</span>] }</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">nothing ::</span> <span class="dt">Result</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>nothing <span class="ot">=</span> <span class="dt">Result</span>{ ok <span class="ot">=</span> <span class="dt">Nothing</span>, stamp <span class="ot">=</span> [], arguments <span class="ot">=</span> [] }</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Testable</span> a <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  property ::</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> () <span class="kw">where</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  property _ <span class="ot">=</span> result nothing</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  property b <span class="ot">=</span> result (nothing{ ok <span class="ot">=</span> <span class="dt">Just</span> b })</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Result</span> <span class="kw">where</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  property res <span class="ot">=</span> result res</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Property</span> <span class="kw">where</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  property prop <span class="ot">=</span> prop</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  property f <span class="ot">=</span> forAll arbitrary f</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forAll ::</span> (<span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>forAll gen body <span class="ot">=</span> <span class="dt">Prop</span> <span class="op">$</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> a   <span class="ot">&lt;-</span> gen</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>     res <span class="ot">&lt;-</span> evaluate (body a)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> (argument a res)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  argument a res <span class="ot">=</span> res{ arguments <span class="ot">=</span> <span class="fu">show</span> a <span class="op">:</span> arguments res }</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evaluate ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>evaluate a <span class="ot">=</span> gen <span class="kw">where</span> <span class="dt">Prop</span> gen <span class="ot">=</span> property a</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">label ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>label s a <span class="ot">=</span> <span class="dt">Prop</span> (add <span class="ot">`fmap`</span> evaluate a)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  add res <span class="ot">=</span> res{ stamp <span class="ot">=</span> s <span class="op">:</span> stamp res }</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">classify ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>classify <span class="dt">True</span>  name <span class="ot">=</span> label name</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>classify <span class="dt">False</span> _    <span class="ot">=</span> property</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> maxTest ::</span> <span class="dt">Int</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> maxFail ::</span> <span class="dt">Int</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> size    ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> every   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">quick ::</span> <span class="dt">Config</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>quick <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  { maxTest <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  , maxFail <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  , size    <span class="ot">=</span> (<span class="op">+</span> <span class="dv">3</span>) <span class="op">.</span> (<span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  , every   <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="fu">show</span> n <span class="kw">in</span> s <span class="op">++</span> [ <span class="ch">&#39;\b&#39;</span> <span class="op">|</span> _ <span class="ot">&lt;-</span> s ]</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="ot">verbose ::</span> <span class="dt">Config</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>verbose <span class="ot">=</span> quick</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  { every <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="fu">show</span> n <span class="op">++</span> <span class="st">&quot;:\n&quot;</span> <span class="op">++</span> <span class="fu">unlines</span> args</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>test, quickCheck,<span class="ot"> verboseCheck ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>test         <span class="ot">=</span> check quick</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>quickCheck   <span class="ot">=</span> check quick</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>verboseCheck <span class="ot">=</span> check verbose</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="ot">check ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>check config a <span class="ot">=</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> rnd <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>     tests config (evaluate a) rnd <span class="dv">0</span> <span class="dv">0</span> []</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="ot">tests ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>tests config gen rnd0 ntest nfail stamps</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ntest <span class="op">==</span> maxTest config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;OK, passed&quot;</span> ntest stamps</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nfail <span class="op">==</span> maxFail config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;Arguments exhausted after&quot;</span> ntest stamps</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> <span class="fu">putStr</span> (every config ntest (arguments result))</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>         <span class="kw">case</span> ok result <span class="kw">of</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Nothing</span>    <span class="ot">-&gt;</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>             tests config gen rnd1 ntest (nfail<span class="op">+</span><span class="dv">1</span>) stamps</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>             tests config gen rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail (stamp result<span class="op">:</span>stamps)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>             <span class="fu">putStr</span> ( <span class="st">&quot;Falsifiable, after &quot;</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">show</span> ntest</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="st">&quot; tests:\n&quot;</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">unlines</span> (arguments result)</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>     <span class="kw">where</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>      result      <span class="ot">=</span> generate (size config ntest) rnd2 gen</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>      (rnd1,rnd2) <span class="ot">=</span> split rnd0</span></code></pre></div>
</section>
<section id="the-extension-to-add-coverage-guidance" class="level3">
<h3><a href="#the-extension-to-add-coverage-guidance"
title="The extension to add coverage-guidance">The extension to add
coverage-guidance</a></h3>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">coverCheck ::</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>)  <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>coverCheck config prop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  rnd <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  testsC config arbitrary prop [] <span class="dv">0</span> rnd <span class="dv">0</span> <span class="dv">0</span> []</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testsC ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>testsC config gen prop xs cov rnd0 ntest nfail stamps</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ntest <span class="op">==</span> maxTest config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;OK, passed&quot;</span> ntest stamps</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nfail <span class="op">==</span> maxFail config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;Arguments exhausted after&quot;</span> ntest stamps</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> <span class="fu">putStr</span> (every config ntest (arguments result))</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>         <span class="kw">case</span> ok result <span class="kw">of</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Nothing</span>    <span class="ot">-&gt;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>             testsC config gen prop xs cov rnd1 ntest (nfail<span class="op">+</span><span class="dv">1</span>) stamps</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> stamps&#39; <span class="ot">=</span> stamp result <span class="op">:</span> stamps</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>                 cov&#39;    <span class="ot">=</span> <span class="fu">length</span> (nub (<span class="fu">concat</span> stamps&#39;))</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> cov&#39; <span class="op">&gt;</span> cov</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>             <span class="kw">then</span> testsC config gen prop xs&#39; cov&#39; rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail stamps&#39;</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>             <span class="kw">else</span> testsC config gen prop xs  cov  rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail stamps&#39;</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>             <span class="fu">putStrLn</span> ( <span class="st">&quot;Falsifiable, after &quot;</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">show</span> ntest</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="st">&quot; tests:\n&quot;</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">head</span> (arguments result)</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>     <span class="kw">where</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>       x              <span class="ot">=</span> generate (size config ntest) rnd3 gen</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>       xs&#39;            <span class="ot">=</span> xs <span class="op">++</span> [x]</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>       <span class="dt">Prop</span> genResult <span class="ot">=</span> prop xs&#39;</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>       result_        <span class="ot">=</span> generate (size config ntest) rnd4 genResult</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>       result         <span class="ot">=</span> result_ {arguments <span class="ot">=</span> <span class="fu">show</span> xs&#39; <span class="op">:</span> arguments result_ }</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>       (rnd1,rnd2)    <span class="ot">=</span> split rnd0</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>       (rnd3,rnd4)    <span class="ot">=</span> split rnd2</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testsC&#39; ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>) <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>testsC&#39; config gen prop <span class="ot">=</span> tests config genResult</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Prop</span> genResult <span class="ot">=</span> forAll (genList gen) prop</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    genList gen <span class="ot">=</span> sized <span class="op">$</span> \len <span class="ot">-&gt;</span> replicateM len gen</span></code></pre></div>
<p>The full source code is available <a
href="https://github.com/stevana/coverage-guided-pbt">here</a>.</p>
</section>
</section>
<section id="example-test-run-using-the-prototype" class="level2">
<h2><a href="#example-test-run-using-the-prototype"
title="Example test run using the prototype">Example test run using the
prototype</a></h2>
<p>We now have all the pieces to test the example from the <a
href="#motivation">motivation</a> section:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>bad s <span class="ot">=</span> coverage <span class="dv">0</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">1</span> <span class="ch">&#39;a&#39;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">2</span> <span class="ch">&#39;d&#39;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">3</span> <span class="ch">&#39;!&#39;</span> <span class="op">$</span> <span class="kw">if</span> s <span class="op">==</span> <span class="st">&quot;bad!&quot;</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    coverage ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    coverage i ch <span class="ot">=</span> classify (s <span class="op">!?</span> i <span class="op">==</span> <span class="dt">Just</span> ch) [ch]</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    (!?) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">!?</span> i <span class="op">|</span> i <span class="op">&lt;</span> <span class="fu">length</span> xs <span class="ot">=</span> <span class="dt">Just</span> (xs <span class="op">!!</span> i)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This property basically says that there’s no string that’s equal to
<code>"bad!"</code>, which is obviously false. If we try to test this
property using the unmodified first version of QuickCheck:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testBad ::</span> <span class="dt">IO</span> ()</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>testBad <span class="ot">=</span> check config bad</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    config <span class="ot">=</span> quick { maxTest <span class="ot">=</span> (<span class="dv">2</span><span class="op">^</span><span class="dv">8</span>)<span class="op">^</span><span class="dv">4</span> }</span></code></pre></div>
<p>We’ll see spin away, but not actually find the bad string:</p>
<pre><code>&gt;&gt;&gt; testBad
32301
^CInterrupted.</code></pre>
<p>I stopped it after about 32k tries, in theory we’d need more than 4
billion attempts to find the bad string using this approach.</p>
<p>Whereas if we use coverage-guided generation:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testBad&#39; ::</span> <span class="dt">IO</span> ()</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>testBad&#39; <span class="ot">=</span> coverCheck config bad</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    config <span class="ot">=</span> verbose</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      { maxTest <span class="ot">=</span> (<span class="dv">2</span><span class="op">^</span><span class="dv">8</span>)<span class="op">*</span><span class="dv">4</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>      , every <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="fu">show</span> n <span class="op">++</span> <span class="st">&quot;: &quot;</span> <span class="op">++</span> <span class="fu">unlines</span> args</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>      }</span></code></pre></div>
<p>We find the bad string pretty quickly. I’m using verbose output here
so you can see how it first find the <code>"b"</code>, then
<code>"ba"</code>, etc:</p>
<pre><code>&gt;&gt;&gt; testBad&#39;
0: &quot;n&quot;
1: &quot;T&quot;
2: &quot;L&quot;
3: &quot;|&quot;
4: &quot;X&quot;
5: &quot;\&quot;&quot;
6: &quot;e&quot;
7: &quot;G&quot;
8: &quot;R&quot;
9: &quot;}&quot;
10: &quot;C&quot;
11: &quot;3&quot;
12: &quot;&gt;&quot;
13: &quot;C&quot;
14: &quot;J&quot;
15: &quot;9&quot;
16: &quot;=&quot;
17: &quot;9&quot;
18: &quot;L&quot;
19: &quot;)&quot;
20: &quot;5&quot;
21: &quot;6&quot;
22: &quot;x&quot;
23: &quot;#&quot;
24: &quot;T&quot;
25: &quot;T&quot;
26: &quot;_&quot;
27: &quot;@&quot;
28: &quot;}&quot;
29: &quot;y&quot;
30: &quot;-&quot;
31: &quot;s&quot;
32: &quot;b&quot;
33: &quot;bx&quot;
34: &quot;b9&quot;
35: &quot;bf&quot;
36: &quot;bl&quot;
37: &quot;ba&quot;
38: &quot;baC&quot;
39: &quot;baX&quot;
40: &quot;baA&quot;
41: &quot;baE&quot;
42: &quot;bay&quot;
43: &quot;baX&quot;
44: &quot;ba6&quot;
45: &quot;ba@&quot;
46: &quot;bai&quot;
47: &quot;ba}&quot;
48: &quot;bay&quot;
49: &quot;bac&quot;
50: &quot;bak&quot;
51: &quot;ba`&quot;
52: &quot;bad&quot;
53: &quot;bad8&quot;
54: &quot;bade&quot;
55: &quot;bad0&quot;
56: &quot;badA&quot;
57: &quot;badP&quot;
58: &quot;badQ&quot;
59: &quot;bad0&quot;
60: &quot;bade&quot;
61: &quot;bad)&quot;
62: &quot;bado&quot;
63: &quot;badE&quot;
64: &quot;bad\&quot;&quot;
65: &quot;bad@&quot;
66: &quot;bad{&quot;
67: &quot;badX&quot;
68: &quot;bado&quot;
69: &quot;badb&quot;
70: &quot;bad~&quot;
71: &quot;bada&quot;
72: &quot;bad%&quot;
73: &quot;bad9&quot;
74: &quot;badE&quot;
75: &quot;bad8&quot;
76: &quot;bad{&quot;
77: &quot;badS&quot;
78: &quot;badn&quot;
79: &quot;bad?&quot;
80: &quot;badn&quot;
81: &quot;badq&quot;
82: &quot;bady&quot;
83: &quot;badA&quot;
84: &quot;bad4&quot;
85: &quot;bad;&quot;
86: &quot;bad9&quot;
87: &quot;badU&quot;
88: &quot;bad!&quot;
Falsifiable, after 88 tests:
&quot;bad!&quot;</code></pre>
</section>
<section id="conclusion-and-further-work" class="level2">
<h2><a href="#conclusion-and-further-work"
title="Conclusion and further work">Conclusion and further work</a></h2>
<ul>
<li><p>Exponential -&gt; polynomial</p></li>
<li><p>Makes more sense for stateful systems than pure functions? Or
atleast properties that expect a sequence of inputs?</p></li>
<li><p>Don’t rerun all commands for every newly generate command</p>
<ul>
<li>only reset the system when shrinking</li>
</ul></li>
<li><p>Problem of strategy (pick something as basis for progress):
coverage, logs, value of memory, helps bootstap the process. Generalise
to support more?</p></li>
<li><p>Local maxima?</p></li>
<li><p>Problem of tactics: picking a good input distributed for the
testing problem at hand. Make previous input influence the next input?
Dependent events, e.g. if one packet gets lost, there’s a higher chance
that the next packet will be lost as well.</p></li>
<li><p>Save <code>(Coverage, Mutation, Frequency, Coverage)</code>
stats?</p></li>
<li><p>More realistic example, e.g.: leader election, transaction
rollback, failover?</p></li>
<li><p>Annoying to sprinkle sometimes assertions everywhere?</p>
<ul>
<li>Can it be combined with logging or tracing?</li>
</ul></li>
<li><p>Use size parameter to implement AFL heuristic for choosing
integers? Or just use <code>frequency</code>?</p></li>
<li><p>Type-generic mutation?</p></li>
<li><p>sometimes_each?</p></li>
</ul>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li><a
href="https://carstein.github.io/fuzzing/2020/04/18/writing-simple-fuzzer-1.html"
class="uri">https://carstein.github.io/fuzzing/2020/04/18/writing-simple-fuzzer-1.html</a></li>
<li><a
href="https://carstein.github.io/fuzzing/2020/04/25/writing-simple-fuzzer-2.html"
class="uri">https://carstein.github.io/fuzzing/2020/04/25/writing-simple-fuzzer-2.html</a></li>
<li><a
href="https://carstein.github.io/fuzzing/2020/05/02/writing-simple-fuzzer-3.html"
class="uri">https://carstein.github.io/fuzzing/2020/05/02/writing-simple-fuzzer-3.html</a></li>
<li><a
href="https://carstein.github.io/fuzzing/2020/05/21/writing-simple-fuzzer-4.html"
class="uri">https://carstein.github.io/fuzzing/2020/05/21/writing-simple-fuzzer-4.html</a></li>
<li><a href="https://antithesis.com/blog/sdtalk/">How Antithesis finds
bugs (with help from the Super Mario Bros)</a></li>
</ul>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This example is due to Dmitry Vyukov, the main author of
<a href="https://github.com/dvyukov/go-fuzz">go-fuzz</a>, but it’s
basically an easier to understand version of the example from Dan Luu’s
post. For comparison, here’s Dan’s example in full:</p>
<pre><code>// Checks that a number has its bottom bits set
func some_filter(x int) bool {
    for i := 0; i &lt; 16; i = i + 1 {
        if !(x&amp;1 == 1) {
            return false
        }
        x &gt;&gt;= 1
    }
    return true
}

// Takes an array and returns a non-zero int
func dut(a []int) int {
    if len(a) != 4 {
        return 1
    }

    if some_filter(a[0]) {
        if some_filter(a[1]) {
            if some_filter(a[2]) {
                if some_filter(a[3]) {
                    return 0 // A bug! We failed to return non-zero!
                }
                return 2
            }
            return 3
        }
        return 4
    }
    return 5
}</code></pre>
<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn2"><p>See the appendix of the original <a
href="https://dl.acm.org/doi/10.1145/351240.351266">paper</a> that first
introduced property-based testing. It’s interesting to note that the
collecting statistics functionality is older than shrinking.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
