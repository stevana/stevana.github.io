<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>Coverage-guided property-based testing</title>
  <link rel="stylesheet" href="style.css?modified=2024-09-25" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/coverage-guided_property-based_testing.html&t=Coverage-guided property-based testing">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About / <span class="work-with-me">Work with me</span></a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>Coverage-guided property-based testing</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#background-and-prior-work"
id="toc-background-and-prior-work">Background and prior work</a>
<ul>
<li><a href="#before-2015" id="toc-before-2015">Before 2015</a></li>
<li><a href="#after-2015" id="toc-after-2015">After 2015</a></li>
</ul></li>
<li><a href="#prototype-implementation"
id="toc-prototype-implementation">Prototype implementation</a>
<ul>
<li><a href="#getting-the-coverage-information"
id="toc-getting-the-coverage-information">Getting the coverage
information</a></li>
<li><a href="#the-first-version-of-quickcheck"
id="toc-the-first-version-of-quickcheck">The first version of
QuickCheck</a>
<ul>
<li><a href="#generating-input-data"
id="toc-generating-input-data">Generating input data</a></li>
<li><a href="#specifying-properties"
id="toc-specifying-properties">Specifying properties</a></li>
<li><a href="#collecting-statistics"
id="toc-collecting-statistics">Collecting statistics</a></li>
<li><a href="#running-the-tests" id="toc-running-the-tests">Running the
tests</a></li>
</ul></li>
<li><a href="#the-extension-to-add-coverage-guidance"
id="toc-the-extension-to-add-coverage-guidance">The extension to add
coverage-guidance</a></li>
</ul></li>
<li><a href="#example-test-runs-using-the-prototype"
id="toc-example-test-runs-using-the-prototype">Example test runs using
the prototype</a>
<ul>
<li><a href="#traditional-use-of-coverage"
id="toc-traditional-use-of-coverage">Traditional use of
coverage</a></li>
<li><a href="#using-coverage-to-guide-generation"
id="toc-using-coverage-to-guide-generation">Using coverage to guide
generation</a></li>
</ul></li>
<li><a href="#conclusion-and-further-work"
id="toc-conclusion-and-further-work">Conclusion and further
work</a></li>
</ul>
</nav>
<div class="date">Posted on Sep 25, 2024</div>
<p><em>Work in progress, please don’t share, but do feel free to get
involved!</em></p>
<p>Almost ten years ago, back in 2015, Dan Luu wrote a <a
href="https://danluu.com/testing/">post</a> asking why coverage-guided
property-based testing wasn’t a thing.</p>
<p>In this post I’ll survey the coverage-guided landscape, looking at
what was there before Dan’s post and what has happened since. I’ll also
show how to add basic coverage-guidance to the first version of the
original property-based testing tool, QuickCheck, in about 35 lines of
code.</p>
<p>Unlike many previous implementations of this idea, the technique used
to implement coverage-guidance is programming language agnostic and
doesn’t rely on any language-specific instrumentation of the software
under test.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>Before we start, let me try to motivate why one would want to combine
coverage-guided fuzzing and property-based testing to begin with.</p>
<p>Consider the following example<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>, where an error is
triggered if some input byte array starts with the bytes
<code>"bad!"</code>:</p>
<pre><code>func sut(input []byte) {
    if input[0] == &#39;b&#39; {
        if input[1] == &#39;a&#39; {
            if input[2] == &#39;d&#39; {
                if input[3] == &#39;!&#39; {
                    panic(&quot;input must not be bad!&quot;)
                }
            }
        }
    }
}</code></pre>
<p>What are the odds that a property-based testing tool (without
coverage-guidance) would be able to find the error?</p>
<p>To make the calculation easier, let’s say that we always generate
arrays of length <span class="math inline">\(4\)</span>. A byte consists
of eight bits, so it has <span class="math inline">\(2^8\)</span>
possible values. That means that the probability is <span
class="math inline">\(\frac{1}{2^8} \cdot \frac{1}{2^8} \cdot
\frac{1}{2^8} \cdot \frac{1}{2^8}) = \frac{1}{2^8}^4 =
\frac{1}{2^{32}}\)</span> which is approximately <span
class="math inline">\(1\)</span> in <span
class="math inline">\(4\)</span> billion. In a realistic test suite, we
wouldn’t restrict the length of the array to be <span
class="math inline">\(4\)</span>, and hence the probability will be even
worse.</p>
<p>With coverage-guidance we keep track of inputs that resulted in
increased coverage. So, for example, if we generate the array
<code>[]byte{'b'}</code> we get further into the nested ifs, and so we
take note of that and start generating longer arrays that start with
<code>'b'</code> and see if we get even further, etc. By building on
previous successes in getting more coverage, we can effectively reduce
the problem to only need <span class="math inline">\(\frac{1}{2^8} +
\frac{1}{2^8} + \frac{1}{2^8} + \frac{2^8} = \frac{1}{2^8} \cdot 4 =
\fraq{1}{2^{10}} = \frac{1}{1024}\)</span>.</p>
<p>In other words coverage-guidance turns an exponential problem into a
polynomial problem!</p>
</section>
<section id="background-and-prior-work" class="level2">
<h2><a href="#background-and-prior-work"
title="Background and prior work">Background and prior work</a></h2>
<p>There’s a lot to cover here, so I’ll split it up in before and after
Dan’s post.</p>
<section id="before-2015" class="level3">
<h3><a href="#before-2015" title="Before 2015">Before 2015</a></h3>
<p>Fuzzing has an interesting origin. It started as a class <a
href="http://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf">project</a>
in an advanced operating systems course taught by Barton Miller at the
University of Wisconsin in 1988.</p>
<p>The project was inspired by the observation that back then, if you
logged into your workstation via a dail-up modem from home and it
rained, then frequently random characters would appear in the terminal.
The line noise wasn’t the surprising thing, but rather that the extra
characters would sometimes crash the program that they tried to invoke.
Among these programs were basic utilities such as <code>vi</code>,
<code>mail</code>, <code>cc</code>, <code>make</code>, <code>sed</code>,
<code>awk</code>, <code>sort</code>, etc, and it was reasonable to
expect that these would give an error message rather than crash and core
dump if fed with some extra characters caused by the rain.</p>
<p>So the project set out to basically recreate what the rain did, but
more effectively, but essentially generating random noise (stream of
bytes) and feeding that to different utilities and see if they crashed.
A couple of years later Barton et al published <a
href="https://dl.acm.org/doi/10.1145/96267.96279"><em>An empirical study
of the reliability of UNIX utilities</em></a> (1990) which documents
their findings.</p>
<p>Inserting random characters was effective in finding corner cases
where the programmers forgot to properly validate the input from the
user. However it wouldn’t trigger bugs hiding deeper under the surface,
such as the <code>"bad!"</code> example from the previous section.</p>
<p>This changed around 2007 when people <a
href="https://lcamtuf.coredump.cx/afl/historical_notes.txt">started
thinking</a> about how fuzzing can be combined with <a
href="https://en.wikipedia.org/wiki/Evolutionary_algorithm">evolutionary
algorithms</a>. The idea being that instead of generating random bytes
all the time as with classical fuzzing, we can use coverage information
from one test to mutate the input for the next test. Or to use the
evolution metaphor: seeds that lead to better coverage are mutated with
the hope that they will lead to even better coverage.</p>
<p>One of the first, and perhaps still most widely known, such
<em>coverage-guided</em> fuzzers is Michał Zalewski’s <a
href="https://lcamtuf.coredump.cx/afl/">AFL</a> (2013). To get a feel
for how effective AFL-style coverage-guidance is, check out the list of
<a href="https://lcamtuf.coredump.cx/afl/#bugs">bugs</a> that it found
and this post about how it manages to figure out the <a
href="https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html">jpeg
format</a> on its own<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<p>Since AFL is the tool that Dan explicitly mentions in his post, let’s
stop at this point and go back to his point, before looking at what
happened since with coverage-guided fuzzers.</p>
<p>Recall that Dan was asking why this idea of coverage-guidance wasn’t
present in property-based testing tools. I’ve written about the <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html#the-history-of-property-based-testing">history</a>
of property-based testing and explained how it <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html#pure-property-based-testing-recap">works</a>
already, so I won’t take up space by repeating myself here. Let’s just
note that the <a
href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">original
paper</a> on property-based testing was published in 2000. So when Dan
wrote asking about this question property-based testing would have been
fifteen and AFL two years old.</p>
<p>The main difference between property-based testing and fuzzing is
that fuzzing requires less work by the user. Simply hook up the byte
generator to the function that expects bytes as input and off it goes
looking for crashes. Property-based testing on the other hand can test
functions that take arbitrary data structures as input (not just bytes),
but you have to describe how to generate such inputs.</p>
<p>Fuzzing only looks for crashes, while property-based testing lets you
specify arbitrary relations that should hold between the input and
output of the system under test. For example, we can generate binary
search trees and check that after we insert something into an arbitrary
binary search tree then it will remain sorted (when we do an inorder
traversal). Fuzzing can’t check such properties, and furthermore because
they generate random bytes it’s unlikely that they’ll even generate a
valid binary search tree to begin with (without lots of coverage-driven
testing).</p>
<p>On the other hand, the coverage of property-based tests is only as
good as the user provided generators. Corner cases where slightly
modified data leads to e.g. exception handling is not explored
automatically, and coverage information is not used to guide the input
generation process.</p>
<p>By now we should have enough background to see that the idea of
combining coverage-guidance and property-based testing makes sense.
Basically what we’d like is to:</p>
<ol type="1">
<li>Use user provided generators to kick start the exploration in the
right direction;</li>
<li>Mutate the generated data, while preserving its type, to surface
bugs that user provided generators alone wouldn’t have found;</li>
<li>Use coverage information to iteratively get deeper into the state
space of the system under test, like in the “bad!” example from the
motivation.</li>
</ol>
</section>
<section id="after-2015" class="level3">
<h3><a href="#after-2015" title="After 2015">After 2015</a></h3>
<p>Having covered what had happened before Dan’s post, let’s have a look
at what has happened in the ten years since his post.</p>
<p>First off, it’s worth noting that at some point he added an update to
his post:</p>
<blockquote>
<p>“Update: Dmitry Vyukov’s Go-fuzz, which looks like it was started a
month after this post was written, uses the approach from the proof of
concept in this post of combining the sort of logic seen in AFL with a
QuickCheck-like framework, and has been shown to be quite effective. I
believe David R. MacIver is also planning to use this approach in the
next version of hypothesis.”</p>
</blockquote>
<p>So let’s start there, with Go-fuzz. At a first glance, all functions
that are tested with Go-fuzz need to take an array of bytes as input. My
initial thought was, how can I write properties which involve generating
more interesting data structures? But it turns out it’s <a
href="https://news.ycombinator.com/item?id=40876822">possible</a>, as
somebody pointed out in the comments of an old post of mine. Furthermore
there are also <a
href="https://adalogics.com/blog/structure-aware-go-fuzzing-complex-types">ways</a>
of making the fuzzer aware of more complex data structures. I haven’t
played around enough with this to be able to compare how well shrinking
works yet though, but overall I’d say this ticks the box of being a
property-based testing tool that is also coverage-guided.</p>
<p>Next up Dan mentions Python’s Hypothesis. I was searching through the
documentation trying to find out how coverage-guidance works, but I
couldn’t find anything. Searching through the repository I found the
following <a
href="https://github.com/HypothesisWorks/hypothesis/pull/1564/commits/dcbea9148be3446392bc3af8892d49f3cc74fbe3">release
note</a> (2018):</p>
<blockquote>
<p>“This release deprecates the coverage-guided testing functionality,
as it has proven brittle and does not really pull its weight.</p>
<p>We intend to replace it with something more useful in the future, but
the feature in its current form does not seem to be worth the cost of
using, and whatever replaces it will likely look very different.”</p>
</blockquote>
<p>As far as I can tell, it hasn’t been reintroduced since.</p>
<p>However it’s possible to hook Hypothesis up to <a
href="https://hypothesis.readthedocs.io/en/latest/details.html#use-with-external-fuzzers">use
external fuzzers</a>. Hypothesis already uses random bytes as basis for
its generators, unlike QuickCheck which uses an integer seed, so I
suppose that the external fuzzers essentially fuzz the random input
bytes that in turn are used to generate more structured input.</p>
<p>Traditional fuzzers are usually designed to target a single binary,
where as the test suite which uses property-based testing typically has
many properties. The <a
href="https://hypofuzz.com/docs/features.html#fuzzer-details">HypoFuzz</a>
tool works around this mismatch by scheduling fuzzing time among the
many Hypothesis properties in your test suite.</p>
<p>What else has happenend since Dan’s post?</p>
<p>One of the first things I noticed is that AFL is no longer <a
href="https://lcamtuf.coredump.cx/afl/">maintained</a>:</p>
<blockquote>
<p>“Note: AFL hasn’t been updated for a couple of years; while it should
still work fine, a more complex fork with a variety of improvements and
additional features, known as AFL++, is available from other members of
the community and is worth checking out.”</p>
</blockquote>
<p>Whereas AFL is based on a single idea of how the fuzzer does its
exploration with very few knobs, <a
href="https://www.usenix.org/system/files/woot20-paper-fioraldi.pdf">AFL++</a>
(2020) keeps the basic AFL evolutionary algorithm structure, but
incorporates a lot of new research on other ways to explore the state
space.</p>
<p>For example, which seed gets scheduled and how many times it gets
mutated per round are <a
href="https://mboehme.github.io/paper/CCS16.pdf">two new parameters</a>
that can be tweaked to achieve different paths of exploration throughout
the system under test.</p>
<p>The next thing I did was to search for “coverage-guided
property-based testing” in the academic literature.</p>
<p>One of the first papers I found was <a
href="https://dl.acm.org/doi/10.1145/3360607"><em>Coverage guided,
property based testing</em></a> by Leonidas Lampropoulos, Michael Hicks,
Benjamin C. Pierce (2019).</p>
<p>In this paper FuzzChick, Coq/Rocq library, that adds AFL-style
coverage instrumentation to QuickChick (a Rocq QuickCheck clone) is
presented.</p>
<p>Unfortunately the only source code I could find lives in an <a
href="https://github.com/QuickChick/QuickChick/compare/master...FuzzChick">unmaintained
branch</a> that <a
href="https://github.com/QuickChick/QuickChick/issues/277">doesn’t
compile</a>.</p>
<p>The related works section of the paper has a couple of interesting
references though.</p>
<p>The main inspiration fro FuzzChick seems to have been Stephen Dolan
et al’s OCaml library called <a
href="https://github.com/ocaml/ocaml.org-media/blob/086fc25105cbccb188c28ec74126d72962921ff8/meetings/ocaml/2017/extended-abstract__2017__stephen-dolan_mindy-preston__testing-with-crowbar.pdf">Crowbar</a>
(2017).</p>
<p>Crowbar uses a stream of bytes to drive its generators, similar to
Hypothesis, and it’s this stream that AFL is hooked up to.</p>
<p>This indirection is Crowbar’s (and by extension, I guess, also
HypoFuzz’s) biggest weakness.</p>
<p>AFL is good at manipulating this byte stream, but because the bytes
are not used directly to test the system under test, but rather to
generate data which in turn is used for testing, some of its
effectiveness is lost. This becomes particularly obvious when data
structures with sparse pre-conditions, e.g. sorted list or a binary
search tree.</p>
<p>That’s what the authors of FuzzChick say at least, while claiming
that they addressed this weakness by doing type-aware mutations.</p>
<p>The other libraries that the paper mentions are from the imperative
language community.</p>
<p>For example <a href="https://github.com/rohanpadhye/jqf"><em>JQF +
Zest: Coverage-guided semantic fuzzing for Java</em></a>, <a
href="https://llvm.org/docs/LibFuzzer.html">libfuzzer</a> and it’s
successor <a href="https://github.com/google/fuzztest">FuzzTest</a>
(2022?) for C++.</p>
<p>Rust’s <code>cargo fuzz</code> seems to build upon libfuzzer, see the
chaper on <a
href="https://rust-fuzz.github.io/book/cargo-fuzz/structure-aware-fuzzing.html"><em>Structure-aware
fuzzing using libfuzzer-sys in Rust</em></a> in the Rust Fuzz Book.</p>
<p>The FuzzTest README claims “It is a first-of-its-kind tool that
bridges the gap between fuzzing and property-based testing”. I can’t
tell why they would claim that, given that it appears to have been
released in 2022 and many of the tools we looked at above seem to have
successfully combined the two approaches before that. For example, how
is it different from Go-fuzz?</p>
<p>In my search I also found the paper <a
href="https://www.mista.me/assets/pdf/icst23-preprint.pdf"><em>MUTAGEN:
Reliable Coverage-Guided, Property-Based Testing using Exhaustive
Mutations</em></a> by Agustín Mista and Alejandro Russo (2023).</p>
<p>This paper seems to build upon the FuzzChick paper, however it swaps
out the AFL-style coverage instrumentation for the use of a GHC <a
href="https://github.com/OctopiChalmers/mutagen/blob/main/src/Test/Mutagen/Tracer/Plugin.hs">plugin</a>
to annotate source code with coverage information of: function clauses,
case statements, multi-way ifs, and each branch of if-then-else
expressions.</p>
<p>Imperative languages such as Go, Python, C++, Rust, and Java seem
ahead of functional languages when it comes to combining coverage-guided
fuzzing and property-based testing.</p>
<p>Let’s try to change that by implementing a small functional
programming version, based on the original property-based testing
implementation.</p>
</section>
</section>
<section id="prototype-implementation" class="level2">
<h2><a href="#prototype-implementation"
title="Prototype implementation">Prototype implementation</a></h2>
<section id="getting-the-coverage-information" class="level3">
<h3><a href="#getting-the-coverage-information"
title="Getting the coverage information">Getting the coverage
information</a></h3>
<p>One key question we need to answer in order to be able to implement
anything that’s coverage-guided is: where do we get the coverage
information from?</p>
<p>When I’ve been thinking about how to implement coverage-guided
property-based testing in the past, I always got stuck thinking that
parsing the coverage output from the compiler in between test case
generation rounds would be annoying and slow.</p>
<p>I thought that in the best case scenario the compiler might provide a
library which exposes the coverage information<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<p>It wasn’t until I started researching this post that I realised that
AFL, and most coverage-guided fuzzers since, actually inject custom
coverage capturing code into compiled programs at every branch point or
<a href="https://en.wikipedia.org/wiki/Basic_block">basic block</a>.
It’s explained in more detail in the <a
href="https://lcamtuf.coredump.cx/afl/technical_details.txt">whitepaper</a>.</p>
<p>The main reason they do it is because of performance, not because
it’s necessarily easier, in fact I still don’t understand exactly how it
works.</p>
<p>It wasn’t until I read about Antithesis’ <a
href="https://antithesis.com/docs/best_practices/sometimes_assertions.html">“sometime
assertions”</a> that I started seeing a simple solution to the
problem.</p>
<p>These “sometimes assertions” can be thought of as generalised
coverage, in that if we would annotate every single line, expression or
branch with a sometime assertion we’d get back line-, expression-, or
branch-based coverage.</p>
<p>But the cool thing about “sometimes assertions” is that we don’t need
to annotate every single line, expression or branch, we can annotate
<em>interesting</em> points in our program.</p>
<p>The final piece of the puzzle, and I think this is the only original
idea that this post adds<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>, is that property-based testing
already has functionality for implementing “sometimes assertions”: the
<code>label</code>, <code>classify</code> and <code>collect</code>
machinary for gathering run-time statistics of the generated data!</p>
<p>This machinary is <a
href="https://www.youtube.com/watch?v=NcJOiQlzlXQ">crucial</a> for
writing good tests and has been part of the QuickCheck implementation
since the very first version<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a>!</p>
<p>So the question is: can we implement coverage-guided property-based
testing using the internal notion of coverage that property-based
testing already has?</p>
</section>
<section id="the-first-version-of-quickcheck" class="level3">
<h3><a href="#the-first-version-of-quickcheck"
title="The first version of QuickCheck">The first version of
QuickCheck</a></h3>
<p>For the sake of self-containment, let’s reproduce the the essential
parts of QuickCheck as defined in the appendix of the original <a
href="https://dl.acm.org/doi/10.1145/351240.351266">paper</a> (ICFP,
2000).</p>
<section id="generating-input-data" class="level4">
<h4><a href="#generating-input-data"
title="Generating input data">Generating input data</a></h4>
<p>Let’s start with the generator<a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="ot">=</span> <span class="dt">Gen</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> a)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">generate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>generate n rnd (<span class="dt">Gen</span> m) <span class="ot">=</span> m size rnd&#39;</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  (size, rnd&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, n) rnd</span></code></pre></div>
<p>So a <code>Gen a</code> is basically a function from a size and a
pseudo-random number generator into <code>a</code>. The pseudo-random
number generator and size can be accessed using the following two
functions:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rand ::</span> <span class="dt">Gen</span> <span class="dt">StdGen</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>rand <span class="ot">=</span> <span class="dt">Gen</span> (\_n r <span class="ot">-&gt;</span> r)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">sized ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>sized fgen <span class="ot">=</span> <span class="dt">Gen</span> (\n r <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">Gen</span> m <span class="ot">=</span> fgen n <span class="kw">in</span> m n r)</span></code></pre></div>
<p>Using these together with the <code>Functor</code>,
<code>Applicative</code> and <code>Monad</code> instances of
<code>Gen</code> we can derive other useful combinators for generating
data:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">choose ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>choose bounds <span class="ot">=</span> (<span class="fu">fst</span> <span class="op">.</span> randomR bounds) <span class="ot">`fmap`</span> rand</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">elements ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>elements xs <span class="ot">=</span> (xs <span class="op">!!</span>) <span class="ot">`fmap`</span> choose (<span class="dv">0</span>, <span class="fu">length</span> xs <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">vector ::</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> [a]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>vector n <span class="ot">=</span> <span class="fu">sequence</span> [ arbitrary <span class="op">|</span> _i <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>n] ]</span></code></pre></div>
<p>Instead of defining generators directly for different datatypes,
QuickCheck first wraps generators in a type class called
<code>Arbitrary</code><a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> elements [<span class="dt">True</span>, <span class="dt">False</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Avoids generating control characters.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> choose (<span class="dv">32</span>,<span class="dv">126</span>) <span class="op">&gt;&gt;=</span> \n <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="fu">chr</span> n)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> sized <span class="op">$</span> \n <span class="ot">-&gt;</span> choose (<span class="op">-</span>n,n)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> [a] <span class="kw">where</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> sized (\n <span class="ot">-&gt;</span> choose (<span class="dv">0</span>,n) <span class="op">&gt;&gt;=</span> vector)</span></code></pre></div>
</section>
<section id="specifying-properties" class="level4">
<h4><a href="#specifying-properties"
title="Specifying properties">Specifying properties</a></h4>
<p>Next up, let’s look at how properties are expressed. The
<code>Property</code> type is a wrapper around
<code>Gen Result</code>:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Property</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Prop</span> (<span class="dt">Gen</span> <span class="dt">Result</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">result ::</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>result res <span class="ot">=</span> <span class="dt">Prop</span> (<span class="fu">return</span> res)</span></code></pre></div>
<p>Where <code>Result</code> is defined as follows:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Result</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Result</span> {<span class="ot"> ok ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>,<span class="ot"> stamp ::</span> [<span class="dt">String</span>],<span class="ot"> arguments ::</span> [<span class="dt">String</span>] }</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">nothing ::</span> <span class="dt">Result</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>nothing <span class="ot">=</span> <span class="dt">Result</span>{ ok <span class="ot">=</span> <span class="dt">Nothing</span>, stamp <span class="ot">=</span> [], arguments <span class="ot">=</span> [] }</span></code></pre></div>
<p>The idea being that <code>ok :: Maybe Bool</code> is
<code>Nothing</code> if the input gets discarded and otherwise the
boolean indicates whether the property passed or not. The
<code>stamp</code> field is used to collect statistics about the
generated test cases, while <code>arguments</code> contains all the
generated inputs (or arguments) to the property.</p>
<p>In order to allow the user to write properties of variying arity
another type class is introduced:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Testable</span> a <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  property ::</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> () <span class="kw">where</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  property _ <span class="ot">=</span> result nothing</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  property b <span class="ot">=</span> result (nothing{ ok <span class="ot">=</span> <span class="dt">Just</span> b })</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Result</span> <span class="kw">where</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  property res <span class="ot">=</span> result res</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Testable</span> <span class="dt">Property</span> <span class="kw">where</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  property prop <span class="ot">=</span> prop</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Testable</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  property f <span class="ot">=</span> forAll arbitrary f</span></code></pre></div>
<p>The key ingredient in the function instance of <code>Testable</code>
is <code>forAll</code>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forAll ::</span> (<span class="dt">Show</span> a, <span class="dt">Testable</span> b) <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>forAll gen body <span class="ot">=</span> <span class="dt">Prop</span> <span class="op">$</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> a   <span class="ot">&lt;-</span> gen</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>     res <span class="ot">&lt;-</span> evaluate (body a)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> (argument a res)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  argument a res <span class="ot">=</span> res{ arguments <span class="ot">=</span> <span class="fu">show</span> a <span class="op">:</span> arguments res }</span></code></pre></div>
<p>Which in turn depends on:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evaluate ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>evaluate a <span class="ot">=</span> gen <span class="kw">where</span> <span class="dt">Prop</span> gen <span class="ot">=</span> property a</span></code></pre></div>
<p>One last construct for writing properties that we need is the ability
to add assumptions or pre-conditions about the input:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(==&gt;) ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span>  <span class="op">==&gt;</span> a <span class="ot">=</span> property a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span> <span class="op">==&gt;</span> a <span class="ot">=</span> property ()</span></code></pre></div>
<p>Notice how if the input doesn’t pass this test, then it will be
discarded.</p>
</section>
<section id="collecting-statistics" class="level4">
<h4><a href="#collecting-statistics"
title="Collecting statistics">Collecting statistics</a></h4>
<p>The way we collect statistics about the generated data is through
these two functions:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">label ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>label s a <span class="ot">=</span> <span class="dt">Prop</span> (add <span class="ot">`fmap`</span> evaluate a)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  add res <span class="ot">=</span> res{ stamp <span class="ot">=</span> s <span class="op">:</span> stamp res }</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">classify ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>classify <span class="dt">True</span>  name <span class="ot">=</span> label name</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>classify <span class="dt">False</span> _    <span class="ot">=</span> property</span></code></pre></div>
</section>
<section id="running-the-tests" class="level4">
<h4><a href="#running-the-tests" title="Running the tests">Running the
tests</a></h4>
<p>Finally we have all the pieces we need to be able to actually run the
tests. The testing can be configured:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> maxTest ::</span> <span class="dt">Int</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> maxFail ::</span> <span class="dt">Int</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> size    ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> every   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="ot">quick ::</span> <span class="dt">Config</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>quick <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  { maxTest <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  , maxFail <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  , size    <span class="ot">=</span> (<span class="op">+</span> <span class="dv">3</span>) <span class="op">.</span> (<span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  , every   <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="fu">show</span> n <span class="kw">in</span> s <span class="op">++</span> [ <span class="ch">&#39;\b&#39;</span> <span class="op">|</span> _ <span class="ot">&lt;-</span> s ]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="ot">verbose ::</span> <span class="dt">Config</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>verbose <span class="ot">=</span> quick</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  { every <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="fu">show</span> n <span class="op">++</span> <span class="st">&quot;:\n&quot;</span> <span class="op">++</span> <span class="fu">unlines</span> args</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Where <code>maxTest</code> is the amount of passing test cases that
will be run, <code>maxFail</code> is the amount of tests that are
allowed to be discarded, <code>size</code> is how the size parameter to
the generator changes between tests, and <code>every</code> is used to
print something (or not) between each test.</p>
<p>The tests themselves can now be run as follows:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>test, quickCheck,<span class="ot"> verboseCheck ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>test         <span class="ot">=</span> check quick</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>quickCheck   <span class="ot">=</span> check quick</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>verboseCheck <span class="ot">=</span> check verbose</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">check ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>check config a <span class="ot">=</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> rnd <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>     tests config (evaluate a) rnd <span class="dv">0</span> <span class="dv">0</span> []</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="ot">tests ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Result</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>tests config gen rnd0 ntest nfail stamps</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ntest <span class="op">==</span> maxTest config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;OK, passed&quot;</span> ntest stamps</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nfail <span class="op">==</span> maxFail config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;Arguments exhausted after&quot;</span> ntest stamps</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> <span class="fu">putStr</span> (every config ntest (arguments result))</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>         <span class="kw">case</span> ok result <span class="kw">of</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Nothing</span>    <span class="ot">-&gt;</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>             tests config gen rnd1 ntest (nfail<span class="op">+</span><span class="dv">1</span>) stamps</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>             tests config gen rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail (stamp result<span class="op">:</span>stamps)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>             <span class="fu">putStr</span> ( <span class="st">&quot;Falsifiable, after &quot;</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">show</span> ntest</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="st">&quot; tests:\n&quot;</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">unlines</span> (arguments result)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>     <span class="kw">where</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>      result      <span class="ot">=</span> generate (size config ntest) rnd2 gen</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>      (rnd1,rnd2) <span class="ot">=</span> split rnd0</span></code></pre></div>
</section>
</section>
<section id="the-extension-to-add-coverage-guidance" class="level3">
<h3><a href="#the-extension-to-add-coverage-guidance"
title="The extension to add coverage-guidance">The extension to add
coverage-guidance</a></h3>
<p>Okey, so the above is the first version of the original
property-based testing tool, QuickCheck. Now let’s add coverage-guidence
to it!</p>
<p>The function that checks a property with coverage-guidance slight
different from <code>quickCheck</code><a href="#fn8"
class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a>:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">coverCheck ::</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>)  <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>coverCheck config prop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  rnd <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  testsC config arbitrary prop [] <span class="dv">0</span> rnd <span class="dv">0</span> <span class="dv">0</span> []</span></code></pre></div>
<p>In particular notice that instead of <code>Testable a</code> we use
an explicit predicate on a list of <code>a</code>,
<code>[a] -&gt; Property</code>. The reason for using a list in the
predicate is so that we can iteratively make progress, using the
coverage information. We see this more clearly if we look at the
coverage-guided analogue of the <code>tests</code> function, in
particular the <code>xs</code> parameter:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testsC ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>testsC config gen prop xs cov rnd0 ntest nfail stamps</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ntest <span class="op">==</span> maxTest config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;OK, passed&quot;</span> ntest stamps</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nfail <span class="op">==</span> maxFail config <span class="ot">=</span> <span class="kw">do</span> done <span class="st">&quot;Arguments exhausted after&quot;</span> ntest stamps</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> <span class="fu">putStr</span> (every config ntest (arguments result))</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>         <span class="kw">case</span> ok result <span class="kw">of</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Nothing</span>    <span class="ot">-&gt;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>             testsC config gen prop xs cov rnd1 ntest (nfail<span class="op">+</span><span class="dv">1</span>) stamps</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> stamps&#39; <span class="ot">=</span> stamp result <span class="op">:</span> stamps</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>                 cov&#39;    <span class="ot">=</span> <span class="fu">length</span> (nub (<span class="fu">concat</span> stamps&#39;))</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>             <span class="kw">if</span> cov&#39; <span class="op">&gt;</span> cov</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>             <span class="kw">then</span> testsC config gen prop xs&#39; cov&#39; rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail stamps&#39;</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>             <span class="kw">else</span> testsC config gen prop xs  cov  rnd1 (ntest<span class="op">+</span><span class="dv">1</span>) nfail stamps&#39;</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>           <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>             <span class="fu">putStrLn</span> ( <span class="st">&quot;Falsifiable, after &quot;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">show</span> ntest</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="st">&quot; tests:\n&quot;</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>                   <span class="op">++</span> <span class="fu">head</span> (arguments result)</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>     <span class="kw">where</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>       x              <span class="ot">=</span> generate (size config ntest) rnd3 gen</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>       xs&#39;            <span class="ot">=</span> xs <span class="op">++</span> [x]</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>       <span class="dt">Prop</span> genResult <span class="ot">=</span> prop xs&#39;</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>       result_        <span class="ot">=</span> generate (size config ntest) rnd4 genResult</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>       result         <span class="ot">=</span> result_ {arguments <span class="ot">=</span> <span class="fu">show</span> xs&#39; <span class="op">:</span> arguments result_ }</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>       (rnd1,rnd2)    <span class="ot">=</span> split rnd0</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>       (rnd3,rnd4)    <span class="ot">=</span> split rnd2</span></code></pre></div>
<p>The other important difference is the <code>cov</code>erage
parameter, which keeps track of how many things have been
<code>classify</code>ed (the <code>stamps</code> parameter). Notice how
we only add the newly generated input, <code>x</code>, if the
<code>cov</code>erage increases.</p>
</section>
</section>
<section id="example-test-runs-using-the-prototype" class="level2">
<h2><a href="#example-test-runs-using-the-prototype"
title="Example test runs using the prototype">Example test runs using
the prototype</a></h2>
<p>Before we go back to the example from the motivation section, let’s
have a look at how coverage information is traditional used in
property-based testing.</p>
<section id="traditional-use-of-coverage" class="level3">
<h3><a href="#traditional-use-of-coverage"
title="Traditional use of coverage">Traditional use of coverage</a></h3>
<p>Let’s start by having a look at how one would typically write a
property using vanilla <code>quickCheck</code>. Consider
<code>insert</code>ing into an already sorted list:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>insert x [] <span class="ot">=</span> [x]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>insert x (y <span class="op">:</span> xs) <span class="op">|</span> x <span class="op">&lt;=</span> y    <span class="ot">=</span> x <span class="op">:</span> y <span class="op">:</span> xs</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> y <span class="op">:</span> insert x xs</span></code></pre></div>
<p>If we do so, then we resulting list should remain sorted:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>prop_insert x xs <span class="ot">=</span> isSorted xs <span class="op">==&gt;</span> isSorted (insert x xs)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="ot">isSorted ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>isSorted xs <span class="ot">=</span> <span class="fu">sort</span> xs <span class="op">==</span> xs</span></code></pre></div>
<p>This test passes:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_insert
OK, passed 100 tests.</code></pre>
<p>What do the test cases that are generated look like? This is where
<code>classify</code> comes in:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_insert&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>prop_insert&#39; x xs <span class="ot">=</span> isSorted xs <span class="op">==&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  classify (<span class="fu">null</span> xs) <span class="st">&quot;empty&quot;</span> <span class="op">$</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  classify (<span class="fu">length</span> xs <span class="op">==</span> <span class="dv">1</span>) <span class="st">&quot;singleton&quot;</span> <span class="op">$</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  classify (<span class="fu">length</span> xs <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> <span class="fu">length</span> xs <span class="op">&lt;=</span> <span class="dv">3</span>) <span class="st">&quot;short&quot;</span> <span class="op">$</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  classify (<span class="fu">length</span> xs <span class="op">&gt;</span> <span class="dv">3</span>) <span class="st">&quot;longer&quot;</span> <span class="op">$</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    isSorted (insert x xs)</span></code></pre></div>
<p>Running this property, we get some statistics about the generated
data:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_insert&#39;
OK, passed 100 tests.
54% empty.
27% singleton.
19% short.</code></pre>
<p>As we can see, all of the lists that get generated are less than 3
elemens long! This is perhaps not what we expected. However if we
consider that precondition says that the list must be sorted, then it
should become clear that it’s unlikely to generate such longer such
lists completely by random<a href="#fn9" class="footnote-ref"
id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
</section>
<section id="using-coverage-to-guide-generation" class="level3">
<h3><a href="#using-coverage-to-guide-generation"
title="Using coverage to guide generation">Using coverage to guide
generation</a></h3>
<p>We now have all the pieces to test the example from the <a
href="#motivation">motivation</a> section:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>bad s <span class="ot">=</span> coverage <span class="dv">0</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">1</span> <span class="ch">&#39;a&#39;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">2</span> <span class="ch">&#39;d&#39;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> coverage <span class="dv">3</span> <span class="ch">&#39;!&#39;</span> <span class="op">$</span> <span class="kw">if</span> s <span class="op">==</span> <span class="st">&quot;bad!&quot;</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    coverage ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    coverage i ch <span class="ot">=</span> classify (s <span class="op">!?</span> i <span class="op">==</span> <span class="dt">Just</span> ch) [ch]</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    (!?) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">!?</span> i <span class="op">|</span> i <span class="op">&lt;</span> <span class="fu">length</span> xs <span class="ot">=</span> <span class="dt">Just</span> (xs <span class="op">!!</span> i)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This property basically says that there’s no string that’s equal to
<code>"bad!"</code>, which is obviously false. If we try to test this
property using the unmodified first version of QuickCheck:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testBad ::</span> <span class="dt">IO</span> ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>testBad <span class="ot">=</span> check config bad</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    config <span class="ot">=</span> quick { maxTest <span class="ot">=</span> (<span class="dv">2</span><span class="op">^</span><span class="dv">8</span>)<span class="op">^</span><span class="dv">4</span> }</span></code></pre></div>
<p>We’ll see spin away, but not actually find the bad string:</p>
<pre><code>&gt;&gt;&gt; testBad
32301
^CInterrupted.</code></pre>
<p>I stopped it after about 32k tries, in theory we’d need more than 4
billion attempts to find the bad string using this approach.</p>
<p>Whereas if we use coverage-guided generation:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testBad&#39; ::</span> <span class="dt">IO</span> ()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>testBad&#39; <span class="ot">=</span> coverCheck config bad</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    config <span class="ot">=</span> verbose</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>      { maxTest <span class="ot">=</span> (<span class="dv">2</span><span class="op">^</span><span class="dv">8</span>)<span class="op">*</span><span class="dv">4</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>      , every <span class="ot">=</span> \n args <span class="ot">-&gt;</span> <span class="fu">show</span> n <span class="op">++</span> <span class="st">&quot;: &quot;</span> <span class="op">++</span> <span class="fu">unlines</span> args</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>      }</span></code></pre></div>
<p>We find the bad string pretty quickly. I’m using verbose output here
so you can see how it first find the <code>"b"</code>, then
<code>"ba"</code>, etc:</p>
<pre><code>&gt;&gt;&gt; testBad&#39;
0: &quot;n&quot;
1: &quot;T&quot;
2: &quot;L&quot;
3: &quot;|&quot;
4: &quot;X&quot;
5: &quot;\&quot;&quot;
6: &quot;e&quot;
7: &quot;G&quot;
8: &quot;R&quot;
9: &quot;}&quot;
10: &quot;C&quot;
11: &quot;3&quot;
12: &quot;&gt;&quot;
13: &quot;C&quot;
14: &quot;J&quot;
15: &quot;9&quot;
16: &quot;=&quot;
17: &quot;9&quot;
18: &quot;L&quot;
19: &quot;)&quot;
20: &quot;5&quot;
21: &quot;6&quot;
22: &quot;x&quot;
23: &quot;#&quot;
24: &quot;T&quot;
25: &quot;T&quot;
26: &quot;_&quot;
27: &quot;@&quot;
28: &quot;}&quot;
29: &quot;y&quot;
30: &quot;-&quot;
31: &quot;s&quot;
32: &quot;b&quot;
33: &quot;bx&quot;
34: &quot;b9&quot;
35: &quot;bf&quot;
36: &quot;bl&quot;
37: &quot;ba&quot;
38: &quot;baC&quot;
39: &quot;baX&quot;
40: &quot;baA&quot;
41: &quot;baE&quot;
42: &quot;bay&quot;
43: &quot;baX&quot;
44: &quot;ba6&quot;
45: &quot;ba@&quot;
46: &quot;bai&quot;
47: &quot;ba}&quot;
48: &quot;bay&quot;
49: &quot;bac&quot;
50: &quot;bak&quot;
51: &quot;ba`&quot;
52: &quot;bad&quot;
53: &quot;bad8&quot;
54: &quot;bade&quot;
55: &quot;bad0&quot;
56: &quot;badA&quot;
57: &quot;badP&quot;
58: &quot;badQ&quot;
59: &quot;bad0&quot;
60: &quot;bade&quot;
61: &quot;bad)&quot;
62: &quot;bado&quot;
63: &quot;badE&quot;
64: &quot;bad\&quot;&quot;
65: &quot;bad@&quot;
66: &quot;bad{&quot;
67: &quot;badX&quot;
68: &quot;bado&quot;
69: &quot;badb&quot;
70: &quot;bad~&quot;
71: &quot;bada&quot;
72: &quot;bad%&quot;
73: &quot;bad9&quot;
74: &quot;badE&quot;
75: &quot;bad8&quot;
76: &quot;bad{&quot;
77: &quot;badS&quot;
78: &quot;badn&quot;
79: &quot;bad?&quot;
80: &quot;badn&quot;
81: &quot;badq&quot;
82: &quot;bady&quot;
83: &quot;badA&quot;
84: &quot;bad4&quot;
85: &quot;bad;&quot;
86: &quot;bad9&quot;
87: &quot;badU&quot;
88: &quot;bad!&quot;
Falsifiable, after 88 tests:
&quot;bad!&quot;</code></pre>
<p>The full source code is available <a
href="https://github.com/stevana/coverage-guided-pbt/blob/main/src/QuickCheckV1.hs">here</a>.</p>
</section>
</section>
<section id="conclusion-and-further-work" class="level2">
<h2><a href="#conclusion-and-further-work"
title="Conclusion and further work">Conclusion and further work</a></h2>
<p>We’ve seen how to add converage-guidance to the first version of the
first property-based testing tool, QuickCheck, in about 35 lines of
code.</p>
<p>Coverage-guidance effectively reduced a exponential problem into a
polynomial one, by building on previous test runs’ successes in
increasing the coverage.</p>
<p>The solution does change the QuickCheck API slightly by requring a
property on a list of <code>a</code>, rather than merely <code>a</code>,
so it’s not suitable for all properties.</p>
<p>I think this limitation isn’t so important, because going further I’d
like to apply coverage-guidance to testing stateful systems. When
testing stateful systems, which I’ve written about <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html">here</a>,
one always generates a list of commands anyway, so the limitation
doesn’t matter.</p>
<p>A more serious limitation with the current approach is that it’s too
greedy and will seek to maximise coverage, without ever backtracking.
This means that it can easily get stuck in local maxima. Consider the
example:</p>
<pre><code>if input[0] == &#39;o&#39;
  if input[1] == &#39;k&#39;
    return
if input[0] == &#39;b&#39;
  if input[1] == &#39;a&#39;
    if input[2] == &#39;d&#39;
      error</code></pre>
<p>If we generate an input that starts with ‘o’ (rather than ‘b’), then
we’ll get stuck never finding the error.</p>
<p>Real coverage-guided tools, like AFL, will not get stuck like that.
While I have a variant of the code that can cope with this, I chose to
present the above greedy version because it’s simpler.</p>
<p>I might write another post with a more AFL-like solution at some
later point, but I’d also like to encourge others to port these ideas to
your favorite language and experiment!</p>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This example is due to Dmitry Vyukov, the main author of
<a href="https://github.com/dvyukov/go-fuzz">go-fuzz</a>, but it’s
basically an easier to understand version of the example from Dan Luu’s
post. For comparison, here’s Dan’s example in full:</p>
<pre><code>// Checks that a number has its bottom bits set
func some_filter(x int) bool {
    for i := 0; i &lt; 16; i = i + 1 {
        if !(x&amp;1 == 1) {
            return false
        }
        x &gt;&gt;= 1
    }
    return true
}

// Takes an array and returns a non-zero int
func dut(a []int) int {
    if len(a) != 4 {
        return 1
    }

    if some_filter(a[0]) {
        if some_filter(a[1]) {
            if some_filter(a[2]) {
                if some_filter(a[3]) {
                    return 0 // A bug! We failed to return non-zero!
                }
                return 2
            }
            return 3
        }
        return 4
    }
    return 5
}</code></pre>
<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn2"><p>For more details about how it works, see the <a
href="https://lcamtuf.coredump.cx/afl/technical_details.txt">AFL
“whitepaper”</a> and its <a
href="https://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html">mutation
heuristics</a>.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>In the case of Haskell, I didn’t know that there was
such a library until read Shae “shapr” Erisson’s post <a
href="https://shapr.github.io/posts/2023-07-30-goldilocks-property-tests.html"><em>Run
property tests until coverage stops increasing</em></a> (2023). Note
that Shae’s post only uses coverage as a stopping condition, not to
actually drive the generation of test cases.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>As I was writing up, I stumbled across the paper <a
href="https://ieeexplore.ieee.org/document/9152719"><em>Ijon: Exploring
Deep State Spaces via Fuzzing</em></a> (2020) which lets the user to add
custom coverage annotations. HypoFuzz also has this <a
href="https://hypofuzz.com/docs/configuration.html#custom-coverage-events">functionality</a>.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>See the appendix of the original <a
href="https://dl.acm.org/doi/10.1145/351240.351266">paper</a> that first
introduced property-based testing. It’s interesting to note that the
collecting statistics functionality is older than shrinking.<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>We’ll not talk about the <code>coarbitrary</code> method
of the <code>Arbitrary</code> type class, which is used to generate
functions, in this post.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>The reason for wrapping <code>Gen</code> in the
<code>Arbitrary</code> type class is so that generators don’t have to be
passed explicitly. Not everyone agrees that this is a good idea, as type
class instances cannot be managed by the module system.<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>It might be interesting to note that we can implement
this signature using the original combinators:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">testsC&#39; ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> <span class="dt">Property</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">String</span>]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>testsC&#39; config gen prop <span class="ot">=</span> tests config genResult</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Prop</span> genResult <span class="ot">=</span> forAll (genList gen) prop</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    genList gen <span class="ot">=</span> sized <span class="op">$</span> \len <span class="ot">-&gt;</span> replicateM len gen</span></code></pre></div>
<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn9"><p>The standard workaround here is to introduce a wrapper
type for which we write a custom generator which generates a random list
and then sorts it before returning. That way no pre-condition is needed,
as the input will be sorted by construction so to say.<a href="#fnref9"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
