<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>The main test loop of simulation testing</title>
  <link rel="stylesheet" href="style.css?modified=2025-02-28" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/the_main_test_loop_of_simulation_testing.html&t=The main test loop of simulation testing">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About / <span class="work-with-me">Work with me</span></a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>The main test loop of simulation testing</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#high-level-overview-of-how-the-simulator-works"
id="toc-high-level-overview-of-how-the-simulator-works">High-level
overview of how the simulator works</a></li>
<li><a href="#representing-the-fake-world"
id="toc-representing-the-fake-world">Representing the fake
world</a></li>
<li><a href="#making-the-fake-world-move"
id="toc-making-the-fake-world-move">Making the fake world move</a></li>
<li><a href="#connecting-the-fake-world-to-the-real-world"
id="toc-connecting-the-fake-world-to-the-real-world">Connecting the fake
world to the real world</a></li>
<li><a href="#running-tests" id="toc-running-tests">Running
tests</a></li>
<li><a href="#conclusion-and-whats-next"
id="toc-conclusion-and-whats-next">Conclusion and what’s next</a></li>
</ul>
</nav>
<div class="date">Posted on Feb 27, 2025</div>
<p>In the <a href="sketching_how_to_simulation_test_distributed_systems.html">last post</a>
we sketched a high-level plan of how to implement language agnostic
simulation testing.</p>
<p>In this post we’ll start working on the implementation. In particular
we’ll have a look at the simulator is implemented and how it’s used to
in the main test loop that gives us simulation testing.</p>
<p>We’ll be using Haskell as our implementation language, however fear
not, I’m aware it’s not everybody’s favorite language and I try to avoid
any clever uses in order to be accessible to the larger programming
community. Should anything be unclear, feel free to get in touch and
I’ll do my best to explain it in a different way.</p>
<section id="high-level-overview-of-how-the-simulator-works"
class="level2">
<h2><a href="#high-level-overview-of-how-the-simulator-works"
title="High-level overview of how the simulator works">High-level
overview of how the simulator works</a></h2>
<p>Before we start introducing code, let’s try to visualise the end
result:</p>
<figure>
<img
src="https://raw.githubusercontent.com/pragma-org/simulation-testing/refs/heads/main/blog/image/simulator.svg"
alt="Picture of simulator and nodes" />
<figcaption aria-hidden="true">Picture of simulator and
nodes</figcaption>
</figure>
<p>The simulator consists of four things:</p>
<ol type="1">
<li>A heap (or priority queue) of messages sorted by arrival time (the
triangle in the picture);</li>
<li>A pseudo-random number generator (PRNG);</li>
<li>A variable number of “node handles” which connect the simulator to
the SUT (nodes);</li>
<li>A trace of client request and response messages to and from the
system.</li>
</ol>
<p>Given this a test run proceeds as follows:</p>
<ol type="1">
<li>The developer provides a way to generate client requests and a way
to check traces;</li>
<li>The simulator generates a an initial heap of client requests using
the developer supplied generator;</li>
<li>The simulator pops the top of the heap, i.e. the message with the
earliest arrival time, and delivers the message to the appropriate node
and gets and responses back via its “node handle”;</li>
<li>If the response is a client response, then append it to the trace,
otherwise it’s a message to another node. For messages to other nodes we
generate a random arrival time using the PRNG and put it back into heap
(this process creates different message interleavings or different seeds
to the PRNG);</li>
<li>Keep doing step 3 and 4 until we run out of messages on the
heap.</li>
<li>Use the developer supplied trace checker to see if the test passed
or not.</li>
</ol>
<p>So, for example, for the echo example in the previous post the
developer would supply way of generating client requests that express
the notion of “node <span class="math inline">\(N\)</span>, please echo
message <span class="math inline">\(M\)</span> back to me” as well as a
way to check if traces are correct. A correct trace in the echo example
amounts to “for each requests to a node to echo something back, there’s
a response from that node which indeed echos back the same message <span
class="math inline">\(M\)</span>”.</p>
<p>From the above recipe we can get something very close to
property-based testing, using the following steps:</p>
<ol type="1">
<li>Generate and execute a test using the above recipe;</li>
<li>Repeat <span class="math inline">\(N\)</span> times;</li>
<li>If one of the tests fail, try shrinking it to provide a minimal
counterexample.</li>
</ol>
<p>Later on we’ll also introduce faults into the mix, but for now this
will do.</p>
</section>
<section id="representing-the-fake-world" class="level2">
<h2><a href="#representing-the-fake-world"
title="Representing the fake world">Representing the fake world</a></h2>
<p>The simulator is manipulating a fake representation of the
“world”:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">World</span> <span class="ot">=</span> <span class="dt">World</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> nodes ::</span> <span class="dt">Map</span> <span class="dt">NodeId</span> <span class="dt">NodeHandle</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> messages ::</span> <span class="dt">Heap</span> <span class="dt">Time</span> <span class="dt">Message</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> prng ::</span> <span class="dt">Prng</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> trace ::</span> <span class="dt">Trace</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>This fake world consists of four parts, that we discussed above, the
nodes and their node handles, the heap of message ordered by arrival
time, a pseudo-random number generator and a trace of client request and
response messages.</p>
<p>The node id is just a string, just like in Maelstrom:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">NodeId</span> <span class="ot">=</span> <span class="dt">NodeId</span> <span class="dt">Text</span></span></code></pre></div>
<p>The node handle is an interface with two operations:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NodeHandle</span> <span class="ot">=</span> <span class="dt">NodeHandle</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> handle ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">Message</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Message</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> close ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The <code>handle</code> operation is called with an arrival time and
a message and returns a sequence of responses, while <code>close</code>
is used to shutdown the node handle (if needed).</p>
<p>A trace is merely a list of messages:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Trace</span> <span class="ot">=</span> [<span class="dt">Message</span>]</span></code></pre></div>
<p>Where messages are defined as per the Maelstrom <a
href="https://github.com/jepsen-io/maelstrom/blob/main/doc/protocol.md">protocol</a>:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Message</span> <span class="ot">=</span> <span class="dt">Message</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> src ::</span> <span class="dt">NodeId</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> dest ::</span> <span class="dt">NodeId</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> body ::</span> <span class="dt">Payload</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>We’ll leave out the exact definition of <code>Payload</code> as
nothing in this post depends on it (and there are multiple ways one can
define it).</p>
</section>
<section id="making-the-fake-world-move" class="level2">
<h2><a href="#making-the-fake-world-move"
title="Making the fake world move">Making the fake world move</a></h2>
<p>The simulator steps through the heap of messages and delivers them to
the nodes via the node handle. The responses it gets from the handle are
partitioned into client responses and messages to other nodes. Client
responses get appended to the trace, together with the message that got
delivered, while the messages to other nodes get assigned random arrival
times and fed back into the heap of messages to be delivered.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stepWorld ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">World</span> ())</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>stepWorld world <span class="ot">=</span> <span class="kw">case</span> Heap.pop world<span class="op">.</span>messages <span class="kw">of</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Right</span> ())</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> ((arrivalTime, message), messages&#39;) <span class="ot">-&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> Map.lookup message<span class="op">.</span>dest world<span class="op">.</span>nodes <span class="kw">of</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> (<span class="st">&quot;stepWorld: unknown destination node: &quot;</span> <span class="op">++</span> <span class="fu">show</span> message<span class="op">.</span>dest)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> node <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (prng&#39;, prng&#39;&#39;) <span class="ot">=</span> splitPrng world<span class="op">.</span>prng</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        responses <span class="ot">&lt;-</span> node<span class="op">.</span>handle arrivalTime message</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (clientResponses, nodeMessages) <span class="ot">=</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>              partition (isClientNodeId <span class="op">.</span> dest) responses</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            meanMicros <span class="ot">=</span> <span class="dv">20000</span> <span class="co">-- 20ms</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>            nodeMessages&#39; <span class="ot">=</span> generateRandomArrivalTimes arrivalTime meanMicros nodeMessages prng&#39;</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span> <span class="dt">Left</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">World</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>              { nodes <span class="ot">=</span> world<span class="op">.</span>nodes</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>              , messages <span class="ot">=</span> messages&#39; <span class="op">&lt;&gt;</span> nodeMessages&#39;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>              , prng <span class="ot">=</span> prng&#39;&#39;</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>              , trace <span class="ot">=</span> world<span class="op">.</span>trace <span class="op">++</span> message <span class="op">:</span> clientResponses</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>              }</span></code></pre></div>
<p>Note that in the case of the echo example there are no messages
between nodes, a node echos back the client request immediately without
any communication with other nodes. We’ll see examples of communication
between nodes before a client response is made a bit later<a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>Another aspect we’ve not seen yet, which will be important later, is
timeouts. The <code>handle</code> function is given the current
simulated time by the simulator, which allows the system under test to
update its notion of time, potentially triggering timeouts (without
having to wait for them to happen in real time).</p>
<p>The above step function, takes one step in the simulation, we can run
the simulation to it’s completion by merely keep stepping it until we
run out of messages to deliver:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runWorld ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Trace</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>runWorld world <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  stepWorld world <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> () <span class="ot">-&gt;</span> <span class="fu">return</span> world<span class="op">.</span>trace</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> world&#39; <span class="ot">-&gt;</span> runWorld world&#39;</span></code></pre></div>
<p>We could imagine having other stopping criteria, e.g. stop after one
minute of real time, or after one year of simulated time, etc.
Time-based stopping criteria are more interesting if we have infinite
generators of client requests (which we currently don’t).</p>
</section>
<section id="connecting-the-fake-world-to-the-real-world"
class="level2">
<h2><a href="#connecting-the-fake-world-to-the-real-world"
title="Connecting the fake world to the real world">Connecting the fake
world to the real world</a></h2>
<p>We know how to simulate the network between <span
class="math inline">\(N\)</span> nodes, but how messages get
<code>handle</code>d is abstracted away in the node handle interface. We
don’t have enough all the pieces to be able to show a concrete
implementation of <code>handle</code> yet. However, we can make thing
slightly more concrete by providing a way of specifying how many nodes
are in a test and how to spawn node handles:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Deployment</span> <span class="ot">=</span> <span class="dt">Deployment</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> numberOfNodes ::</span> <span class="dt">Int</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> spawn ::</span> <span class="dt">IO</span> <span class="dt">NodeHandle</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Given the node count, a spawn function, a list of initial messages,
and a PRNG, we can construct a fake “world” as follows:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newWorld ::</span> <span class="dt">Deployment</span> <span class="ot">-&gt;</span> [<span class="dt">Message</span>] <span class="ot">-&gt;</span> <span class="dt">Prng</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">World</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>newWorld deployment initialMessages prng <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> nodeIds <span class="ot">=</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">map</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>          (<span class="dt">NodeId</span> <span class="op">.</span> (<span class="st">&quot;n&quot;</span> <span class="op">&lt;&gt;</span>) <span class="op">.</span> Text.pack <span class="op">.</span> <span class="fu">show</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>          [<span class="dv">1</span> <span class="op">..</span> deployment<span class="op">.</span>numberOfNodes]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  nodeHandles <span class="ot">&lt;-</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    replicateM deployment<span class="op">.</span>numberOfNodes deployment<span class="op">.</span>spawn</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (prng&#39;, prng&#39;&#39;) <span class="ot">=</span> splitPrng prng</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>      meanMicros <span class="ot">=</span> <span class="dv">20000</span> <span class="co">-- 20ms</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>      initialMessages&#39; <span class="ot">=</span> generateRandomArrivalTimes epoch meanMicros initialMessages prng&#39;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">World</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      { nodes <span class="ot">=</span> Map.fromList (<span class="fu">zip</span> nodeIds nodeHandles)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>      , messages <span class="ot">=</span> initialMessages&#39;</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>      , prng <span class="ot">=</span> prng&#39;&#39;</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>      , trace <span class="ot">=</span> []</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>      }</span></code></pre></div>
<p>This fake world is now ready to be run by the simulator, as we
described above.</p>
</section>
<section id="running-tests" class="level2">
<h2><a href="#running-tests" title="Running tests">Running
tests</a></h2>
<p>At this point we got everything we need to use the simulator as the
center piece of our tests. We’ll parametrised our tests by a
configuration to be able to control the tests:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TestConfig</span> <span class="ot">=</span> <span class="dt">TestConfig</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> numberOfTests ::</span> <span class="dt">Int</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> numberOfNodes ::</span> <span class="dt">Int</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> replaySeed ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">defaultTestConfig ::</span> <span class="dt">TestConfig</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>defaultTestConfig <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TestConfig</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    { numberOfTests <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    , numberOfNodes <span class="ot">=</span> <span class="dv">5</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    , replaySeed <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>The number of tests parameter controls how many test cases we
generate and execute, in the sense of property-based testing. The number
of nodes, we covered above. Finally there’s the replay seed, which is
used to create the PRNG. By using the same seed we can replay a test
execution and get the same result, which is useful if we want to share a
failing test case with someone or check if a patch fixes a bug.</p>
<p>Another parameter of the tests is a so called “workload”, which
captures the notion of how client requests are generated and how traces
are checked<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Workload</span> <span class="ot">=</span> <span class="dt">Workload</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> name ::</span> <span class="dt">Text</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> generateMessage ::</span> <span class="dt">Gen</span> <span class="dt">Message</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> property ::</span> <span class="dt">Form</span> <span class="dt">Message</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Given the above we can write the main test loop:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">blackboxTestWith ::</span> <span class="dt">TestConfig</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Workload</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>blackboxTestWith testConfig binaryFilePath workload <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  (prng, seed) <span class="ot">&lt;-</span> newPrng testConfig<span class="op">.</span>replaySeed</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> deployment <span class="ot">=</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Deployment</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>          { numberOfNodes <span class="ot">=</span> testConfig<span class="op">.</span>numberOfNodes</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>          , spawn <span class="ot">=</span> pipeSpawn binaryFilePath seed</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (prng&#39;, _prng&#39;&#39;) <span class="ot">=</span> splitPrng prng</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> runTests deployment workload testConfig<span class="op">.</span>numberOfTests prng&#39;</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> result <span class="kw">of</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Failure</span> trace <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> (<span class="st">&quot;Seed: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> seed)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> trace</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="dt">False</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Success</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">True</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="ot">blackboxTest ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Workload</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>blackboxTest <span class="ot">=</span> blackboxTestWith defaultTestConfig</span></code></pre></div>
<p>The <code>pipeSpawn</code> function takes a file path to a binary and
creates a node handle via <code>stdin</code> and <code>stdout</code>,
similar to Maelstrom. We’ll see the concrete implementation of this in a
later post.</p>
<p>The only thing that remains is to loop <code>numberOfTests</code>
times, generating and executing the tests each time.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TestResult</span> <span class="ot">=</span> <span class="dt">Success</span> <span class="op">|</span> <span class="dt">Failure</span> <span class="dt">Trace</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runTests ::</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Deployment</span> <span class="ot">-&gt;</span> <span class="dt">Workload</span> <span class="ot">-&gt;</span> <span class="dt">NumberOfTests</span> <span class="ot">-&gt;</span> <span class="dt">Prng</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TestResult</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>runTests deployment workload numberOfTests0 initialPrng <span class="ot">=</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  loop numberOfTests0 initialPrng</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    loop ::</span> <span class="dt">NumberOfTests</span> <span class="ot">-&gt;</span> <span class="dt">Prng</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TestResult</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    loop <span class="dv">0</span> _prng <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Success</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    loop n prng <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> (prng&#39;, initialMessages) <span class="ot">=</span> generate <span class="dv">100</span> prng <span class="co">-- XXX: vary size over time...</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> (prng&#39;&#39;, prng&#39;&#39;&#39;) <span class="ot">=</span> splitPrng prng&#39;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      result <span class="ot">&lt;-</span> runTest deployment workload prng&#39;&#39; initialMessages</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> result <span class="kw">of</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Success</span> <span class="ot">-&gt;</span> loop (n <span class="op">-</span> <span class="dv">1</span>) prng&#39;&#39;&#39;</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Failure</span> _unShrunkTrace <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>          initialMessagesAndTrace <span class="ot">&lt;-</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>            shrink</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>              (<span class="fu">fmap</span> testResultToMaybe <span class="op">.</span> runTest deployment workload prng)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>              (shrinkList (<span class="fu">const</span> []))</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>              initialMessages</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> (_shrunkMessages, shrunkTrace) <span class="ot">=</span> NonEmpty.last initialMessagesAndTrace</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>          <span class="fu">return</span> (<span class="dt">Failure</span> shrunkTrace)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="ot">    generate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Prng</span> <span class="ot">-&gt;</span> (<span class="dt">Prng</span>, [<span class="dt">Message</span>])</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    generate size prng <span class="ot">=</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> initMessages <span class="ot">=</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>            [ makeInitMessage (makeNodeId i) (<span class="fu">map</span> makeNodeId js)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">1</span> <span class="op">..</span> deployment<span class="op">.</span>numberOfNodes]</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>            , <span class="kw">let</span> js <span class="ot">=</span> [j <span class="op">|</span> j <span class="ot">&lt;-</span> [<span class="dv">1</span> <span class="op">..</span> deployment<span class="op">.</span>numberOfNodes], j <span class="op">/=</span> i]</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>          (prng&#39;, initialMessages) <span class="ot">=</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>            Gen.runGen (Gen.listOf workload<span class="op">.</span>generateMessage) prng size</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a><span class="ot">          messages ::</span> [<span class="dt">Message</span>]</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>          messages <span class="ot">=</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>            <span class="fu">zipWith</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>              ( \message <span class="fu">index</span> <span class="ot">-&gt;</span> message {body <span class="ot">=</span> message<span class="op">.</span>body {msgId <span class="ot">=</span> <span class="dt">Just</span> <span class="fu">index</span>}}</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>              )</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>              (initMessages <span class="op">&lt;&gt;</span> initialMessages)</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span> <span class="op">..</span>]</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span>  (prng&#39;, messages)</span></code></pre></div>
<p>Where running a single test creates a new fake world, simulates it
and checks the trace:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runTest ::</span> <span class="dt">Deployment</span> <span class="ot">-&gt;</span> <span class="dt">Workload</span> <span class="ot">-&gt;</span> <span class="dt">Prng</span> <span class="ot">-&gt;</span> [<span class="dt">Message</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TestResult</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>runTest deployment workload prng initialMessages <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  world <span class="ot">&lt;-</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    newWorld</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>      deployment</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>      initialMessages</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>      prng</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  resultingTrace <span class="ot">&lt;-</span> runWorld world</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  traverse_ (<span class="op">.</span>close) world<span class="op">.</span>nodes</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> sat workload<span class="op">.</span>property resultingTrace emptyEnv</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Success</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">return</span> (<span class="dt">Failure</span> resultingTrace)</span></code></pre></div>
</section>
<section id="conclusion-and-whats-next" class="level2">
<h2><a href="#conclusion-and-whats-next"
title="Conclusion and what’s next">Conclusion and what’s next</a></h2>
<p>We’ve seen how one could go about implementing testing around a
simulation of a network between nodes in a distributed system.</p>
<p>There were a couple of things we had to leave out from the code:</p>
<ol type="1">
<li>How generation of client requests is implemented;</li>
<li>How to check that traces, that the simulator returns, are
correct;</li>
<li>How to shrink and present minimal counterexamples when the check
fails;</li>
<li>How to spawn node handles which allow us to communicate with nodes
via <code>stdin</code> and <code>stdout</code> similar to
Maelstrom.</li>
</ol>
<p>This is what we’ll turn our attention to next. Probably tackling
point 1-3 in one or two posts. For point 4 we need a bit more context,
in particular we need to introduce the deterministic event loop on top
of which nodes are running (the node handle will be connected to the
event loop).</p>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>For now I hope you can imagine something like: don’t
reply to the client until we’ve replicated the data among enough nodes
so that we can ensure it’s reliably there in case some nodes crash.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The details of how <code>Gen</code> and
<code>Form</code> are defined will be a subject of later posts.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
