<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>Parallel property-based testing with a deterministic thread scheduler</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/parallel_property-based_testing_with_a_deterministic_thread_scheduler.html&t=Parallel property-based testing with a deterministic thread scheduler">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About</a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>Parallel property-based testing with a deterministic thread scheduler</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#background" id="toc-background">Background</a></li>
<li><a href="#motivation-and-overview"
id="toc-motivation-and-overview">Motivation and overview</a></li>
<li><a href="#deterministic-scheduler"
id="toc-deterministic-scheduler">Deterministic scheduler</a>
<ul>
<li><a href="#thread-scheduler-communication"
id="toc-thread-scheduler-communication">Thread-scheduler
communication</a></li>
<li><a href="#managed-threads" id="toc-managed-threads">Managed
threads</a></li>
<li><a href="#scheduler" id="toc-scheduler">Scheduler</a></li>
<li><a href="#example-broken-atomic-counter"
id="toc-example-broken-atomic-counter">Example: broken atomic
counter</a></li>
</ul></li>
<li><a href="#parallel-property-based-testing-recap"
id="toc-parallel-property-based-testing-recap">Parallel property-based
testing recap</a></li>
<li><a href="#integrating-the-scheduler-into-the-testing"
id="toc-integrating-the-scheduler-into-the-testing">Integrating the
scheduler into the testing</a>
<ul>
<li><a href="#changes-to-sequential-module"
id="toc-changes-to-sequential-module">Changes to sequential
module</a></li>
<li><a href="#changes-to-parallel-module"
id="toc-changes-to-parallel-module">Changes to parallel module</a></li>
<li><a href="#changes-to-the-counter-example"
id="toc-changes-to-the-counter-example">Changes to the counter
example</a></li>
</ul></li>
<li><a href="#conclusion-and-further-work"
id="toc-conclusion-and-further-work">Conclusion and further
work</a></li>
</ul>
</nav>
<div class="date">Posted on Jul 19, 2024</div>
<p><em>Work in progress, please don’t share, but do feel free to get
involved!</em></p>
<p>This post is about how to write tests that can catch race conditions
in a reproducible way. The approach is programming language agnostic,
and should work in most languages that have a decent multi-threaded
story. It’s a white-box testing approach, meaning you will have to
modify the software under test.</p>
<section id="background" class="level2">
<h2><a href="#background" title="Background">Background</a></h2>
<p>In my previous <a
href="https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html">post</a>,
we had a look at how to mechanically derive parallel tests that can
uncover race conditions from a sequential fake<a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>One of the nice things about the approach is that it’s a black-box
testing technique, i.e. it doesn’t require the user to change the
software under test.</p>
<p>One big downside is that because threads will interleave differently
when we rerun the tests, there by potentially causing different
outcomes. This in turn creates problems for the shrinking of failing
test cases<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<p>As a workaround, I suggested that when a race condition is found in
the unmodified code, one could swap the shared memory module for one
that introduces sleeps around the operations. This creates less
non-determinism, because the jitter of each operation will have less of
an impact, and therefore helps shrinking.</p>
<p>This isn’t a satisfactory solution, of course, and I left a to do
item to implement a determinstic scheduler, like the authors do in the
<a
href="https://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf">paper</a>
that first introduced parallel property-based testing.</p>
<p>The idea of the deterministic scheduler is that it should be possible
to rerun a multi-threaded program and get exactly the same interleaving
of threads each time.</p>
<p>The deterministic scheduler from the above mentioned paper is called
PULSE. It was <a
href="http://quviq.com/documentation/pulse/index.html">supposedly</a>
released under the BSD license, however I’ve not been able to find
it.</p>
<p>PULSE is written in Erlang and the paper uses it to test Erlang code.
In Erlang everything is triggered by message passing, so I think that
the correct way of thinking about what PULSE does is that it acts as a
person-in-the-middle proxy. With other words, an Erlang process doesn’t
send a messaged directly to another process, but instead asks the
scheduler to send it to the process. That way all messages go via the
scheduler and it can choose the message order. Note that a seed can be
used to introduce randomness, without introducing non-determinism.</p>
<p>I implemented a proxy scheduler like this in Haskell (using
<code>distributed-process</code>, think Haskell trying to be like
Erlang) about 6 years <a
href="https://github.com/advancedtelematic/quickcheck-state-machine-distributed#readme">ago</a>,
but I didn’t know how to do it in a non-message-passing setting.</p>
<p>I was therefore happy to see that my post inspired matklad to write a
<a
href="https://matklad.github.io/2023/07/05/properly-testing-concurrent-data-structures.html">post</a>
where he shows how he’d do it in a multi-threaded shared memory
setting.</p>
<p>In this post I’ll port matklad’s approach from Rust to Haskell and
hook it up to the parallel property-based testing machinary from my
previous post.</p>
<p>Another difference between matklad and the approach in this post is
that matklad uses an ad-hoc correctness criteria, whereas I follow the
parallel property-based testing paper and use <a
href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf">linearisability</a>.</p>
<p>An ad-hoc criteria can be faster than linearisability checking, but
depending on how complicated your system is, it might be harder to find
one. Linearisability checking on the other hand follows mechanically
(for free) from a sequential (single-threaded) model/fake.</p>
<p>If you know what you are doing, then by all means figure out an
ad-hoc correctness criteria like matklad does. If on the otherhand you
haven’t tested much concurrent code before, then I’d recommend starting
with the linearisability checking approach that we are about to
describe<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
</section>
<section id="motivation-and-overview" class="level2">
<h2><a href="#motivation-and-overview"
title="Motivation and overview">Motivation and overview</a></h2>
<p>In order to explain what we’d like to do, it’s helpful to consider an
example of a race condition.</p>
<p>The text book <a
href="https://en.wikipedia.org/wiki/Race_condition#Example">example</a>
of a race condition is a counter which is incremented by two threads at
the same time.</p>
<p>One possible interleaving of the two threads that yields the correct
result is the following:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Time</th>
<th style="text-align: left;">Thread 1</th>
<th style="text-align: left;">Thread 2</th>
<th style="text-align: center;"></th>
<th style="text-align: left;">Integer value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">read value</td>
<td style="text-align: left;"></td>
<td style="text-align: center;">←</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">increase value</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">write back</td>
<td style="text-align: left;"></td>
<td style="text-align: center;">→</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">read value</td>
<td style="text-align: center;">←</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">increase value</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">write back</td>
<td style="text-align: center;">→</td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<p>However there are other interleavings where one of the threads
overwrites the other thread’s increment, yielding an incorrect
result:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Time</th>
<th style="text-align: left;">Thread 1</th>
<th style="text-align: left;">Thread 2</th>
<th style="text-align: center;"></th>
<th style="text-align: left;">Integer value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">read value</td>
<td style="text-align: left;"></td>
<td style="text-align: center;">←</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">read value</td>
<td style="text-align: center;">←</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">increase value</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">increase value</td>
<td style="text-align: center;"></td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;">write back</td>
<td style="text-align: left;"></td>
<td style="text-align: center;">→</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">write back</td>
<td style="text-align: center;">→</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<p>In most programming languages the thread interleaving is
non-deterministic, and so we get irreproducible failures also sometimes
known as “Heisenbugs”.</p>
<p>What we’d like to do is to be able to start a program with some token
and if the same token is used then we get the same thread interleaving
and therefore a reproducible result.</p>
<p>The idea, due to matklad, is to insert pauses between each shared
memory operation (the reads and writes), have a scheduler unpause one
thread at the time. The scheduler is parametrised by a seed which is
used together with a pseudorandom number generator which allows it to
deterministically choose which thread to unpause.</p>
<p>In the rest of this post we will port matklad’s deterministic
scheduler from Rust to Haskell, hopefully in a way that shows that this
can be done in any other language with decent multi-threaded programming
primitives. Then we’ll do a short recap of how parallel property-based
testing works, and finally we’ll hook up the deterministic schduler to
the parallel property-based testing machinary.</p>
</section>
<section id="deterministic-scheduler" class="level2">
<h2><a href="#deterministic-scheduler"
title="Deterministic scheduler">Deterministic scheduler</a></h2>
<p>The implementation of the deterministic scheduler can be split up in
three parts. First we’ll implement a way for the spawned threads to
communicate with the scheduler, this communication channel will be used
to pause and unpause the threads. After that we’ll make a wrapper
datatype around Haskell’s threads which also includes the communication
channel. Finally, we’ll have all the pieces to implement the
deterministic scheduler itself.</p>
<section id="thread-scheduler-communication" class="level3">
<h3><a href="#thread-scheduler-communication"
title="Thread-scheduler communication">Thread-scheduler
communication</a></h3>
<p>The scheduler needs to be able to communicate with the running
threads, in order to be able to determinstically unpause, or “step”, one
thread at a time.</p>
<p>We’ll use Haskell’s <code>TMVar</code>s for this, but any kind of
shared memory will do.</p>
<p>Haskell’s <code>MVar</code>s can be thought of boxes that contain a
value, where taking something out of a box that is empty blocks and
putting something into a box that is full blocks as well. Where “blocks”
means that the run-time will suspend the thread that tries the blocking
action and only wake it up when the <code>MVar</code> changes, i.e. it’s
an efficient way of waiting compared to <a
href="https://en.wikipedia.org/wiki/Busy_waiting">busy-waiting</a> or
spinning.</p>
<p>The <code>T</code> in <code>TMVar</code>s merely adds <a
href="https://en.wikipedia.org/wiki/Software_transactional_memory">STM</a>
transactions around <code>MVar</code>s, we’ll see an example of what
these are useful for shortly.</p>
<p>We’ll call our communcation channel <code>Signal</code>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Signal</span> <span class="ot">=</span> <span class="dt">SingleThreaded</span> <span class="op">|</span> <span class="dt">MultiThreaded</span> (<span class="dt">TMVar</span> ())</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Eq</span></span></code></pre></div>
<p>There are two ways to create a <code>Signal</code>, one for
single-threaded and another for multi-threaded execution:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newSingleThreadedSignal ::</span> <span class="dt">Signal</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>newSingleThreadedSignal <span class="ot">=</span> <span class="dt">SingleThreaded</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">newMultiThreadedSignal ::</span> <span class="dt">IO</span> <span class="dt">Signal</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>newMultiThreadedSignal <span class="ot">=</span> <span class="dt">MultiThreaded</span> <span class="op">&lt;$&gt;</span> newEmptyTMVarIO</span></code></pre></div>
<p>The idea being that in the single-threaded case the scheduler
shouldn’t be doing anything. In particular pausing a thread in the
single-threaded case is a no-op:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pause ::</span> <span class="dt">Signal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>pause <span class="dt">SingleThreaded</span>        <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>pause (<span class="dt">MultiThreaded</span> tmvar) <span class="ot">=</span> atomically (takeTMVar tmvar)</span></code></pre></div>
<p>Notice that in the multi-threaded case the pause operation will try
to take a value from the <code>TMVar</code> and also notice that the
<code>TMVar</code> starts off being empty, so this will cause the thread
to block.</p>
<p>The way the scheduler can unpause the thread is by putting a unit
value into the <code>TMVar</code>, which will cause the
<code>takeTMVar</code> finish.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unpause ::</span> <span class="dt">Signal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>unpause <span class="dt">SingleThreaded</span>        <span class="ot">=</span> <span class="fu">error</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;unpause: a single thread should never be paused&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>unpause (<span class="dt">MultiThreaded</span> tmvar) <span class="ot">=</span> atomically (putTMVar tmvar ())</span></code></pre></div>
<p>For our scheduler implementation we’ll also need a way to check if a
thread is paused:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isPaused ::</span> <span class="dt">Signal</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>isPaused <span class="dt">SingleThreaded</span>        <span class="ot">=</span> <span class="fu">return</span> <span class="dt">False</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>isPaused (<span class="dt">MultiThreaded</span> tmvar) <span class="ot">=</span> isEmptyTMVar tmvar</span></code></pre></div>
<p>It’s also useful to be able to check if all threads are paused:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">waitUntilAllPaused ::</span> [<span class="dt">Signal</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>waitUntilAllPaused signals <span class="ot">=</span> atomically <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  bs <span class="ot">&lt;-</span> <span class="fu">mapM</span> isPaused signals</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  guard (<span class="fu">and</span> bs)</span></code></pre></div>
<p>Notice that STM makes this easy as we can do this check
atomically.</p>
</section>
<section id="managed-threads" class="level3">
<h3><a href="#managed-threads" title="Managed threads">Managed
threads</a></h3>
<p>Having implemented the communication channel between the thread and
the scheduler, we are now ready to introduce our “managed” threads (we
call them “managed” because they are managed by the scheduler). These
threads are basically a wrapper around Haskell’s <code>Async</code>
threads that also includes our communication channel,
<code>Signal</code>.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ManagedThreadId</span> a <span class="ot">=</span> <span class="dt">ManagedThreadId</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> _mtidName   ::</span> <span class="dt">String</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _mtidSignal ::</span> <span class="dt">Signal</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _mtidAsync  ::</span> <span class="dt">Async</span> a</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Eq</span></span></code></pre></div>
<p>Our managed thread can be spawned as follows:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">spawn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Signal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">ManagedThreadId</span> a)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>spawn name io <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  s <span class="ot">&lt;-</span> newMultiThreadedSignal</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> async (io s)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">ManagedThreadId</span> name s a)</span></code></pre></div>
<p>Noticed that the spawned IO action gets access to the communication
channel.</p>
<p>The <code>Async</code> thread API exposes a way to check if a thread
is still executing, threw an exeception or finished yeilding a result.
We’ll extend this by also being able to check if the thread is paused as
follows.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ThreadStatus</span> a <span class="ot">=</span> <span class="dt">Paused</span> <span class="op">|</span> <span class="dt">Finished</span> a <span class="op">|</span> <span class="dt">Threw</span> <span class="dt">SomeException</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">getThreadStatus ::</span> <span class="dt">ManagedThreadId</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">ThreadStatus</span> a)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>getThreadStatus mtid <span class="ot">=</span> atomically go</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    go <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>      res <span class="ot">&lt;-</span> pollSTM (_mtidAsync mtid)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> res <span class="kw">of</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>          b <span class="ot">&lt;-</span> isPaused (_mtidSignal mtid)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> b</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Paused</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> go</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> (<span class="dt">Left</span> err) <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Threw</span> err)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> (<span class="dt">Right</span> x)  <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Finished</span> x)</span></code></pre></div>
</section>
<section id="scheduler" class="level3">
<h3><a href="#scheduler" title="Scheduler">Scheduler</a></h3>
<p>We now got all the pieces we need to implement our deterministic
scheduler.</p>
<p>The idea is to wait until all threads are paused, then step one of
them and wait until it either pauses again or finishes. If it pauses
again, then repeat the stepping. If it finishes, remove it from the list
of stepped threads and continue stepping.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">schedule ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> [<span class="dt">ManagedThreadId</span> a] <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> <span class="dt">IO</span> ([a], g)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>schedule mtids0 gen0 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">&lt;-</span> timeout <span class="dv">1000000</span> (waitUntilAllPaused (<span class="fu">map</span> _mtidSignal mtids0))</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> res <span class="kw">of</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;schedule: all threads didn&#39;t pause within a second&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> () <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- putStrLn &quot;all paused&quot;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>      go mtids0 gen0 []</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> [<span class="dt">ManagedThreadId</span> a] <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">IO</span> ([a], g)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    go []    gen acc <span class="ot">=</span> <span class="fu">return</span> (<span class="fu">reverse</span> acc, gen)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    go mtids gen acc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> (ix, gen&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, <span class="fu">length</span> mtids <span class="op">-</span> <span class="dv">1</span>) gen</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>          mtid <span class="ot">=</span> mtids <span class="op">!!</span> ix</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- putStrLn (&quot;schedule, picked: &quot; ++ _mtidName mtid)</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      unpause (_mtidSignal mtid)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      status <span class="ot">&lt;-</span> getThreadStatus mtid</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> status <span class="kw">of</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Finished</span> x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- putStrLn (&quot;schedule, finished: &quot; ++ _mtidName mtid)</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>          go (mtids \\ [mtid]) gen&#39; (x <span class="op">:</span> acc)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Paused</span>     <span class="ot">-&gt;</span> go mtids gen&#39; acc</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Threw</span> err  <span class="ot">-&gt;</span> <span class="fu">error</span> (<span class="st">&quot;schedule: &quot;</span> <span class="op">++</span> <span class="fu">show</span> err)</span></code></pre></div>
<p>We can now also implement a useful higher-level combinator:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapConcurrently ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> (<span class="dt">Signal</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> <span class="dt">IO</span> ([b], g)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>mapConcurrently f xs gen <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  mtids <span class="ot">&lt;-</span> forM (<span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] xs) <span class="op">$</span> \(i, x) <span class="ot">-&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    spawn (<span class="st">&quot;Thread &quot;</span> <span class="op">++</span> <span class="fu">show</span> i) (\sig <span class="ot">-&gt;</span> f sig x)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  schedule mtids gen</span></code></pre></div>
</section>
<section id="example-broken-atomic-counter" class="level3">
<h3><a href="#example-broken-atomic-counter"
title="Example: broken atomic counter">Example: broken atomic
counter</a></h3>
<p>To show that our scheduler is indeed deterministic, let’s implement
the race condition between two increments from the introduction.</p>
<p>First let’s introduce an interface for shared memory.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SharedMemory</span> a <span class="ot">=</span> <span class="dt">SharedMemory</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> memReadIORef  ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> memWriteIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">realMem ::</span> <span class="dt">SharedMemory</span> a</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>realMem <span class="ot">=</span> <span class="dt">SharedMemory</span> readIORef writeIORef</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="ot">fakeMem ::</span> <span class="dt">Signal</span> <span class="ot">-&gt;</span> <span class="dt">SharedMemory</span> a</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>fakeMem signal <span class="ot">=</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SharedMemory</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    { memReadIORef <span class="ot">=</span> \ref <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        pause signal</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- putStrLn &quot;reading ref&quot;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        x <span class="ot">&lt;-</span> readIORef ref</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- pause signal</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> x</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    , memWriteIORef <span class="ot">=</span> \ref x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        pause signal</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- putStrLn &quot;writing ref&quot;</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        writeIORef ref x</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- pause signal</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>The idea is that we will use two different instances of this
interface: a “real” one which just does what we’d expect from shared
memory, and a “fake” one which pauses around the real operations. The
real one will be used when we deploy the actual software and the fake
one while we do our testing.</p>
<p>We can now implement our counter example against the shared memory
interface:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AtomicCounter</span> <span class="ot">=</span> <span class="dt">AtomicCounter</span> (<span class="dt">IORef</span> <span class="dt">Int</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">newCounter ::</span> <span class="dt">IO</span> <span class="dt">AtomicCounter</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>newCounter <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  ref <span class="ot">&lt;-</span> newIORef <span class="dv">0</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">AtomicCounter</span> ref)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">incr ::</span> <span class="dt">SharedMemory</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>incr mem (<span class="dt">AtomicCounter</span> ref) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> memReadIORef mem ref</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  memWriteIORef mem ref (i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">SharedMemory</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>get mem (<span class="dt">AtomicCounter</span> ref) <span class="ot">=</span> memReadIORef mem ref</span></code></pre></div>
<p>Finally, we can implement the race condition test using the counter
and two threads that do increments:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Int</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>test seed <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  counter <span class="ot">&lt;-</span> newCounter</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  mtid1 <span class="ot">&lt;-</span> spawn <span class="st">&quot;0&quot;</span> (\signal <span class="ot">-&gt;</span> incr (fakeMem signal) counter)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  mtid2 <span class="ot">&lt;-</span> spawn <span class="st">&quot;1&quot;</span> (\signal <span class="ot">-&gt;</span> incr (fakeMem signal) counter)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> gen  <span class="ot">=</span> mkStdGen seed</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> schedule [mtid1, mtid2] gen</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  two <span class="ot">&lt;-</span> get realMem counter</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (seed, two <span class="op">==</span> <span class="dv">2</span>, two)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="ot">test1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> <span class="fu">mapM_</span> (\seed <span class="ot">-&gt;</span> <span class="fu">print</span> <span class="op">=&lt;&lt;</span> test seed) [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]</span></code></pre></div>
<p>The test is parametrised by a seed for the scheduler. If we run it
with different seeds we get different outcomes:</p>
<pre><code>&gt;&gt;&gt; test1
(0,True,2)
(1,True,2)
(2,False,1)
(3,True,2)
(4,False,1)
(5,True,2)
(6,False,1)
(7,False,1)
(8,True,2)
(9,True,2)
(10,False,1)</code></pre>
<p>If we fix the seed to one which makes our test fail:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>test2 <span class="ot">=</span> <span class="kw">let</span> seed <span class="ot">=</span> <span class="dv">2</span> <span class="kw">in</span> replicateM_ <span class="dv">10</span> (<span class="fu">print</span> <span class="op">=&lt;&lt;</span> test seed)</span></code></pre></div>
<p>then we get the same outcome everytime:</p>
<pre><code>&gt;&gt;&gt; test2
(2,False,1)
(2,False,1)
(2,False,1)
(2,False,1)
(2,False,1)
(2,False,1)
(2,False,1)
(2,False,1)
(2,False,1)
(2,False,1)</code></pre>
<p>These quick tests seem to suggest that our scheduler is in fact
deterministic.</p>
</section>
</section>
<section id="parallel-property-based-testing-recap" class="level2">
<h2><a href="#parallel-property-based-testing-recap"
title="Parallel property-based testing recap">Parallel property-based
testing recap</a></h2>
<p>In our counter example above, we had two concurrent increments, in
this case it’s easy to see what the answer must be (the counter must
have the value of two, if we start counting from zero and increment by
one).</p>
<p>However for more complicated scenarios it gets less clear,
consider:</p>
<ul>
<li>two concurrent incrs + get</li>
<li>timeouts / crashing threads</li>
<li>more complicated datastructures than a counter, e.g. key-value store
with deletes</li>
</ul>
<p>Luckily there’s a correctness criteria for concurrent programs like
these which is based on a sequential model:</p>
<p>Linearizability: a correctness condition for concurrent objects by
Herlihy and Wing (1990) <a
href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf"
class="uri">https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf</a></p>
<p>this is what we use in parallel property-based testing (and also what
Jepsen’s Knossos checker uses)</p>
<p>The idea in a nutshell: execute commands in parallel, collect a
concurrent history of when each command started and stopped executing,
try to find an interleaving of commands which satisfies the sequential
model.</p>
<ul>
<li>eventual consistency?</li>
</ul>
</section>
<section id="integrating-the-scheduler-into-the-testing" class="level2">
<h2><a href="#integrating-the-scheduler-into-the-testing"
title="Integrating the scheduler into the testing">Integrating the
scheduler into the testing</a></h2>
<p>I don’t want to reimplement the parallel property-based testing
machinary from my previous post here, but merely show that integrating
the deterministic scheduler isn’t too much work.</p>
<p>We need to change the code from the previous post in three different
places: the sequential module, the parallel module and the counter
example itself.</p>
<section id="changes-to-sequential-module" class="level3">
<h3><a href="#changes-to-sequential-module"
title="Changes to sequential module">Changes to sequential
module</a></h3>
<p>First we import the library code that we wrote above in this
post:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="va">+import qualified ManagedThread2 as Scheduler</span></span></code></pre></div>
<p>Then we move the <code>runCommandMonad</code> method from the
<code>ParallelModel</code> class into the <code>StateModel</code> class
and change it so that it has access to the communication channel to the
scheduler (<code>Signal</code>):</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="va">+  runCommandMonad :: proxy state -&gt; CommandMonad state a -&gt; Scheduler.Signal -&gt; IO a</span></span></code></pre></div>
<p>We then change the <code>runCommands</code> function to use
<code>runCommandMonad</code> and use a single-threaded
<code>Signal</code>, i.e. one that doesn’t do any pauses:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a> runCommands :: forall state. StateModel state</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="st">-            =&gt; Commands state -&gt; PropertyM (CommandMonad state) ()</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="st">-runCommands (Commands cmds0) = go initialState emptyEnv cmds0</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="va">+            =&gt; Commands state -&gt; PropertyM IO ()</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="va">+runCommands (Commands cmds0) =</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="va">+  hoist (flip (runCommandMonad (Proxy :: Proxy state)) Scheduler.newSingleThreadedSignal) $</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="va">+    go initialState emptyEnv cmds0</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>   where</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>     go :: state -&gt; Env state -&gt; [Command state (Var (Reference state))]</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        -&gt; PropertyM (CommandMonad state) ()</span></code></pre></div>
<p>In order for this to typecheck we need a helper function that changes
the underlying monad of a <code>PropertyM</code> (QuickCheck’s monadic
properties):</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="va">+hoist :: Monad m =&gt; (forall x. m x -&gt; IO x) -&gt; PropertyM m a -&gt; PropertyM IO a</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="va">+hoist nat (MkPropertyM f) = MkPropertyM $ \g -&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="va">+  let</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="va">+    MkGen h = f (fmap (fmap (return . ioProperty)) g)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="va">+  in</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="va">+    MkGen (\r n -&gt; nat (h r n))</span></span></code></pre></div>
</section>
<section id="changes-to-parallel-module" class="level3">
<h3><a href="#changes-to-parallel-module"
title="Changes to parallel module">Changes to parallel module</a></h3>
<p>Again we import the deterministic scheduler that we defined in this
post:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="va">+import qualified ManagedThread2 as Scheduler</span></span></code></pre></div>
<p>As we said above, the <code>runCommandMonad</code> method was moved
into the sequential testing module:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="st">-  runCommandMonad :: proxy state -&gt; CommandMonad state a -&gt; IO a</span></span></code></pre></div>
<p>We’ll reuse QuickCheck’s seed for our scheduler, the following helper
function extracts the seed from QuickCheck’s <code>PropertyM</code>:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="va">+getSeed :: PropertyM m QCGen</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="va">+getSeed = MkPropertyM (\f -&gt; MkGen (\r n -&gt; unGen (f r) r n))</span></span></code></pre></div>
<p>We now have all the pieces we need to rewrite
<code>runParallelCommands</code> to use the deterministic scheduler:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a> runParallelCommands :: forall state. ParallelModel state</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>                     =&gt; ParallelCommands state -&gt; PropertyM IO ()</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a> runParallelCommands cmds0@(ParallelCommands forks0) = do</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="va">+  gen &lt;- getSeed</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="va">+  liftIO (putStrLn (&quot;Seed: &quot; ++ show gen))</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>   forM_ (parallelCommands cmds0) $ \cmd -&gt; do</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>     let name = commandName cmd</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>     monitor (tabulate &quot;Commands&quot; [name] . classify True name)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>   monitor (tabulate &quot;Concurrency&quot; (map (show . length . unFork) forks0))</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>   q   &lt;- liftIO newTQueueIO</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>   c   &lt;- liftIO newAtomicCounter</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="st">-  env &lt;- liftIO (runForks q c emptyEnv forks0)</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="va">+  env &lt;- liftIO (runForks q c emptyEnv gen forks0)</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>   hist &lt;- History &lt;$&gt; liftIO (atomically (flushTQueue q))</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>   let ok = linearisable env (interleavings hist)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>   unless ok (monitor (counterexample (show hist)))</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>   assert ok</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>   where</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a><span class="st">-    runForks :: TQueue (Event state) -&gt; AtomicCounter -&gt; Env state -&gt; [Fork state]</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="st">-             -&gt; IO (Env state)</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a><span class="st">-    runForks _q _c env [] = return env</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a><span class="st">-    runForks  q  c env (Fork cmds : forks) = do</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a><span class="st">-      envs &lt;- liftIO $</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a><span class="st">-        mapConcurrently (runParallelReal q c env) (zip [Pid 0..] cmds)</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="va">+    runForks :: RandomGen g =&gt; TQueue (Event state) -&gt; AtomicCounter -&gt; Env state -&gt; g</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="va">+             -&gt; [Fork state] -&gt; IO (Env state)</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a><span class="va">+    runForks _q _c env _gen [] = return env</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a><span class="va">+    runForks  q  c env gen (Fork cmds : forks) = do</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a><span class="va">+      (envs, gen&#39;) &lt;- liftIO $</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a><span class="va">+        Scheduler.mapConcurrently (runParallelReal q c env) (zip [Pid 0..] cmds) gen</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>       let env&#39; = combineEnvs (env : envs)</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a><span class="st">-      runForks q c env&#39; forks</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a><span class="va">+      runForks q c env&#39; gen&#39; forks</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>     runParallelReal :: TQueue (Event state) -&gt; AtomicCounter -&gt; Env state</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a><span class="st">-                    -&gt; (Pid, Command state (Var (Reference state))) -&gt; IO (Env state)</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a><span class="st">-    runParallelReal q c env (pid, cmd) = do</span></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a><span class="va">+                    -&gt; Scheduler.Signal -&gt; (Pid, Command state (Var (Reference state))) -&gt; IO (Env state)</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a><span class="va">+    runParallelReal q c env signal (pid, cmd) = do</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>       atomically (writeTQueue q (Invoke pid cmd))</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a><span class="st">-      eResp &lt;- try (runCommandMonad (Proxy :: Proxy state) (runReal (fmap (lookupEnv env) cmd)))</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a><span class="va">+      eResp &lt;- try (runCommandMonad (Proxy :: Proxy state) (runReal (fmap (lookupEnv env) cmd)) signal)</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>       case eResp of</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>         Left (err :: SomeException) -&gt;</span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>           error (&quot;runParallelReal: &quot; ++ displayException err)</span></code></pre></div>
</section>
<section id="changes-to-the-counter-example" class="level3">
<h3><a href="#changes-to-the-counter-example"
title="Changes to the counter example">Changes to the counter
example</a></h3>
<div class="sourceCode" id="cb26"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="va">+import qualified ManagedThread2 as Scheduler</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="st">-incrRaceCondition :: IO ()</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="st">-incrRaceCondition = do</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="st">-  n &lt;- readIORef gLOBAL_COUNTER</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="st">-  threadDelay 100</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="st">-  writeIORef gLOBAL_COUNTER (n + 1)</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="st">-  threadDelay 100</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="va">+incrRaceCondition :: Scheduler.SharedMemory Int -&gt; IO ()</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="va">+incrRaceCondition mem = do</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="va">+  n &lt;- liftIO (Scheduler.memReadIORef mem gLOBAL_COUNTER)</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="va">+  Scheduler.memWriteIORef mem gLOBAL_COUNTER (n + 1)</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="st">-get :: IO Int</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="st">-get = readIORef gLOBAL_COUNTER</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="va">+get :: Scheduler.SharedMemory Int -&gt; IO Int</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="va">+get mem = Scheduler.memReadIORef mem gLOBAL_COUNTER</span></span></code></pre></div>
<div class="sourceCode" id="cb28"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="va">+  type CommandMonad Counter = ReaderT Scheduler.Signal IO</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="va">+</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>   -- We also need to explain which part of the counter API each command</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>   -- corresponds to.</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="st">-  runReal :: Command Counter r -&gt; IO (Response Counter r)</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="st">-  runReal Get  = Get_  &lt;$&gt; get</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="st">-  runReal Incr = Incr_ &lt;$&gt; incrRaceCondition</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="va">+  runReal :: Command Counter r -&gt; ReaderT Scheduler.Signal IO (Response Counter r)</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="va">+  runReal cmd = do</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="va">+    sig &lt;- ask</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="va">+    let mem = Scheduler.fakeMem sig</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="va">+    case cmd of</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="va">+      Get  -&gt; liftIO (Get_  &lt;$&gt; get mem)</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="va">+      Incr -&gt; liftIO (Incr_ &lt;$&gt; incrRaceCondition mem)</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="va">+  runCommandMonad _ m sig = runReaderT m sig</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="va">+</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a> prop_counter :: Commands Counter -&gt; Property</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a> prop_counter cmds = monadicIO $ do</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="st">-  run reset</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="va">+  liftIO reset</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>   runCommands cmds</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>   assert True</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="st">-instance ParallelModel Counter where</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="st">-</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="st">-  -- The command monad is IO, so we don&#39;t need to do anything here.</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="st">-  runCommandMonad _ = id</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="va">+instance ParallelModel Counter</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a> prop_parallelCounter :: ParallelCommands Counter -&gt; Property</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a> prop_parallelCounter cmds = monadicIO $ do</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="st">-  replicateM_ 10 $ do</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="st">-    run reset</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="st">-    runParallelCommands cmds</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="va">+  run reset</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="va">+  runParallelCommands cmds</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>   assert True</span></code></pre></div>
</section>
</section>
<section id="conclusion-and-further-work" class="level2">
<h2><a href="#conclusion-and-further-work"
title="Conclusion and further work">Conclusion and further work</a></h2>
<ul>
<li><p>some seeds don’t give the minimal counterexample, shrinking can
be improved as already pointed out in my previous post</p></li>
<li><p>enumarate all interleavings upto some depth, model checking
style, perhaps using smallcheck? Compare to dejafu library</p></li>
<li><p>rewrite into proper library?</p></li>
<li><p>while this approach works in all languages due to its white-box
nature, what would it take to have a black-box approach that’s
deterministic?</p>
<ul>
<li>intercept syscalls rr (and hermit?)</li>
<li>hypervisor (Antithesis)</li>
<li>language support for user schedulers</li>
</ul></li>
</ul>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>If you haven’t heard of <a
href="https://martinfowler.com/bliki/TestDouble.html">fakes</a> before,
think of them as a more elaborate test double than a mock. A mock of a
component expects to be called in some particular way (i.e. exposes only
some limited subset of the components API), and typically throw an
expeception when called in any other way. While a fake exposes the full
API and can be called just like the real component, but unlike the real
component it takes some shortcuts. For example a fake might lose all
data when restarted (i.e. keeps all data in memory, while the real
component persists the data to some stable storage).<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The reason for shrinking not working so well with
non-determinism is because shrinking stops when the property passes. So
if some input causes the property to fail and then we rerun the property
on a smaller input it might be the case that the smaller input still
contains the race condition, but because the interleaving of threads is
non-deterministic we are unlucky and the race condition isn’t triggered
and the property passes, which stops the shrinking process.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Jepsen’s <a
href="https://aphyr.com/posts/314-computational-techniques-in-knossos">Knossos
checker</a> also uses linearisability checking and has found many <a
href="https://jepsen.io/analyses">bugs</a>, so we are in good
company.</p>
<p>Note that the most recent Jepsen analyses use the <a
href="https://github.com/jepsen-io/elle">Elle checker</a>, rather than
the Knossos checker. The Elle checker doesn’t do linearisability
checking, but rather looks for cycles in the dependencies of database
transactions. Checking for cycles is less general than linearisability
checking, but also more efficient. See the Elle <a
href="https://github.com/jepsen-io/elle/raw/master/paper/elle.pdf">paper</a>
for details.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
