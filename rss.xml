<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stevan's notes</title>
    <description>Collection of notes on distributed systems.</description>
    <language>en</language>
    <link>https://stevana.github.io/rss.xml</link>
    <atom:link href="https://stevana.github.io/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The sad state of property-based testing libraries</title>
      <link>https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html</link>
      <guid>https://stevana.github.io/the_sad_state_of_property-based_testing_libraries.html</guid>
      <pubDate>Tue, 2 Jul 2024 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>The sad state of property-based testing libraries</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#the-history-of-property-based-testing"
id="toc-the-history-of-property-based-testing">The history of
property-based testing</a></li>
<li><a href="#a-survey-of-property-based-testing-libraries"
id="toc-a-survey-of-property-based-testing-libraries">A survey of
property-based testing libraries</a></li>
<li><a href="#analysis" id="toc-analysis">Analysis</a>
<ul>
<li><a
href="#why-are-property-based-testing-libraries-in-such-a-sad-state"
id="toc-why-are-property-based-testing-libraries-in-such-a-sad-state">Why
are property-based testing libraries in such a sad state?</a>
<ul>
<li><a
href="#stateful-and-parallel-testing-isnt-as-useful-as-pure-testing"
id="toc-stateful-and-parallel-testing-isnt-as-useful-as-pure-testing">Stateful
and parallel testing isn’t as useful as pure testing</a></li>
<li><a href="#stateful-modelling-requires-training"
id="toc-stateful-modelling-requires-training">Stateful modelling
requires training</a></li>
<li><a href="#closed-source-helps-industry-adoption"
id="toc-closed-source-helps-industry-adoption">Closed source helps
industry adoption</a></li>
</ul></li>
<li><a href="#what-can-we-do-about-it"
id="toc-what-can-we-do-about-it">What can we do about it?</a></li>
</ul></li>
<li><a href="#synthesis" id="toc-synthesis">Synthesis</a>
<ul>
<li><a href="#pure-property-based-testing-recap"
id="toc-pure-property-based-testing-recap">Pure property-based testing
recap</a></li>
<li><a href="#stateful-property-based-testing"
id="toc-stateful-property-based-testing">Stateful property-based
testing</a>
<ul>
<li><a href="#example-counter" id="toc-example-counter">Example:
counter</a></li>
<li><a href="#stateful-library-implementation"
id="toc-stateful-library-implementation">Stateful library
implementation</a></li>
<li><a href="#example-circular-buffer"
id="toc-example-circular-buffer">Example: circular buffer</a></li>
<li><a href="#example-jug-puzzle-from-die-hard-3"
id="toc-example-jug-puzzle-from-die-hard-3">Example: jug puzzle from Die
Hard 3</a></li>
</ul></li>
<li><a href="#parallel-property-based-testing"
id="toc-parallel-property-based-testing">Parallel property-based
testing</a>
<ul>
<li><a href="#parallel-library-implementation"
id="toc-parallel-library-implementation">Parallel library
implementation</a></li>
<li><a href="#example-parallel-counter"
id="toc-example-parallel-counter">Example: parallel counter</a></li>
<li><a href="#example-process-registry"
id="toc-example-process-registry">Example: process registry</a></li>
</ul></li>
<li><a href="#integration-testing-with-contract-tested-fakes"
id="toc-integration-testing-with-contract-tested-fakes">Integration
testing with contract tested fakes</a>
<ul>
<li><a href="#example-queue-again" id="toc-example-queue-again">Example:
queue (again)</a></li>
<li><a href="#example-file-system" id="toc-example-file-system">Example:
file system</a></li>
<li><a href="#example-bigger-system-of-components"
id="toc-example-bigger-system-of-components">Example: bigger system of
components</a></li>
</ul></li>
</ul></li>
<li><a href="#conclusion-and-future-work"
id="toc-conclusion-and-future-work">Conclusion and future work</a></li>
<li><a href="#acknowledgments"
id="toc-acknowledgments">Acknowledgments</a></li>
</ul>
</nav>
<div class="date">Posted on Jul  2, 2024</div>
<p>Property-based testing is a rare example of academic research that
has made it to the mainstream in less than 30 years. Under the slogan
“don’t write tests, generate them” property-based testing has gained
support from a diverse group of programming language communities. In
fact, the Wikipedia page of the original property-basted testing Haskell
library, <a
href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a>, lists 57
reimplementations in other languages.</p>
<p>In this post I’d like to survey the most popular property-based
testing implementations and compare them with what used to be the
state-of-the-art fifteen years ago (2009). As the title already gives
away, most of the libraries do not offer their users the most advanced
property-based testing features. In order to best explain what’s missing
and why I think we ended up in this situation, let me start by telling
the brief history of property-based testing.</p>
<section id="the-history-of-property-based-testing" class="level2">
<h2><a href="#the-history-of-property-based-testing"
title="The history of property-based testing">The history of
property-based testing</a></h2>
<p>In Gothenburg, Sweden’s second most populated city, there’s a
university called Chalmers. At the computer science department of
Chalmers there are several research groups, two of which are
particularly relevant to our story – the <em>Functional Programming</em>
group and <em>Programming Logic</em> group. I’ll let you guess what the
former group’s main interest is. The latter group’s mostly concerned
with a branch of functional programming where the type system is
sufficiently expressive that it allows for formal specifications of
programs, sometimes called dependently typed programming or type theory.
Agda is an example of a Haskell-like dependently typed programming
language, that also happens to be mainly developed by the Programming
Logic group. Given the overlap of interest and proximity, researchers at
the department are sometimes part of both groups or at least visit each
others research seminars from time to time.</p>
<p>John Hughes is a long-time member of the Functional Programming
group, who’s also well aware of the research on dependently typed
programming going on in the Programming Logic group. One day in the late
nineties, after having worked hard on finishing something important on
time, John found himself having a week “off”. So, just for fun, he
started experimenting with the idea of testing if a program respects a
formal specification.</p>
<p>Typically in dependently typed programming you use the types to write
the specification and then the program that implements that type is the
formal proof that the program is correct. For example, let’s say you’ve
implemented a list sorting function, the specification typically then is
that the output of the sorting function is ordered, i.e. for any index
<span class="math inline"><em>i</em></span> in your output list the
element at that index must be smaller or equal to the element at index
<span class="math inline"><em>i</em> + 1</span>. Formally proving that a
program is correct with respect to a specification is often as much work
as writing the program in the first place, so merely testing it can
often be a sweet spot where you get some confidence that the
specification is correct, without having to do the proving work. For
example in the sorting example you can simply generate a random input
list and then compare the output of your sorting function with the one
in the standard library (which is likely to be correct). As programs get
more complicated the ratio of effort saved by merely testing, as opposed
to proving, increases. In fact for bigger programs the effort involved
in proving correctness is simply too high for it to be practical (this
is an active area of research). Given all this, I hope that you can
start to see why this idea excited John.</p>
<p>While John was working on this idea, Koen Claessen, another member of
the Functional Programming group, <a
href="https://youtu.be/x4BNj7mVTkw?t=289">stuck his head</a> into John’s
office and asked what he was doing. Koen got excited as well and came
back the next day with his improved version of John’s code. There was
some things that Koen hadn’t thought about, so John iterated on his code
and so it went back and forth for a week until the first implementation
of property-based testing was written and not long afterwards they
published the paper <a
href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf"><em>QuickCheck:
A Lightweight Tool for Random Testing of Haskell Programs</em></a> (ICFP
2000). I think it’s worth stressing the <em>lightweight tool</em> part
from the paper’s title, the complete source code for the <a
href="https://github.com/Rewbert/quickcheck-v1">first version</a> of the
library is included in the appendix of the paper and it’s about 300
lines of code.</p>
<p>Haskell and dependently typed programming languages, like Agda, are
pure functional programming languages, meaning that it’s possible at the
type-level to distinguish whether a function has side-effects or not.
Proofs about functions in Agda, and similar languages, are almost always
only dealing with pure functions. Probably as a result of this, the
first version of QuickCheck can only test pure functions. This
shortcoming was rectified in the follow up paper <a
href="https://www.cse.chalmers.se/~rjmh/Papers/QuickCheckST.ps"><em>Testing
monadic code with QuickCheck</em></a> (2002) by the same authors. It’s
an important extension as it allows us to reason about functions that
use mutable state, file I/O and networking, etc. It also lays the
foundation for being able to test concurrent programs, as we shall see
below.</p>
<p>Around the same time as the second paper was published (2002), John
was applying for a major grant at the Swedish Strategic Research
Foundation. A part of the application process involved pitching in front
of a panel of people from industry. Some person from <a
href="https://en.wikipedia.org/wiki/Ericsson">Ericsson</a> was on the
panel and they were interested in QuickCheck. There was also a serial
entrepreneur on the panel and she encouraged John to start a company,
and the Ericsson person agreed to be a first customer, and so Quviq AB
was founded in 2006<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> by John and Thomas Arts (perhaps
somewhat surprisingly, Koen was never involved in the company).</p>
<p>The first project at Ericsson that Quviq helped out testing was
written in Erlang. Unlike Haskell, Erlang is not a pure functional
programming language and on top of that there’s concurrency everywhere.
So even the second, monadic, version of QuickCheck didn’t turn out to be
ergonomic enough for the job. This is what motivated the closed source
Quviq QuickCheck version written in Erlang, first mentioned in the paper
<a
href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=b268715b8c0bcebe53db857aa2d7a95fbb5c5dbf"><em>Testing
telecoms software with Quviq QuickCheck</em></a> (2006). The main
features of the closed source version that, as we shall see, are still
not found in many open source versions are:</p>
<ol type="1">
<li>Sequential <em>stateful</em> property-based testing using a state
machine model;</li>
<li><em>Parallel</em> testing with race condition detection by reusing
the sequential state machine model.</li>
</ol>
<p>We shall describe how these features work in detail later. For now
let’s just note that <em>stateful</em> testing in its current form was
first mentioned in <a
href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5ae25681ff881430797268c5787d7d9ee6cf542c"><em>QuickCheck
testing for fun and profit</em></a> (2007). This paper also mentions
that it took John four iterations to get the stateful testing design
right, so while the 2006 paper already does mention stateful testing
it’s likely containing one of those earlier iteration of it.</p>
<p>While the 2007 paper also mentions <em>parallel</em> testing via
traces and interleavings, it’s vague on details. It’s only later in <a
href="https://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf"><em>Finding
Race Conditions in Erlang with QuickCheck and PULSE</em></a> (ICFP 2009)
that parallel testing is described in detail including a reference to <a
href="https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf"><em>Linearizability:
a correctness condition for concurrent objects</em></a> by Herlihy and
Wing (1990) which is the main technique behind it.</p>
<p>I’d like to stress that no Quviq QuickCheck library code is ever
shared in any of these papers, they only contain the library APIs (which
are public) and test examples implemented using said APIs.</p>
<p>After that most papers are experience reports of applying Quviq
QuickCheck at different companies, e.g. <em>Testing A Database for Race
Conditions with QuickCheck</em> (2011), <a
href="https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"><em>Testing
the hard stuff and staying sane</em></a> (2014), <em>Testing AUTOSAR
software with QuickCheck</em> (2015), <em>Mysteries of Dropbox:
Property-Based Testing of a Distributed Synchronization Service</em>
(2016).</p>
<p>Sometimes various minor extensions to stateful and parallel testings
are needed in order to test some particular piece of software, e.g. C
FFI bindings in the case of AUTOSAR or eventual consistency in the case
of Dropbox, but by and large the stateful and parallel testing features
remain the same.</p>
</section>
<section id="a-survey-of-property-based-testing-libraries"
class="level2">
<h2><a href="#a-survey-of-property-based-testing-libraries"
title="A survey of property-based testing libraries">A survey of
property-based testing libraries</a></h2>
<p>As we’ve seen above, the current state-of-the-art when it comes to
property-based testing is <em>stateful</em> testing via a state machine
model and reusing the same sequential state machine model combined with
linearisability to achieve <em>parallel</em> testing.</p>
<p>Next let’s survey the most commonly used property-based testing
libraries to see how well supported these two testing features are. Let
me be clear up front that I’ve not used all of these libraries. My
understanding comes from reading the documentation, issue tracker and
sometimes source code.</p>
<p>To my best knowledge, as of July 2024, the following table summarises
the situation. Please open an <a
href="https://github.com/stevana/stateful-pbt-with-fakes/issues">issue</a>,
PR, or get in <a href="https://stevana.github.io/about.html">touch</a>
if you see a mistake or an important omission.</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 1%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Library</th>
<th style="text-align: left;">Language</th>
<th style="text-align: center;">Stateful</th>
<th style="text-align: center;">Parallel</th>
<th style="text-align: left;">Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">CsCheck</td>
<td style="text-align: left;">C#</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Eris</td>
<td style="text-align: left;">PHP</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">FsCheck</td>
<td style="text-align: left;">F#</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Has experimental <a
href="https://fscheck.github.io/FsCheck//StatefulTestingNew.html">stateful
testing</a>. An <a
href="https://github.com/fscheck/FsCheck/issues/214">issue</a> to add
parallel support has been open since 2016.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Gopter</td>
<td style="text-align: left;">Go</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">The README says “No parallel commands …
yet?” and there’s an open <a
href="https://github.com/leanovate/gopter/issues/20">issue</a> from
2017.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Hedgehog</td>
<td style="text-align: left;">Haskell</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;">Has parallel support, but the
implementation has <a
href="https://github.com/hedgehogqa/haskell-hedgehog/issues/104">issues</a>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Hypothesis</td>
<td style="text-align: left;">Python</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">PropEr</td>
<td style="text-align: left;">Erlang</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;">First open source library to support
both?</td>
</tr>
<tr class="even">
<td style="text-align: left;">QuickCheck</td>
<td style="text-align: left;">Haskell</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/nick8325/quickcheck/issues/139">issue</a> to
add stateful testing since 2016.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">QuickTheories</td>
<td style="text-align: left;">Java</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Has <a
href="https://github.com/quicktheories/QuickTheories/issues/42">experimental</a>
for stateful testing, there’s also some parallel testing, but it’s
inefficient and restrictive compared to QuviQ’s Erlang version of
QuickCheck. From the <a
href="https://github.com/quicktheories/QuickTheories/blob/a963eded0604ab9fe1950611a64807851d790c1c/core/src/main/java/org/quicktheories/core/stateful/Parallel.java#L35">source
code</a>: “Supplied commands will first be run in sequence and compared
against the model, then run concurrently. All possible valid end states
of the system will be calculated, then the actual end state compared to
this. As the number of possible end states increases rapidly with the
number of commands, command lists should usually be constrained to 10 or
less.”</td>
</tr>
<tr class="even">
<td style="text-align: left;">Rapid</td>
<td style="text-align: left;">Go</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">RapidCheck</td>
<td style="text-align: left;">C++</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/emil-e/rapidcheck/issues/47">issue</a> to add
parallel support from 2015.</td>
</tr>
<tr class="even">
<td style="text-align: left;">ScalaCheck</td>
<td style="text-align: left;">Scala</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Has some support for parallel testing, but
it’s limited as can be witnessed by the fact that the two <a
href="https://github.com/typelevel/scalacheck/tree/19af6eb656ba759980664e29ec6ae3e063021685/examples">examples</a>
of testing LevelDB and Redis both are sequential
(<code>threadCount = 1</code>).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Supposition</td>
<td style="text-align: left;">Julia</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">The stateful testing lacks a proper <a
href="https://github.com/Seelengrab/Supposition.jl/discussions/26">interface</a>
though.</td>
</tr>
<tr class="even">
<td style="text-align: left;">SwiftCheck</td>
<td style="text-align: left;">Swift</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/typelift/SwiftCheck/issues/149">issue</a> to
add stateful testing from 2016.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fast-check</td>
<td style="text-align: left;">TypeScript</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Has <a
href="https://fast-check.dev/docs/advanced/race-conditions/">some
support</a> for race condition checking, but it seems different from
Quviq QuickCheck’s parallel testing. In particular it doesn’t seem to
reuse the sequential state machine model nor use linearisability.</td>
</tr>
<tr class="even">
<td style="text-align: left;">jetCheck</td>
<td style="text-align: left;">Java</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">From the source code “Represents an action
with potential side effects, for single-threaded property-based testing
of stateful systems.”.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">jqwik</td>
<td style="text-align: left;">Java</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">jsverify</td>
<td style="text-align: left;">JavaScript</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/jsverify/jsverify/issues/148">issue</a> to add
stateful testing from 2015.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lua-quickcheck</td>
<td style="text-align: left;">Lua</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">propcheck</td>
<td style="text-align: left;">Elixir</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">There’s an open <a
href="https://github.com/alfert/propcheck/issues/148">issue</a> to add
parallel testing from 2020.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">proptest</td>
<td style="text-align: left;">Rust</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">See proptest-state-machine.</td>
</tr>
<tr class="even">
<td style="text-align: left;">proptest-state-machine</td>
<td style="text-align: left;">Rust</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Documentation says “Currently, only
sequential strategy is supported, but a concurrent strategy is planned
to be added at later point.”.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">qcheck-stm</td>
<td style="text-align: left;">OCaml</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">quickcheck</td>
<td style="text-align: left;">Prolog</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">quickcheck</td>
<td style="text-align: left;">Rust</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Issue to add stateful testing has been <a
href="https://github.com/BurntSushi/quickcheck/issues/134">closed</a>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">quickcheck-state-machine</td>
<td style="text-align: left;">Haskell</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;">Second open source library with parallel
testing support? (I was <a
href="https://github.com/nick8325/quickcheck/issues/139#issuecomment-272439099">involved</a>
in the development.)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rackcheck</td>
<td style="text-align: left;">Racket</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">rantly</td>
<td style="text-align: left;">Ruby</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">stateful-check</td>
<td style="text-align: left;">Clojure</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☒</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">test.check</td>
<td style="text-align: left;">Clojure</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;">Someone has implemented stateful testing
in a blog <a
href="http://blog.guillermowinkler.com/blog/2015/04/12/verifying-state-machine-behavior-using-test-dot-check/">post</a>
though.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">test.contract</td>
<td style="text-align: left;">Clojure</td>
<td style="text-align: center;">☒</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">theft</td>
<td style="text-align: left;">C</td>
<td style="text-align: center;">☐</td>
<td style="text-align: center;">☐</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</section>
<section id="analysis" class="level2">
<h2><a href="#analysis" title="Analysis">Analysis</a></h2>
<p>By now I hope that I’ve managed to convince you that most
property-based testing libraries do not implement what used to be the
state-of-the-art fifteen years ago.</p>
<p>Many libraries lack stateful testing via state machines and most lack
parallel testing support. Often users of the libraries have opened
tickets asking for these features, but the tickets have stayed open for
years without any progress. Furthermore it’s not clear to me whether all
libraries that support stateful testing can be generalised to parallel
testing without a substantial redesign of their APIs. I don’t think
there’s a single example of a library to which parallel testing was
added later, rather than designed for from the start.</p>
<section
id="why-are-property-based-testing-libraries-in-such-a-sad-state"
class="level3">
<h3><a
href="#why-are-property-based-testing-libraries-in-such-a-sad-state"
title="Why are property-based testing libraries in such a sad state?">Why
are property-based testing libraries in such a sad state?</a></h3>
<p>Here are three reasons I’ve heard from John:</p>
<ol type="1">
<li><p>The stateful and parallel testing features are not as useful as
testing pure functions. This is what John told me when I asked him why
these features haven’t taken off in the context of Haskell (BobKonf
2017);</p></li>
<li><p>The state machine models that one needs to write for the stateful
and parallel testing require a different way of thinking compared to
normal testing. One can’t merely give these tools to new users without
also giving them proper training, John said in an <a
href="https://youtu.be/x4BNj7mVTkw?t=898">interview</a>;</p></li>
<li><p>Open source didn’t work, a closed source product and associated
services <a
href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5ae25681ff881430797268c5787d7d9ee6cf542c">helps</a>
adoption:</p>
<blockquote>
<p>“Thomas Arts and I have founded a start-up, Quviq AB, to develop and
market Quviq QuickCheck. Interestingly, this is the second
implementation of QuickCheck for Erlang. The first was presented at the
Erlang User Conference in 2003, and made available on the web. Despite
enthusiasm at the conference, it was never adopted in industry. We tried
to give away the technology, and it didn’t work! So now we are selling
it, with considerably more success. Of course, Quviq QuickCheck is no
longer the same product that was offered in 2003—it has been improved in
many ways, adapted in the light of customers’ experience, extended to be
simpler to apply to customers’ problems, and is available together with
training courses and consultancy. That is, we are putting a great deal
of work into helping customers adopt the technology. It was naive to
expect that simply putting source code on the web would suffice to make
that happen, and it would also be unreasonable to expect funding
agencies to pay for all the work involved. In that light, starting a
company is a natural way for a researcher to make an impact on
industrial practice—and so far, at least, it seems to be
succeeding.”</p>
</blockquote></li>
</ol>
<p>A cynic might argue that there’s a conflict of interest between doing
research and education on one hand and running a company that sells
licenses, training and consulting on the other.</p>
<p>Let me be clear that I’ve the utmost respect for John, and I believe
what he says to be true and I believe he acts with the best intentions.
Having said that let me try to address John’s points.</p>
<section
id="stateful-and-parallel-testing-isnt-as-useful-as-pure-testing"
class="level4">
<h4><a
href="#stateful-and-parallel-testing-isnt-as-useful-as-pure-testing"
title="Stateful and parallel testing isn’t as useful as pure testing">Stateful
and parallel testing isn’t as useful as pure testing</a></h4>
<p>I think many people will agree that separating pure from
side-effectful code is good practice in any programming language, and I
do agree with John that you can get far by merely property-based testing
those pure fragments.</p>
<p>However, I also think that stateful and parallel testing is almost
equally important for many non-trivial software systems. Most systems in
industry will have some database, stateful protocol or use concurrent
data structures, which all benefit from the stateful and parallel
testing features.</p>
</section>
<section id="stateful-modelling-requires-training" class="level4">
<h4><a href="#stateful-modelling-requires-training"
title="Stateful modelling requires training">Stateful modelling requires
training</a></h4>
<p>Regarding formal specification requiring a special way of thinking
and therefor training, I believe this is a correct assessment. However I
also believe that this is already true for property-based testing of
pure functions. A non-trained user of pure property-based testing will
likely test less interesting properties than someone who’s trained.</p>
<p>Given that John has written <a
href="https://research.chalmers.se/publication/517894/file/517894_Fulltext.pdf">papers</a>
and given <a
href="https://www.youtube.com/watch?v=NcJOiQlzlXQ">talks</a> on the
topic of making property-based testing of pure functions more accessible
to programmers, one might wonder why we cannot do the same for stateful
and parallel testing?</p>
<p>The experience reports, that we’ve mentioned above, usually contain
some novelty (which warrants publishing a new paper) rather than general
advice which can be done with the vanilla stateful and parallel testing
features. Furthermore they require buying a Quviq license in order to
reproduce the results, a show stopper for many people.</p>
<p>I think it’s also worth stressing that stateful specifications are
not necessarily always more difficult than specifications for pure
functions. For example, to model a key-value store one can get quite far
with the model being a list of key-value pairs. In fact a simple model
like that managed to find a 17 step (shrunk) counterexample in LevelDB
to a known <a
href="https://github.com/google/leveldb/issues/50">issue</a>, within
mere minutes. It took weeks for Google to provide a fix, and then after
running the property again on the fixed code a new 31 step
counterexample was found within minutes. Turns out there was a bug in
the background compaction process. The compaction process improves read
performance and reclaims disk space, which is important for a key-value
store, but interestingly it’s not explicitly part of the model. Joseph W
Norton gave a <a
href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/strangeloop/lambdajam2013/master/slides/Norton-QuickCheck.html">talk</a>
at LambdaJam 2013 about it.</p>
</section>
<section id="closed-source-helps-industry-adoption" class="level4">
<h4><a href="#closed-source-helps-industry-adoption"
title="Closed source helps industry adoption">Closed source helps
industry adoption</a></h4>
<p>Regarding keeping the source closed helping with adoption, I think
this is perhaps the most controversial point that John makes.</p>
<p>If we try to see it from John’s perspective, how else would an
academic get funding to work on tooling (which typically isn’t
recognised as doing research), or feedback from industry? Surely, one
cannot expect research funding agencies to pay for this?</p>
<p>On the other hand one could ask why there isn’t a requirement that
published research should be reproducible using open source tools (or at
least tools that are freely available to the public and other
researchers)? Trying to replicate the results from the Quviq QuickCheck
papers (from 2006 and onward) without buying a Quviq QuickCheck license,
is almost impossible without a lot of reverse engineering work.</p>
<p>I suppose one could argue that one could have built a business around
an open source tool, only charging for the training and consulting, but
given how broken open source is today, unless you are a big company
(which takes more than it gives back), it’s definitely not clear that it
would have worked (and it was probably even worse back in 2006).</p>
<p>Even if John is right and that keeping it closed source has helped
adoption in industry, I think it’s by now fair to say it has not helped
open source adoption. Or perhaps another way to look at it, it’s
unlikely that a company that pays for a license in Erlang would then go
and port the library in another language.</p>
</section>
</section>
<section id="what-can-we-do-about-it" class="level3">
<h3><a href="#what-can-we-do-about-it"
title="What can we do about it?">What can we do about it?</a></h3>
<p>I think there’s at least two things worth trying.</p>
<ol type="1">
<li><p>Provide a short open source implementation of stateful and
parallel property-based testing, analogous to the original ~300 lines of
code QuickCheck implementation.</p>
<p>Perhaps part of the original QuickCheck library’s success in
spreading to so many other languages can be attributed to the fact that
its small implementation and that it is part of the original
paper?</p></li>
<li><p>Try to make the formal specification part easier, so that we
don’t need to train developers (as much).</p>
<p>Perhaps we can avoid state machines as basis for specifications and
instead reuse concepts that programmers are already familiar with from
their current testing activities, e.g. mocking and test doubles more
generally?</p></li>
</ol>
</section>
</section>
<section id="synthesis" class="level2">
<h2><a href="#synthesis" title="Synthesis">Synthesis</a></h2>
<p>In order to test the above hypothesis, I’d like to spend the rest of
this post as follows:</p>
<ol type="1">
<li><p>Show how one can implement stateful and parallel property-based
testing in about 400 lines of code (similar to the size of the original
QuickCheck implementation);</p></li>
<li><p>Make specifications simpler by using in-memory reference
implementations similar to mocks, more accurately called <a
href="https://martinfowler.com/bliki/TestDouble.html">fakes</a>, rather
than state machines.</p></li>
</ol>
<p>Before we get started with stateful testing, let’s first recap how
property-based testing of pure functions works.</p>
<section id="pure-property-based-testing-recap" class="level3">
<h3><a href="#pure-property-based-testing-recap"
title="Pure property-based testing recap">Pure property-based testing
recap</a></h3>
<p>It’s considered good practice to test new functions or functionality,
to make sure it does what we want. For example, imagine we’ve written a
linked-list reversal function called <code>reverse</code>, then it might
be sensible to test it against a couple of lists such as the empty list
and, say, the three element list <code>[1, 2, 3]</code>.</p>
<p>How does one choose which example inputs to test against though?
Typically one wants to choose corner cases, such as the empty list, that
perhaps were overlooked during the implementation. It’s difficult to
think of corner cases that you might have overlooked (because if you can
then you probably wouldn’t have overlooked them in the first place)!
This is where generating random inputs, a key feature of property-based
testing, comes in. The idea being that random inputs will eventually hit
corner cases.</p>
<p>When we manually pick inputs for our tests, like
<code>[1, 2, 3]</code>, we know what the output should be and so we can
make the appropriate assertion,
i.e. <code>reverse [1, 2, 3] == [3, 2, 1]</code>. When we generate
random inputs we don’t always know what the output should be. This is
where writing properties that relate the output to the input somehow
comes in. For example, while we don’t know what the output of reversing
an arbitrary list is, we do know that reversing it twice will give back
the input. This is how we can express this property in QuickCheck:</p>
<pre><code>&gt;&gt;&gt; quickCheck (\(xs :: [Int]) -&gt; reverse (reverse xs) == xs)
+++ OK, passed 100 tests.</code></pre>
<p>By default 100 tests get generated, but that can be adjusted:</p>
<pre><code>&gt;&gt;&gt; quickCheck (withMaxSuccess 5 (\(xs :: [Int]) -&gt; reverse (reverse xs) == xs))
+++ OK, passed 5 tests.</code></pre>
<p>We can see what test get generated using
<code>verboseCheck</code>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> verboseCheck (withMaxSuccess <span class="dv">5</span> (\(<span class="ot">xs ::</span> [<span class="dt">Int</span>]) <span class="ot">-&gt;</span> <span class="fu">reverse</span> (<span class="fu">reverse</span> xs) <span class="op">==</span> xs))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="dt">Passed</span><span class="op">:</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">4</span>,<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">5</span> tests<span class="op">.</span></span></code></pre></div>
<p>Or by using <code>sample</code> on the appropriate
<code>Gen</code>erator. In this case we are generating lists of
integers, hence the <code>Gen [Int]</code> type annotation:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> sample (<span class="ot">arbitrary ::</span> <span class="dt">Gen</span> [<span class="dt">Int</span>])</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">4</span>]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,<span class="dv">6</span>,<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">6</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">7</span>,<span class="dv">5</span>,<span class="op">-</span><span class="dv">8</span>,<span class="dv">1</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">11</span>,<span class="dv">4</span>]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">11</span>]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>[<span class="op">-</span><span class="dv">3</span>,<span class="dv">17</span>,<span class="op">-</span><span class="dv">14</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">17</span>,<span class="dv">18</span>,<span class="op">-</span><span class="dv">8</span>,<span class="op">-</span><span class="dv">9</span>,<span class="op">-</span><span class="dv">13</span>,<span class="op">-</span><span class="dv">7</span>]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,<span class="dv">19</span>,<span class="dv">6</span>,<span class="dv">9</span>,<span class="op">-</span><span class="dv">15</span>,<span class="op">-</span><span class="dv">6</span>,<span class="op">-</span><span class="dv">19</span>]</span></code></pre></div>
<p>The list and integer generators are provided by the library and I
hope you agree that these seem like sensible arbitrary lists to use in
our tests.</p>
<p>Next let’s have a look at when a property fails. For example this is
what happens if we try to test that the output of reversing a list is
the input list:</p>
<pre><code>&gt;&gt;&gt; quickCheck (\(xs :: [Int]) -&gt; reverse xs == xs)
*** Failed! Falsified (after 3 tests and 2 shrinks):
[0,1]</code></pre>
<p>We see that after 3 tests a test case was generated that failed, the
input got shrunk twice and the minimal counterexample
<code>[0, 1]</code> is presented. Notice that we do need a list that is
at least of length two, because any shorter list will reverse to
itself.</p>
<p>As pointed out earlier, coming up with these properties is not easy.
There are however a few patterns that come up over and over again. With
<code>reverse</code> we saw an example of an involutory function, i.e.
<code>f (f x) == x</code>, here are a few other examples:</p>
<ul>
<li>Inverses,
e.g. <code>\(i :: Input) -&gt; deserialise (serialise i) == i</code>;</li>
<li>Idempotency,
e.g. <code>\(xs :: [Int]) -&gt; sort (sort xs) == sort xs</code>;</li>
<li>Associativity,
e.g. <code>\(i j k :: Int) -&gt; (i + j) + k == i + (j + k)</code>;</li>
<li>Axioms of abstract data types, e.g.
<code>\(x :: Int)(xs :: [Int]) -&gt; member x (insert x xs) &amp;&amp; not (member x (remove x xs))</code>;</li>
<li>Metamorphic properties, e.g.
<code>\(g :: Graph)(m n :: Node) -&gt; shortestPath g m n == shortestPath g n m</code>.</li>
</ul>
<p>Readers familiar with discrete math might recognise some of the
above.</p>
</section>
<section id="stateful-property-based-testing" class="level3">
<h3><a href="#stateful-property-based-testing"
title="Stateful property-based testing">Stateful property-based
testing</a></h3>
<p>In the pure property-based testing case, that we just looked at, the
picture of the test setup looks a bit like this:</p>
<pre><code>         +-----+
      i  |     |  o
    -----&gt;  f  +----&gt;
         |     |
         +-----+</code></pre>
<p>Where <code>i</code> is the input we generate, <code>f</code> is the
function we are applying the generated input to produce the output
<code>o</code>. In the case of the <code>reverse</code> example, from
before, <code>i</code> and <code>o</code> are of type list of integers
(<code>[Int]</code>), <code>f</code> is <code>reverse . reverse</code>
and the property that we check for every generated input is that input
is equal to the output.</p>
<p>Next let’s contrast this picture with how the test setup looks when
we are testing a stateful component. A simple example of a stateful
component is a counter with an <code>incr</code>ement operation which
increment the counter and returns the old count.</p>
<p>Unlike in the pure case, the same input will not give the same
output. For example the first time we do <code>incr</code> we get back
<code>0</code> (if we start counting from zero) while the second time we
do <code>incr</code> we get <code>1</code>. A database or a file system
are two other examples of stateful components, where the history of
previous inputs affects the output of the next input.</p>
<p>In the stateful case, the picture looks more like this:</p>
<pre><code>    +------+     +------+     +------+
    |      | i1  |      | i2  |      |
    |  s0  +-----&gt;  s1  +-----&gt;  s2  | ...
    |      |     |      |     |      |
    +------+     +--+---+     +--+---+
                    |            |
                    | o1         | o2
                    v            v

    ---------------------------------&gt; time</code></pre>
<p>Where <code>s</code> is the state, <code>i</code> is an input
(e.g. <code>incr</code>) and <code>o</code> is an output. Notice how the
state evolves over time and depends on the history of inputs.</p>
<p>In the pure case each test case is a single input, in the stateful
case we need a sequence of inputs in order to test how the system
changes over time. In the pure case our properties were relations on the
input and output, i.e. <code>R : i -&gt; o -&gt; Bool</code>. In the
stateful case our properties would need to be generalised to
<code>R' : [i] -&gt; [o] -&gt; Bool</code> to account for how the state
changes over time. Writing such properties is cumbersome, an alternative
is to account for the state explicitly by means of some kind of
model.</p>
<p>This is where our in-memory reference implementation, or fake, comes
in. We’ll use a function of type <code>m -&gt; i -&gt; (m, o)</code>,
i.e. from the old model and an input compute the next model and the
output. From this we can derive a property that for each input checks if
the outputs of the stateful component agrees with the output of the
fake:</p>
<pre><code>         +------+     +------+     +------+
         |      | i1  |      | i2  |      |
 real:   |  s0  +-----&gt;  s1  +-----&gt;  s2  | ...
         |      |     |      |     |      |
         +------+     +--++--+     +--++--+
                         ||           ||
                         ||o1         || o2
                         ||           ||
         +------+     +--++--+     +--++--+
         |      | i1  |      | i2  |      |
 fake:   |  m0  +-----&gt;  m1  +-----&gt;  m2  | ...
         |      |     |      |     |      |
         +------+     +------+     +------+

         ---------------------------------&gt; time</code></pre>
<p>In case the outputs disagree we shrink the sequence of inputs and try
to present the smallest counterexample, as in the pure case.</p>
<p>Let’s make things more concrete with some actual code that we can
run.</p>
<section id="example-counter" class="level4">
<h4><a href="#example-counter" title="Example: counter">Example:
counter</a></h4>
<p>All examples, in the rest of this post, will have three parts:</p>
<ol type="1">
<li>The software under test;</li>
<li>The model that the software under test gets tested against;</li>
<li>The generated tests and output from running them.</li>
</ol>
<p>The first part is independent of the stateful testing library we are
building. The second part is hooking up the first part to the library by
implementing an interface (type class). We’ll look at the definition of
the type class after the example. The final part is how to write the
actual property and interpret the output from running them.</p>
<section id="software-under-test" class="level5">
<h5><a href="#software-under-test" title="Software under test">Software
under test</a></h5>
<p>This is how you can implement a counter using a global mutable
variable in Haskell:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">gLOBAL_COUNTER ::</span> <span class="dt">IORef</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>gLOBAL_COUNTER <span class="ot">=</span> unsafePerformIO (newIORef <span class="dv">0</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE gLOBAL_COUNTER #-}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ot">incr ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>incr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> readIORef gLOBAL_COUNTER</span></code></pre></div>
<p>Notice that here <code>incr</code> doesn’t return the old value, like
above, and instead we have a separate operation <code>get</code> which
returns the current value of the counter.</p>
</section>
<section id="model" class="level5">
<h5><a href="#model" title="Model">Model</a></h5>
<p>To model our counter we’ll use an integer.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Counter</span> <span class="ot">=</span> <span class="dt">Counter</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- We&#39;ll come back to the definition of the `StateModel` type class after this</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- example.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> <span class="dt">Counter</span> <span class="kw">where</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- We start counting from zero.</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  initialState ::</span> <span class="dt">Counter</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  initialState <span class="ot">=</span> <span class="dt">Counter</span> <span class="dv">0</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The commands correspond to the names of the functions that operate on the</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- global counter.</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span> <span class="dt">Counter</span> r</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Incr</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Get</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The responses correspond to the return types of each function. By</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- convention we&#39;ll add a underscore suffix to a response of the corresponding</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- command.</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span> <span class="dt">Counter</span> r</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Incr_</span> ()</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Get_</span> <span class="dt">Int</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The state machine takes a command and the model of the counter and returns</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- a new model and a response. We&#39;ll come back to the role of the `Either` later.</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="ot">  runFake ::</span> <span class="dt">Command</span> <span class="dt">Counter</span> r <span class="ot">-&gt;</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Void</span> (<span class="dt">Counter</span>, <span class="dt">Response</span> <span class="dt">Counter</span> r)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">Incr</span>  (<span class="dt">Counter</span> n) <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">Counter</span> (n <span class="op">+</span> <span class="dv">1</span>), <span class="dt">Incr_</span> ())</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">Get</span> m<span class="op">@</span>(<span class="dt">Counter</span> n) <span class="ot">=</span> <span class="fu">return</span> (m, <span class="dt">Get_</span> n)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- We also need to explain which part of the counter API each command</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- corresponds to.</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="ot">  runReal ::</span> <span class="dt">Command</span> <span class="dt">Counter</span> r <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">Counter</span> r)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>  runReal <span class="dt">Get</span>  <span class="ot">=</span> <span class="dt">Get_</span>  <span class="op">&lt;$&gt;</span> get</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>  runReal <span class="dt">Incr</span> <span class="ot">=</span> <span class="dt">Incr_</span> <span class="op">&lt;$&gt;</span> incr</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- We&#39;ll generate increments and reads of the counter with equal probability.</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Notice that we only need to explain how to generate a single command, the</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- library will use this to generate sequences of commands as we&#39;ll see later.</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommand ::</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> <span class="dt">Counter</span> r)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>  generateCommand _s <span class="ot">=</span> elements [<span class="dt">Incr</span>, <span class="dt">Get</span>]</span></code></pre></div>
<p>A common complaint is that the model (<code>Counter</code> and
<code>runFake</code>) is as big as the implementation itself. This is
true, because it’s an example. In reality the model will often be many
orders of magnitude smaller. This is due to the fact that the model,
unlike the real implementation, doesn’t need to persisting to disk,
communicating over the network, or perform various time or space
optimisations. Recall the LevelDB example from above.</p>
</section>
<section id="tests" class="level5">
<h5><a href="#tests" title="Tests">Tests</a></h5>
<p>The tests, or property, can now be written as follows.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_counter ::</span> <span class="dt">Commands</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>prop_counter cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  run reset</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">reset ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>reset <span class="ot">=</span> writeIORef gLOBAL_COUNTER <span class="dv">0</span></span></code></pre></div>
<p>To run them, we can load the module and type
<code>quickCheck prop_counter</code> in the REPL, which gives us an
output like:</p>
<pre><code>+++ OK, passed 100 tests:
89% Get
85% Incr

Commands (2151 in total):
52.02% Get
47.98% Incr</code></pre>
<p>Where the first group of percentages tell us the proportion of tests
that contained the get and increment command respectively, and the
second group of percentages tell us the proportion of get and increment
commands out of all commands generated. Note that the first group
doesn’t add up to 100%, because most tests will contain both commands,
whereas the second group does. The reason the second group is almost
50-50 is because in the generator we generate both commands with equal
probability.</p>
<p>Another thing to note is that we need to <code>reset</code> the
counter between tests, otherwise the global counter will have the value
from the last test while the model always starts from zero and we get a
mismatch.</p>
<p>To make things a bit more interesting, let’s introduce a bug into our
counter and see if the tests can find it. Let’s make it so that if the
counter has the value of 42, then it won’t increment properly.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">incr42Bug ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>incr42Bug <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n&#39; <span class="ot">=</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">42</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>           <span class="kw">then</span> n <span class="co">-- </span><span class="al">BUG</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>           <span class="kw">else</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER n&#39;</span></code></pre></div>
<p>We also need to change the <code>runReal</code> function to use our
buggy increment as follows.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="st">- runReal Incr = Incr_ &lt;$&gt; incr</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ runReal Incr = Incr_ &lt;$&gt; incr42Bug</span></span></code></pre></div>
<p>When we run the property now, we’ll see something like the following
output.</p>
<pre><code>*** Failed! Assertion failed (after 66 tests and 29 shrinks):
    Commands [Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Incr,Get]
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Incr --&gt; Incr_ ()
    Get --&gt; Get_ 42

    Expected: Get_ 43
    Got: Get_ 42</code></pre>
<p>Notice that this is indeed the smallest counterexample and how it
took 66 randomly generated test cases to find the sequence of inputs
that triggered the bug and then 29 shrink steps for QuickCheck to
minimise it.</p>
</section>
</section>
<section id="stateful-library-implementation" class="level4">
<h4><a href="#stateful-library-implementation"
title="Stateful library implementation">Stateful library
implementation</a></h4>
<p>In the example above we implemented the <code>StateModel</code>
interface (or type class), next we’ll have a look at the definition of
this interface and the testing functionality we can derive by
programming against the interface.</p>
<section id="stateful-testing-interface" class="level5">
<h5><a href="#stateful-testing-interface"
title="Stateful testing interface">Stateful testing interface</a></h5>
<p>Let me give you the full definition of the interface and then I’ll
explain it in words afterwards.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ( <span class="op">...</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>      ) <span class="ot">=&gt;</span> <span class="dt">StateModel</span> state <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- If we think of the system under test as a black box, then commands are the</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- inputs and responses the outputs to the black box.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span><span class="ot">  state ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span><span class="ot"> state ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Sometimes a command needs to refer to a previous response, e.g. when a file</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- is opened we get a handle which is later refered to when writing or reading</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- form the file. File handles, and similar constructs, are called references</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- and can be part of commands and responses.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span><span class="ot"> state ::</span> <span class="dt">Type</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span> state <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Not all commands are valid in all states. Pre-conditions allow the user to</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- specify when a command is safe to execute, for example we cannot write or</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- read to or from an unopened file. The `PreconditionFailure` data type</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- allows the user to create custom pre-condition failures. By default now</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- pre-condition failures are allowed, thus the `Void` (empty) type.</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">PreconditionFailure</span><span class="ot"> state ::</span> <span class="dt">Type</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">PreconditionFailure</span> state <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommand ::</span> state <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="ot">  shrinkCommand ::</span> state <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _state _cmd <span class="ot">=</span> []</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a><span class="ot">  initialState ::</span> state</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a><span class="ot">  runFake ::</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)) <span class="ot">-&gt;</span> state</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">PreconditionFailure</span> state)</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>                    (state, <span class="dt">Response</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a><span class="ot">  runReal ::</span> <span class="dt">Command</span> state (<span class="dt">Reference</span> state)</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">CommandMonad</span> state (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a><span class="ot">  monitoring ::</span> (state, state)</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Reference</span> state)</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Response</span> state (<span class="dt">Reference</span> state)</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Property</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>  monitoring _states _cmd _resp <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a><span class="ot">  commandName ::</span> (<span class="dt">Show</span> (<span class="dt">Command</span> state ref), <span class="dt">Show</span> ref)</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=&gt;</span> <span class="dt">Command</span> state ref <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>  commandName <span class="ot">=</span> <span class="fu">head</span> <span class="op">.</span> <span class="fu">words</span> <span class="op">.</span> <span class="fu">show</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Most often the result of executing a command against the system under test</span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- will live in the IO monad, but sometimes it can be useful to be able a</span></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- choose another monad.</span></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">CommandMonad</span><span class="ot"> state ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">CommandMonad</span> state <span class="ot">=</span> <span class="dt">IO</span></span></code></pre></div>
<p>The interface is parametrised by a <code>state</code> type that the
user needs to define before instantiating the interface. In the counter
example <code>state</code> is
<code>newtype Counter = Counter Int</code>. The user needs to provide an
<code>initialState :: state</code> from which we’ll start generating
commands and executing the model, in the counter case this is
<code>Counter 0</code>.</p>
<p>As part of the instantiating the user also needs to specify a type of
<code>Command</code>s and <code>Response</code>s, these were the
<code>Incr</code> and <code>Get</code> operations of the counter and
their response types respectively.</p>
<p>In addition there’s also three optional types, that we’ve not needed
in the counter example. The first is references, these are used to refer
to previously created resources. For example if we open a file handle on
a POSIX-like file system, then later commands need to be able to refer
to that file handle when wanting to write or read from it. The second
datatype is <code>PreconditionFailure</code>, which is used to give a
nice error message when a command is executed in a disallowed state. For
example if we try to read from a file handle that has been closed. The
third data type is <code>CommandMonad</code> which let’s us use a
different monad than <code>IO</code> for executing our commands in.
After we’ve finished with the interface definition we’ll come back to
more examples where we’ll use these optional types, hopefully these
examples will help make things more concrete.</p>
<p>We’ve already seen that the user needs to provide a way to generate
single command, the only thing worth mentioning is that in case our
commands contain references then during generation we only deal with
<code>Var</code>s of references, where
<code>data Var a = Var Int</code>. The reason for this is that we cannot
generate, for example, real file handles (only the operating system
can), so instead we generate “symbolic” references which are just
<code>Int</code>s. Think of these as placeholders for which real
references will be substituted in once the real references are created
during execution.</p>
<p>Shrinking of individual commands is optional and disabled by default,
but as we’ve seen this doesn’t exclude the sequence of commands to be
shrunk. We’ll shall see shortly how that is done in detail.</p>
<p>Next up we got <code>runFake</code> and <code>runReal</code> which
executes a command against the <code>state</code> model and the real
system respectively. Notice how <code>runFake</code> can fail with a
<code>PreconditionFailure</code>, whereas <code>runReal</code> is always
expected to succeed (because if a command fails the precondition check,
then it won’t get generated and hence never reach <code>runReal</code>).
Another difference is that <code>runFake</code> uses symbolic
references, while <code>runReal</code> deals with real references. We’ll
shortly see how this substitution of references works.</p>
<p>Lastly we have two optional functions related to keeping statistics
of generated test cases, which is useful for coverage reporting among
other things. We’ll come back to how these can be used as we look at
more examples after we’ve defined our stateful property-based testing
library.</p>
</section>
<section id="generating-and-shrinking" class="level5">
<h5><a href="#generating-and-shrinking"
title="Generating and shrinking">Generating and shrinking</a></h5>
<p>Once we have our interface we can start writing functions against the
interface. These functions are what the user gets once they implement
the interface. In this section we’ll have a look at generation of
sequences of <code>Commands</code>, which will be the inputs for our
tests, and how to shrink said inputs to produce a minimal
counterexample.</p>
<p>Let’s start by defining <code>Commands</code>, notice that they use
symbolic references (i.e. <code>Var (Reference state)</code>):</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Commands</span> state <span class="ot">=</span> <span class="dt">Commands</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> unCommands ::</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))] }</span></code></pre></div>
<p>As mentioned above, when we generate commands we cannot generate real
references, e.g. file handles, thus <code>Var (Reference state)</code>
is used which is isomorphic to just an <code>Int</code>.</p>
<p>Sometimes it’s convenient to split up <code>runFake</code> into two
parts, the first checks if the command is allowed in the current state,
i.e. the precondition holds:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">precondition ::</span> <span class="dt">StateModel</span> state</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">=&gt;</span> state <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>precondition s cmd <span class="ot">=</span> <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> _  <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> _ <span class="ot">-&gt;</span> <span class="dt">True</span></span></code></pre></div>
<p>And the second part advances the state:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nextState ::</span> <span class="dt">StateModel</span> state</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>          <span class="ot">=&gt;</span> state <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)) <span class="ot">-&gt;</span> state</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>nextState s cmd <span class="ot">=</span> <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> (s&#39;, _) <span class="ot">-&gt;</span> s&#39;</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> _err <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;nextState: impossible, we checked for success in precondition&quot;</span></span></code></pre></div>
<p>We assume that we’ll only ever look at the <code>nextState</code>
when the <code>precondition</code> holds.</p>
<p>Using these two functions we can implement QuickCheck’s
<code>Arbitrary</code> type class for <code>Commands</code> which let’s
us generate and shrink <code>Commands</code>:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> state <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Commands</span> state) <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> (<span class="dt">Commands</span> state)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> <span class="dt">Commands</span> <span class="op">&lt;$&gt;</span> genCommands initialState</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="ot">      genCommands ::</span> <span class="dt">StateModel</span> state</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>                  <span class="ot">=&gt;</span> state <span class="ot">-&gt;</span> <span class="dt">Gen</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>      genCommands s <span class="ot">=</span> sized <span class="op">$</span> \n <span class="ot">-&gt;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>          w <span class="ot">=</span> n <span class="ot">`div`</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>          frequency</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>            [ (<span class="dv">1</span>, <span class="fu">return</span> [])</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>            , (w, <span class="kw">do</span> mcmd <span class="ot">&lt;-</span> generateCommand s <span class="ot">`suchThatMaybe`</span> precondition s</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">case</span> mcmd <span class="kw">of</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> <span class="fu">return</span> []</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Just</span> cmd <span class="ot">-&gt;</span> (cmd <span class="op">:</span>) <span class="op">&lt;$&gt;</span> genCommands (nextState s cmd))</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="ot">  shrink ::</span> <span class="dt">Commands</span> state <span class="ot">-&gt;</span> [<span class="dt">Commands</span> state]</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>  shrink <span class="ot">=</span> pruneShrinks <span class="op">.</span> possibleShrinks</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="ot">      possibleShrinks ::</span> <span class="dt">Commands</span> state <span class="ot">-&gt;</span> [<span class="dt">Commands</span> state]</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>      possibleShrinks <span class="ot">=</span> <span class="fu">map</span> (<span class="dt">Commands</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">fst</span>) <span class="op">.</span> shrinkList shrinker</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>                      <span class="op">.</span> withStates initialState <span class="op">.</span> unCommands</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>          shrinker (cmd, s) <span class="ot">=</span> [ (cmd&#39;, s) <span class="op">|</span> cmd&#39; <span class="ot">&lt;-</span> shrinkCommand s cmd ]</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="ot">          withStates ::</span> <span class="dt">StateModel</span> state</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">=&gt;</span> state <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">-&gt;</span> [(<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)), state)]</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>          withStates s0 <span class="ot">=</span> go s0 []</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>              go _s acc []           <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>              go  s acc (cmd <span class="op">:</span> cmds) <span class="ot">=</span> go (nextState s cmd) ((cmd, s) <span class="op">:</span> acc) cmds</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a><span class="ot">      pruneShrinks ::</span> [<span class="dt">Commands</span> state] <span class="ot">-&gt;</span> [<span class="dt">Commands</span> state]</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>      pruneShrinks <span class="ot">=</span> coerce <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span>)</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>                   <span class="op">.</span> <span class="fu">map</span> (go initialState Set.empty [] <span class="op">.</span> unCommands)</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>          go _s _vars acc [] <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>          go  s  vars acc (cmd <span class="op">:</span> cmds)</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">not</span> (scopeCheck vars cmd) <span class="ot">=</span> go s vars acc cmds</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Left</span> _preconditionFailure <span class="ot">-&gt;</span> go s vars acc cmds</span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Right</span> (s&#39;, resp) <span class="ot">-&gt;</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>                    returnedVars <span class="ot">=</span> Set.fromList (toList resp)</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>                    vars&#39; <span class="ot">=</span> returnedVars <span class="ot">`Set.union`</span> vars</span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>                    go s&#39; vars&#39; (cmd <span class="op">:</span> acc) cmds</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a><span class="ot">scopeCheck ::</span> <span class="dt">Foldable</span> (<span class="dt">Command</span> state)</span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>scopeCheck varsInScope cmd <span class="ot">=</span> usedVars <span class="ot">`Set.isSubsetOf`</span> varsInScope</span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>    usedVars <span class="ot">=</span> Set.fromList (toList cmd)</span></code></pre></div>
<p>Notice how after shrinking we prune away all commands that don’t pass
the precondition or that are out of scope with respect to symbolic
references.</p>
<p>The intuition here is that as we remove commands from the originally
generated <code>Commands</code> (which all pass their preconditions), we
might have broken some preconditions and pruning simply removes the
commands which we made invalid in the process of shrinking. Similarly we
can have a command that creates a reference that later commands then
depend on, if we during shrinking remove the command that created the
reference then we must also remove the commands that depend on the
reference.</p>
</section>
<section id="running-and-assertion-checking" class="level5">
<h5><a href="#running-and-assertion-checking"
title="Running and assertion checking">Running and assertion
checking</a></h5>
<p>Once we’ve generated <code>Commands</code> we need to execute them
against the model and the real system using <code>runFake</code> and
<code>runReal</code>. In the process of doing so <code>runReal</code>
will produce <code>Reference</code>s that later commands might use, so
we also need to substitute symbolic references for real references.
This, together with coverage statistics bookkeeping, is done in the
<code>runCommands</code> function:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runCommands ::</span> <span class="kw">forall</span> state<span class="op">.</span> <span class="dt">StateModel</span> state</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=&gt;</span> <span class="dt">Commands</span> state <span class="ot">-&gt;</span> <span class="dt">PropertyM</span> (<span class="dt">CommandMonad</span> state) ()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>runCommands (<span class="dt">Commands</span> cmds0) <span class="ot">=</span> go initialState emptyEnv cmds0</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> state <span class="ot">-&gt;</span> <span class="dt">Env</span> state <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">PropertyM</span> (<span class="dt">CommandMonad</span> state) ()</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    go _state _env [] <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    go  state  env (cmd <span class="op">:</span> cmds) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> runFake cmd state <span class="kw">of</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>          monitor (counterexample (<span class="st">&quot;Preconditon failed: &quot;</span> <span class="op">++</span> <span class="fu">show</span> err))</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>          assert <span class="dt">False</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> (state&#39;, resp) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> name <span class="ot">=</span> commandName cmd</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>          monitor (tabulate <span class="st">&quot;Commands&quot;</span> [name] <span class="op">.</span> classify <span class="dt">True</span> name)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Here we substitute all symbolic references for real ones:</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> ccmd <span class="ot">=</span> <span class="fu">fmap</span> (lookupEnv env) cmd</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>          cresp <span class="ot">&lt;-</span> run (runReal ccmd)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>          monitor (counterexample (<span class="fu">show</span> cmd <span class="op">++</span> <span class="st">&quot; --&gt; &quot;</span> <span class="op">++</span> <span class="fu">show</span> cresp))</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>          monitor (monitoring (state, state&#39;) ccmd cresp)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Here we collect all references from the response and store it in</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- our environment, so that subsequence commands can be substituted.</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> refs   <span class="ot">=</span> toList cresp</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>              env&#39;   <span class="ot">=</span> extendEnv env (<span class="fu">zip</span> [sizeEnv env<span class="op">..</span>] refs)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>              cresp&#39; <span class="ot">=</span> <span class="fu">fmap</span> (lookupEnv env&#39;) resp</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>              ok     <span class="ot">=</span> cresp <span class="op">==</span> cresp&#39;</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>          unless ok <span class="op">$</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            monitor (counterexample (<span class="st">&quot;Expected: &quot;</span> <span class="op">++</span> <span class="fu">show</span> cresp&#39; <span class="op">++</span> <span class="st">&quot;\nGot: &quot;</span> <span class="op">++</span> <span class="fu">show</span> cresp))</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- And finally here&#39;s where we assert that the model and the real</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- implementation agree.</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>          assert ok</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>          go state&#39; env&#39; cmds</span></code></pre></div>
<p>Where <code>Env</code> is defined as follows.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Env</span> state <span class="ot">=</span> <span class="dt">Env</span> {<span class="ot"> unEnv ::</span> <span class="dt">IntMap</span> (<span class="dt">Reference</span> state) }</span></code></pre></div>
<p>That’s all the pieces we need to implement that <code>Counter</code>
example that we saw above, plus some new constructs to deal with
precondition failures and references.</p>
<p>Next let’s have a look at an example where we need preconditions and
references.</p>
</section>
</section>
<section id="example-circular-buffer" class="level4">
<h4><a href="#example-circular-buffer"
title="Example: circular buffer">Example: circular buffer</a></h4>
<p>This example is taken from John’s paper <a
href="https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"><em>Testing
the hard stuff and staying sane</em></a> (2014).</p>
<section id="software-under-test-1" class="level5">
<h5><a href="#software-under-test-1"
title="Software under test">Software under test</a></h5>
<p>The implementation is written in C and uses two indices which keep
track of the front and back of the queue, this allows us to implement
the queue in a circular fashion. I’ve copied the C code straight from
the paper. In order to test it from Haskell, we’ll use Haskell’s foreign
function interface.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> queue <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="op">*</span>buf<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> inp<span class="op">,</span> outp<span class="op">,</span> size<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> Queue<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>Queue <span class="op">*</span>new<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="op">*</span>buff <span class="op">=</span> malloc<span class="op">(</span>n<span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  Queue q <span class="op">=</span> <span class="op">{</span>buff<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span>n<span class="op">};</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  Queue <span class="op">*</span>qptr <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>Queue<span class="op">));</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">*</span>qptr <span class="op">=</span> q<span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> qptr<span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> put<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>buf<span class="op">[</span>q<span class="op">-&gt;</span>inp<span class="op">]</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>inp <span class="op">=</span> <span class="op">(</span>q<span class="op">-&gt;</span>inp <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> get<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ans <span class="op">=</span> q<span class="op">-&gt;</span>buf<span class="op">[</span>q<span class="op">-&gt;</span>outp<span class="op">];</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>outp <span class="op">=</span> <span class="op">(</span>q<span class="op">-&gt;</span>outp <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>q<span class="op">-&gt;</span>inp <span class="op">-</span> q<span class="op">-&gt;</span>outp<span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the C code doesn’t do any error checking, e.g. if we
<code>get</code> from an empty queue then we’ll get back uninitialised
memory.</p>
</section>
<section id="model-1" class="level5">
<h5><a href="#model-1" title="Model">Model</a></h5>
<p>The circular buffer implementation is efficient, because it reuses
the allocated memory as we go around in circles, but it’s not obviously
correct.</p>
<p>To model queues we’ll use a more straight forward non-circular
implementation. This is less efficient (doesn’t matter as it’s merely
used during testing), but hopefully more obviously correct.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FQueue</span> <span class="ot">=</span> <span class="dt">FQueue</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> fqElems ::</span> [<span class="dt">Int</span>]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> fqSize  ::</span> <span class="dt">Int</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>In the <code>Counter</code> example above we only had one counter, so
the model was merely a single integer. In this example, because of
<code>new</code> returning a queue, we need to be able to model
arbitrary many queues. We can do this using symbolic references
(<code>data Var a = Var Int</code>) as follows:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Map</span> (<span class="dt">Var</span> <span class="dt">Queue</span>) <span class="dt">FQueue</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyState ::</span> <span class="dt">State</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>emptyState <span class="ot">=</span> Map.empty</span></code></pre></div>
<p>Where <code>Queue</code> is the Haskell data type that corresponds to
the C <code>Queue</code> and the <code>Var a</code> data type is
provided by the library and is a symbolic reference to <code>a</code>
(just an <code>Int</code>eger). The idea being that in the model we
don’t have access to real <code>Queue</code>s, merely symbolic
references to them. This might seem a bit strange, but I hope that it
will become more clear when we model <code>new</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FakeOp</span> a <span class="ot">=</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Err</span> (<span class="dt">State</span>, a)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fNew ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> (<span class="dt">Var</span> <span class="dt">Queue</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>fNew sz s <span class="ot">=</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    v  <span class="ot">=</span> <span class="dt">Var</span> (Map.size s)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    s&#39; <span class="ot">=</span> Map.insert v (<span class="dt">FQueue</span> [] sz) s</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (s&#39;, v)</span></code></pre></div>
<p>As we have access to the state when defining our model, we can create
new unique symbolic references by simply counting how many symbolic
references we’ve created previously (using <code>Map.size</code>)<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<p>As we said before, in the C code we don’t do any error checking. In
the model we do check that, for example, the queue is non-empty before
we <code>fGet</code> an item. These are our preconditions.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Err</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">QueueDoesNotExist</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">QueueIsEmpty</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fPut ::</span> <span class="dt">Var</span> <span class="dt">Queue</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> ()</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>fPut q i s</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> q <span class="ot">`Map.notMember`</span> s <span class="ot">=</span> <span class="dt">Left</span> <span class="dt">QueueDoesNotExist</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">return</span> (Map.adjust (\fq <span class="ot">-&gt;</span> fq { fqElems <span class="ot">=</span> fqElems fq <span class="op">++</span> [i] }) q s, ())</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="ot">fGet ::</span> <span class="dt">Var</span> <span class="dt">Queue</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> <span class="dt">Int</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>fGet q s</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> q <span class="ot">`Map.notMember`</span> s <span class="ot">=</span> <span class="dt">Left</span> <span class="dt">QueueDoesNotExist</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">case</span> fqElems (s <span class="op">Map.!</span> q) <span class="kw">of</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>      []     <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="dt">QueueIsEmpty</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>      i <span class="op">:</span> is <span class="ot">-&gt;</span> <span class="fu">return</span> (Map.adjust (\fq <span class="ot">-&gt;</span> fq { fqElems <span class="ot">=</span> is }) q s, i)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="ot">fSize ::</span> <span class="dt">Var</span> <span class="dt">Queue</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> <span class="dt">Int</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>fSize q s</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> q <span class="ot">`Map.notMember`</span> s <span class="ot">=</span> <span class="dt">Left</span> <span class="dt">QueueDoesNotExist</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>           <span class="ot">=</span> <span class="fu">return</span> (s, <span class="fu">length</span> (fqElems (s <span class="op">Map.!</span> q)))</span></code></pre></div>
<p>Recall that we won’t generate a get operation unless the precondition
holds in the state that we are currently in, i.e. we will never generate
gets if the queue is empty and thus we’ll never execute the C code for
<code>get</code> which gives back uninitialised memory.</p>
<p>Having defined our model the interface implementation is almost
mechanical.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> <span class="dt">State</span> <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  initialState <span class="ot">=</span> Map.empty</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Queue</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">PreconditionFailure</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Err</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span> <span class="dt">State</span> q</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">New</span> <span class="dt">Int</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Put</span> q <span class="dt">Int</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Get</span> q</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Size</span> q</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span> <span class="dt">State</span> q</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">New_</span> q</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Put_</span> ()</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Get_</span> <span class="dt">Int</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Size_</span> <span class="dt">Int</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>  generateCommand s</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> Map.null s <span class="ot">=</span> <span class="dt">New</span> <span class="op">.</span> getPositive <span class="op">&lt;$&gt;</span> arbitrary</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> oneof</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">New</span> <span class="op">.</span> getPositive <span class="op">&lt;$&gt;</span> arbitrary</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Put</span>  <span class="op">&lt;$&gt;</span> arbitraryQueue <span class="op">&lt;*&gt;</span> arbitrary</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Get</span>  <span class="op">&lt;$&gt;</span> arbitraryQueue</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a><span class="ot">      arbitraryQueue ::</span> <span class="dt">Gen</span> (<span class="dt">Var</span> <span class="dt">Queue</span>)</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>      arbitraryQueue <span class="ot">=</span> elements (Map.keys s)</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _s (<span class="dt">New</span> i)   <span class="ot">=</span> [ <span class="dt">New</span> i&#39;   <span class="op">|</span> <span class="dt">Positive</span> i&#39; <span class="ot">&lt;-</span> shrink (<span class="dt">Positive</span> i) ]</span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _s (<span class="dt">Put</span> q i) <span class="ot">=</span> [ <span class="dt">Put</span> q i&#39; <span class="op">|</span> i&#39; <span class="ot">&lt;-</span> shrink i ]</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>  shrinkCommand _s _cmd <span class="ot">=</span> []</span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">New</span> sz)  s <span class="ot">=</span> <span class="fu">fmap</span> <span class="dt">New_</span>  <span class="op">&lt;$&gt;</span> fNew sz s</span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Put</span> q i) s <span class="ot">=</span> <span class="fu">fmap</span> <span class="dt">Put_</span>  <span class="op">&lt;$&gt;</span> fPut q i s</span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Get</span> q)   s <span class="ot">=</span> <span class="fu">fmap</span> <span class="dt">Get_</span>  <span class="op">&lt;$&gt;</span> fGet q s</span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Size</span> q)  s <span class="ot">=</span> <span class="fu">fmap</span> <span class="dt">Size_</span> <span class="op">&lt;$&gt;</span> fSize q s</span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Here `new`, `put`, `get` and `size` are FFI wrappers for their respective C</span></span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- functions.</span></span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">New</span> sz)  <span class="ot">=</span> <span class="dt">New_</span>  <span class="op">&lt;$&gt;</span> new sz</span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Put</span> q i) <span class="ot">=</span> <span class="dt">Put_</span>  <span class="op">&lt;$&gt;</span> put q i</span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Get</span> q)   <span class="ot">=</span> <span class="dt">Get_</span>  <span class="op">&lt;$&gt;</span> get q</span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Size</span> q)  <span class="ot">=</span> <span class="dt">Size_</span> <span class="op">&lt;$&gt;</span> size q</span></code></pre></div>
<p>The only new thing worth paying attention to is the <code>q</code> in
<code>Command</code> and <code>Response</code>, which is parametrised so
that it works for both symbolic and real references. The
<code>Functor</code> instance lets us do substitution, while
<code>Foldable</code> lets us extract all new references from a
response, so that we can substitute them in later
<code>Command</code>s.</p>
</section>
<section id="testing" class="level5">
<h5><a href="#testing" title="Testing">Testing</a></h5>
<p>Having implemented the interface, we can write our property as
follows.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_queue ::</span> <span class="dt">Commands</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>prop_queue cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span></code></pre></div>
<p>When we run it, using <code>quickCheck prop_queue</code>, we get the
following error.</p>
<pre><code>   *** Failed! Assertion failed (after 7 tests and 5 shrinks):
    Commands {unCommands = [New 1,Put (Var 0) 0,Put (Var 0) 1,Get (Var 0)]}
    New 1 --&gt; New_ (Queue 0x00000000016e9010)
    Put (Var 0) 0 --&gt; Put_ ()
    Put (Var 0) 1 --&gt; Put_ ()
    Get (Var 0) --&gt; Get_ 1
    Expected: Get_ 0
    Got: Get_ 1</code></pre>
<p>So we create a new queue of size <code>1</code>, put two items
(<code>0</code> and <code>1</code>) into it, and finally we read a value
from the queue and this is where the assertion fails. Or model returns
<code>0</code>, because it’s a FIFO queue, but the C code returns
<code>1</code>. The reason for this is that in the C code there’s no
error checking, so writing a value to a full queue simply overwrites the
oldest value. So there’s actually nothing wrong with the implementation,
but rather the model is wrong. We’ve forgotten a precondition:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a> data Err</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>   = QueueDoesNotExist</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>   | QueueIsEmpty</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="va">+  | QueueIsFull</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>fPut :: Var Queue -&gt; Int -&gt; State -&gt; Either Err (State, ())</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>fPut q i s</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  | q `Map.notMember` s = Left QueueDoesNotExist</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="va">+ | length (fqElems (s Map.! q)) &gt;= fqSize (s Map.! q) = Left QueueIsFull</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  | otherwise = return (Map.adjust (\fq -&gt; fq { fqElems = fqElems fq ++ [i] }) q s, ())</span></code></pre></div>
<p>We can add the counterexample that we got as a regression test to our
test suite as follows:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit_queueFull ::</span> <span class="dt">IO</span> ()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>unit_queueFull <span class="ot">=</span> quickCheck (withMaxSuccess <span class="dv">1</span> (expectFailure (prop_queue cmds)))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    cmds <span class="ot">=</span> <span class="dt">Commands</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">New</span> <span class="dv">1</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Put</span> (<span class="dt">Var</span> <span class="dv">0</span>) <span class="dv">1</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Put</span> (<span class="dt">Var</span> <span class="dv">0</span>) <span class="dv">0</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Get</span> (<span class="dt">Var</span> <span class="dv">0</span>)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>Notice that we can basically copy-paste <code>cmds</code> from
QuickCheck’s output, but I’ve done some formatting here to make it more
readable.</p>
<p>After fixing the precondition for <code>fPut</code>,
<code>unit_queueFull</code> fails as follows:</p>
<pre><code>+++ OK, failed as expected. Assertion failed (after 1 test):
New 1 --&gt; New_ (Queue 0x00000000006f6d20)
Put (Var 0) 1 --&gt; Put_ ()
Preconditon failed: QueueIsFull</code></pre>
<p>When we rerun <code>quickCheck prop_queue</code> we will not generate
this example again, because all preconditions need to hold, and the
property passes:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
+++ OK, passed 100 tests:
95% New
86% Put
67% Get

Commands (2497 in total):
44.13% New
41.25% Put
14.62% Get</code></pre>
<p>However as we can see in the output there’s no coverage for
<code>Size</code>! The reason for this is because we’ve forgot to add it
to our generator:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  generateCommand s</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    | Map.null s = New . getPositive &lt;$&gt; arbitrary</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    | otherwise  = oneof</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>      [ New . getPositive &lt;$&gt; arbitrary</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>      , Put  &lt;$&gt; arbitraryQueue &lt;*&gt; arbitrary</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>      , Get  &lt;$&gt; arbitraryQueue</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="va">+     , Size &lt;$&gt; arbitraryQueue</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>After adding it and rerunning the property, we get the following
error:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
*** Failed! Assertion failed (after 25 tests and 8 shrinks):
Commands {unCommands = [New 1,Put (Var 0) 0,Size (Var 0)]}
New 1 --&gt; New_ (Queue 0x0000000001444220)
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ 0
Expected: Size_ 1
Got: Size_ 0</code></pre>
<p>Size should return how many items are in the queue, so after we put
one item into a queue we expect it to return <code>1</code>, but in the
above counterexample it returns <code>0</code>.</p>
<p>To understand why this happens we have to look at how
<code>put</code> and <code>size</code> are implemented:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> put<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>buf<span class="op">[</span>q<span class="op">-&gt;</span>inp<span class="op">]</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  q<span class="op">-&gt;</span>inp <span class="op">=</span> <span class="op">(</span>q<span class="op">-&gt;</span>inp <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> size<span class="op">(</span>Queue <span class="op">*</span>q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">(</span>q<span class="op">-&gt;</span>inp <span class="op">-</span> q<span class="op">-&gt;</span>outp<span class="op">)</span> <span class="op">%</span> q<span class="op">-&gt;</span>size<span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In <code>put</code> when we do
<code>q-&gt;inp = (q-&gt;inp + 1) % q-&gt;size</code> we get
<code>q-&gt;inp = (0 + 1) % 1 == 0</code> and then when we calculate the
<code>size</code> we get <code>(0 - 0) % 1 == 0</code>. One way to fix
this is to make <code>q-&gt;size</code> be <code>n + 1</code> rather
than <code>n</code> where <code>n</code> is the size parameter of
<code>new</code>, that way <code>put</code> will do
<code>q-&gt;inp = (0 + 1) % 2 == 1</code> instead and size will be
<code>1 - 0 % 2 == 1</code> which is correct. Here’s the diff:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>  Queue *new(int n) {</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="st">-   int *buff = malloc(n*sizeof(int));</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="st">-   Queue q = {buff,0,0,n};</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="va">+   int *buff = malloc((n + 1)*sizeof(int));</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="va">+   Queue q = {buff,0,0,n + 1};</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    Queue *qptr = malloc(sizeof(Queue));</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    *qptr = q;</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    return qptr;</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>As before, we can add a regression test for the size issue as
follows:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit_queueSize ::</span> <span class="dt">IO</span> ()</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>unit_queueSize <span class="ot">=</span> quickCheck (withMaxSuccess <span class="dv">1</span> (prop_queue cmds))</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    cmds <span class="ot">=</span> <span class="dt">Commands</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>      [ <span class="dt">New</span> <span class="dv">1</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Put</span> (<span class="dt">Var</span> <span class="dv">0</span>) <span class="dv">0</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>      , <span class="dt">Size</span> (<span class="dt">Var</span> <span class="dv">0</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>      ]</span></code></pre></div>
<p>After the change to <code>new</code> this test passes, but if we
rerun the property we get the following error:</p>
<pre><code>*** Failed! Assertion failed (after 38 tests and 12 shrinks):
Commands {unCommands = [New 1,Put (Var 0) 0,Get (Var 0),Put (Var 0) 0,Size (Var 0)]}
New 1 --&gt; New_ (Queue 0x00007fd47c00a920)
Put (Var 0) 0 --&gt; Put_ ()
Get (Var 0) --&gt; Get_ 0
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ (-1)
Expected: Size_ 1
Got: Size_ (-1)</code></pre>
<p>After the second <code>put</code> we’ll have
<code>q-&gt;inp = (1 + 1) % 2 == 0</code> while
<code>q-&gt;outp = 1</code> due to the <code>get</code> and so when we
call <code>size</code> we get <code>0 - 1 % 2 == -1</code>. Taking the
absolute value:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  int size(Queue *q) {</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="st">-   return (q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="va">+   return abs(q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Makes this test case pass, and in fact it also makes the property
pass:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
+++ OK, passed 100 tests:
93% New
79% Put
74% Size
59% Get

Commands (2340 in total):
32.09% New
29.06% Size
28.25% Put
10.60% Get</code></pre>
<p>John says that at this point most programmers would probably be happy
and believe that their implementation works, but if we rerun it again
(or increase the amount of tests generated), we get:</p>
<pre><code>&gt;&gt;&gt; quickCheck prop_queue
*** Failed! Assertion failed (after 56 tests and 19 shrinks):
Commands {unCommands = [New 2,Put (Var 0) 0,Put (Var 0) 0,Get (Var 0),Put (Var 0) 0,Size (Var 0)]}
New 2 --&gt; New_ (Queue 0x00007fbf4c006490)
Put (Var 0) 0 --&gt; Put_ ()
Put (Var 0) 0 --&gt; Put_ ()
Get (Var 0) --&gt; Get_ 0
Put (Var 0) 0 --&gt; Put_ ()
Size (Var 0) --&gt; Size_ 1
Expected: Size_ 2
Got: Size_ 1</code></pre>
<p>We can see that all queues of size <code>1</code> now work, because
this test starts by creating a queue of size <code>2</code>, so we’ve
made progress. But taking the absolute value isn’t the correct way to
calculate the size (even though it works for queues of size
<code>1</code>), the following is the correct way to do it:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>  int size(Queue *q) {</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="st">-   return abs(q-&gt;inp - q-&gt;outp) % q-&gt;size;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="va">+   return (q-&gt;inp - q-&gt;outp + q-&gt;size) % q-&gt;size;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>With this final tweak, the property passes. I hope that this somewhat
long example gives you a feel for how property-based testing drives the
development and debugging of the code.</p>
</section>
</section>
<section id="example-jug-puzzle-from-die-hard-3" class="level4">
<h4><a href="#example-jug-puzzle-from-die-hard-3"
title="Example: jug puzzle from Die Hard 3">Example: jug puzzle from Die
Hard 3</a></h4>
<p>In the movie Die Hard 3 there’s a <a
href="https://www.youtube.com/watch?v=BVtQNK_ZUJg">scene</a> where Bruce
Willis and Samuel L. Jackson have to solve a puzzle in order to stop a
bomb from going off. The puzzle is: given a 3L and a 5L jug, how can you
measure exactly 4L?</p>
<p>I first saw this example solved using TLA+ and I wanted to include it
here because it shows that we don’t necessarily need a real
implementation, merely running the model/fake can be useful.</p>
<p>The main idea is to model the two jugs and all actions we can do with
them and then throw an exception when the big jug contains 4L. This will
fail the test and output the shrunk sequence of actions that resulted in
the failure, giving us the solution to the puzzle.</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Model</span> <span class="ot">=</span> <span class="dt">Model</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> bigJug   ::</span> <span class="dt">Int</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> smallJug ::</span> <span class="dt">Int</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> <span class="dt">Model</span> <span class="kw">where</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>  initialState <span class="ot">=</span> <span class="dt">Model</span> <span class="dv">0</span> <span class="dv">0</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span> <span class="dt">Model</span> <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span> <span class="dt">Model</span> r</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">FillBig</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">FillSmall</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">EmptyBig</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">EmptySmall</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">SmallIntoBig</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">BigIntoSmall</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span> <span class="dt">Model</span> r <span class="ot">=</span> <span class="dt">Done</span> <span class="op">|</span> <span class="dt">BigJugIs4</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommand ::</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> <span class="dt">Model</span> r)</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>  generateCommand _s <span class="ot">=</span> elements [<span class="fu">minBound</span> <span class="op">..</span>]</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a><span class="ot">  runFake ::</span> <span class="dt">Command</span> <span class="dt">Model</span> r <span class="ot">-&gt;</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> void (<span class="dt">Model</span>, <span class="dt">Response</span> <span class="dt">Model</span> r)</span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">FillBig</span>      s <span class="ot">=</span> done s { bigJug   <span class="ot">=</span> <span class="dv">5</span> }</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">FillSmall</span>    s <span class="ot">=</span> done s { smallJug <span class="ot">=</span> <span class="dv">3</span> }</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">EmptyBig</span>     s <span class="ot">=</span> done s { bigJug   <span class="ot">=</span> <span class="dv">0</span> }</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">EmptySmall</span>   s <span class="ot">=</span> done s { smallJug <span class="ot">=</span> <span class="dv">0</span> }</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">SmallIntoBig</span> (<span class="dt">Model</span> big small) <span class="ot">=</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> big&#39; <span class="ot">=</span> <span class="fu">min</span> <span class="dv">5</span> (big <span class="op">+</span> small) <span class="kw">in</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>    done (<span class="dt">Model</span> { bigJug <span class="ot">=</span> big&#39;</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>                , smallJug <span class="ot">=</span> small <span class="op">-</span> (big&#39; <span class="op">-</span> big) })</span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">BigIntoSmall</span> (<span class="dt">Model</span> big small) <span class="ot">=</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> small&#39; <span class="ot">=</span> <span class="fu">min</span> <span class="dv">3</span> (big <span class="op">+</span> small) <span class="kw">in</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>    done (<span class="dt">Model</span> { bigJug <span class="ot">=</span> big <span class="op">-</span> (small&#39; <span class="op">-</span> small)</span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>                , smallJug <span class="ot">=</span> small&#39;</span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>                })</span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a><span class="ot">  runReal ::</span> <span class="dt">Command</span> <span class="dt">Model</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">Model</span> (<span class="dt">Reference</span> <span class="dt">Model</span>))</span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a>  runReal _cmd <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Done</span></span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a><span class="ot">  monitoring ::</span> (<span class="dt">Model</span>, <span class="dt">Model</span>) <span class="ot">-&gt;</span> <span class="dt">Command</span> <span class="dt">Model</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="dt">Model</span> <span class="dt">Void</span></span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Property</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>  monitoring (_s, s&#39;) _cmd _resp <span class="ot">=</span></span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a>    counterexample <span class="op">$</span> <span class="st">&quot;\n    State: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s&#39; <span class="op">++</span> <span class="st">&quot;\n&quot;</span></span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-51"><a href="#cb47-51" aria-hidden="true" tabindex="-1"></a><span class="ot">done ::</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> void (<span class="dt">Model</span>, <span class="dt">Response</span> <span class="dt">Model</span> ref)</span>
<span id="cb47-52"><a href="#cb47-52" aria-hidden="true" tabindex="-1"></a>done s&#39; <span class="op">|</span> bigJug s&#39; <span class="op">==</span> <span class="dv">4</span> <span class="ot">=</span> <span class="fu">return</span> (s&#39;, <span class="dt">BigJugIs4</span>)</span>
<span id="cb47-53"><a href="#cb47-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="fu">return</span> (s&#39;, <span class="dt">Done</span>)</span>
<span id="cb47-54"><a href="#cb47-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-55"><a href="#cb47-55" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_dieHard ::</span> <span class="dt">Commands</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb47-56"><a href="#cb47-56" aria-hidden="true" tabindex="-1"></a>prop_dieHard cmds <span class="ot">=</span> withMaxSuccess <span class="dv">10000</span> <span class="op">$</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb47-57"><a href="#cb47-57" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb47-58"><a href="#cb47-58" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span></code></pre></div>
<p>When we run <code>quickcheck prop_dieHard</code> we get the following
output:</p>
<pre><code>   +++ OK, failed as expected. Assertion failed (after 199 tests and 11 shrinks):
    Commands [FillBig,BigIntoSmall,EmptySmall,BigIntoSmall,FillBig,BigIntoSmall]
    FillBig --&gt; Done

        State: Model {bigJug = 5, smallJug = 0}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 2, smallJug = 3}

    EmptySmall --&gt; Done

        State: Model {bigJug = 2, smallJug = 0}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 0, smallJug = 2}

    FillBig --&gt; Done

        State: Model {bigJug = 5, smallJug = 2}

    BigIntoSmall --&gt; Done

        State: Model {bigJug = 4, smallJug = 3}

    Expected: BigJugIs4
    Got: Done</code></pre>
<p>Notice how the trace shows the intermediate states, making it easy to
verify that it’s indeed a correct solution to the puzzle<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
</section>
</section>
<section id="parallel-property-based-testing" class="level3">
<h3><a href="#parallel-property-based-testing"
title="Parallel property-based testing">Parallel property-based
testing</a></h3>
<p>Let’s now turn our focus to parallel property-based testing.</p>
<p>Debugging buggy concurrent code is not fun. The main reason for this
is that the threads interleave in different ways between executions,
making it hard to reproduce the bug and hard to verify that a bug fix
actually worked.</p>
<p>Ideally we’d like to make working with concurrent code as pleasant as
the sequential stateful case and without the user having to write any
additional test code. In order to explain how we can achieve this, we
need to first understand how we can test concurrent code in a
reproducible way.</p>
<p>Recall our <code>Counter</code> that we looked at in the sequential
testing case. Here we’ll be using a slight generalisation where the
<code>incr</code> takes an integer parameter which specifies by how much
we want to increment (instead of always incrementing by
<code>1</code>).</p>
<p>When we interact with the counter sequentially, i.e. one command at
the time, then it appears to count correctly:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> incr <span class="dv">1</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> incr <span class="dv">2</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> get</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<p>If we instead concurrently issue the <code>incr</code>ements, we see
something strange:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span> forM_ [<span class="dv">0</span><span class="op">..</span><span class="dv">100000</span>] <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span>   c <span class="ot">&lt;-</span> newCounter</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span>   concurrently_ (incr c <span class="dv">1</span>) (incr c <span class="dv">2</span>)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span>   x <span class="ot">&lt;-</span> get c</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;</span>   <span class="kw">if</span> x <span class="op">==</span> <span class="dv">3</span> <span class="kw">then</span> <span class="fu">return</span> () <span class="kw">else</span> <span class="fu">error</span> (<span class="st">&quot;i = &quot;</span> <span class="op">++</span> <span class="fu">show</span> i <span class="op">++</span> <span class="st">&quot;, x = &quot;</span> <span class="op">++</span> <span class="fu">show</span> x)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a> <span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> i <span class="ot">=</span> <span class="dv">29768</span>, x <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>After 29768 iterations we get back <code>1</code> rather than the
expected <code>3</code>! The reason for this is because there’s a race
condition in the implementation of <code>incr</code>:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a> incr i <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>   j <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>   writeIORef gLOBAL_COUNTER (i <span class="op">+</span> j)</span></code></pre></div>
<p>Because we first read the old value and <em>then</em> write the new
incremented value in an non-atomic way, it’s possible that if two
threads do this at the same time they overwrite each others increment.
For example, consider the interleaving:</p>
<pre><code>   thread 1, incr 1     |  thread 2, incr 2
   ---------------------+------------------
    0 &lt;- readIORef      |
                        | 0 &lt;- readIORef
                        | writeIORef (2 + 0)
    writeIORef (1 + 0)  |
                        |
                        v
                       time</code></pre>
<p>If we read from the counter after the two increments are done we get
<code>1</code> instead of the expected <code>3</code>. The fix to this
problem is to do an atomic update using <code>atomicModifyIORef'</code>,
instead of first reading and then writing to the <code>IORef</code>.</p>
<p>The concurrent test that we just wrote is not only specific to the
counter example but also only uses three fixed commands, the two
concurrent <code>incr</code>ements followed by a <code>get</code>. While
it was enough to find this race condition, in general we’d like to try
arbitrary combinations of commands and possibly involving more than two
threads.</p>
<p>The key concept we need in order to accomplish that is that of
<em>concurrent history</em>, which is perhaps easiest to explain in
terms of a more familiar concept: a sequence diagram.</p>
<p>Consider the following sequence diagram:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/sequence-diagram.svg"
width=60%></p>
<p>Here we see that the first and second thread concurrently increment,
the first thread then reads the counter concurrently with the second
thread’s increment that’s still going on. The second thread’s increment
finishes and a third thread does a read which is concurrent with the
first thread’s read.</p>
<p>We can abstract away the arrows and merely focus on the intervals of
the commands:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/history-from-sequence-diagram.svg"
width=60%></p>
<p>If we rotate the intervals we get the concurrent history:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter.svg"
width=60%></p>
<p>Note that the execution of some commands overlap in time, this is
what’s meant by concurrent and arguably it’s easier to see the overlap
here than in the original sequence diagram.</p>
<p>We’ve also abstracted away the counter, it’s a black box from the
perspective of the threads. The only thing we know for sure is when we
invoked the operation and when it returned, which is what our interval
captures. We also know that the effect of the operation must have
happened sometime within that interval.</p>
<p>One such concurrent history can have different interleavings,
depending on when exactly the effect of the commands happen. Here are
two possible interleavings, where the red cross symbolises when the
effect happened (i.e. when exactly the counter update its state).</p>
<p>The first corresponds to the sequential history
<code>&lt; incr 1, get, incr 2, get &gt;</code>:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter_get_1_3.svg"
width=60%></p>
<p>and the other interleaving corresponds to the sequential history
<code>&lt; incr 1, incr 2, get, get &gt;</code>:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/stateful-pbt-with-fakes/main/images/concurrent_counter_get_3_3.svg"
width=60%></p>
<p>One last thing we’ve left out from the concurrent history so far is
the responses. In this example, the only interesting responses are those
of the <code>get</code>s.</p>
<p>Let’s say that the <code>get</code>s returned <code>1</code> and
<code>3</code> respectively. Is this a correct concurrent outcome? Yes,
according to linearisability it’s enough to find a single interleaving
for which the sequential state machine model can explain the outcome and
in this case the first interleaving above
<code>&lt; incr 1, get, incr 2, get &gt;</code> does that.</p>
<p>What if the <code>get</code>s both returned <code>3</code>? That’s
also correct and witnessed by the second interleaving
<code>&lt; incr 1, incr 2, get, get &gt;</code>. When we can find a
sequential interleaving that supports the outcome of a concurrent
execution we say that the concurrent history linearises.</p>
<p>If the <code>get</code> on the third thread returned <code>1</code>
or <code>2</code> however, then it would be a non-linearisable outcome.
We can see visually that that <code>get</code> happens after both
<code>incr</code>, so no matter where we choose to place the red crosses
on the <code>incr</code>s the effects will happen before that
<code>get</code> so it must return <code>3</code>. Is it even possible
that <code>1</code> or <code>2</code> are returned? It’s, imagine if
<code>incr</code> is implemented by first reading the current value then
storing the incremented value, in that case there can be a race where
the <code>incr</code>s overwrite each other.</p>
<p>So to summarise, we execute commands concurrently using several
threads and gather a concurrent history of the execution. We then try to
find a sequential interleaving (a choice of where the red crosses in the
diagrams should be) which respects the a sequential state machine model
specification. If we find a single one that does, then we say that the
history linearises and that the concurrent execution is correct, if we
cannot find a sequential interleaving that respects the model then the
history doesn’t linearise and we have found a problem.</p>
<section id="parallel-library-implementation" class="level4">
<h4><a href="#parallel-library-implementation"
title="Parallel library implementation">Parallel library
implementation</a></h4>
<p>Let’s try to implement the above. We’ll split up the implementation
in three parts. First, we’ll show how to generate and shrink parallel
commands, these will be different than the sequential commands as we
have more than one thread that does the execution. Second, we’ll have a
look at how to execute the generated parallel commands to produce a
concurrent history. Finally, we’ll implement linearisability checking by
trying to find an interleaving of the concurrent history which respects
the sequential model.</p>
<section id="parallel-program-generation-and-shrinking" class="level5">
<h5><a href="#parallel-program-generation-and-shrinking"
title="Parallel program generation and shrinking">Parallel program
generation and shrinking</a></h5>
<p>First we need define what a parallel program is:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ParallelCommands</span> state <span class="ot">=</span> <span class="dt">ParallelCommands</span> [<span class="dt">Fork</span> state]</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fork</span> state <span class="ot">=</span> <span class="dt">Fork</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span></code></pre></div>
<p>The idea is that the commands inside <code>Fork</code>s get executed
in parallel, this list will only be between one and three commands long,
i.e. capturing single, double or triple threaded execution. The amount
of <code>Fork</code>s themselves vary with the size of the test case,
just like when we were doing the sequential testing.</p>
<p>Depending on the order in which the commands in the
<code>Fork</code>s get executed, we can potentially get different
models. For example
<code>Fork [Write "a" "foo", Write "a" "bar"]</code>, depending on which
branch of the <code>Fork</code> gets executed first we might end up with
either <code>"foo"</code> or <code>"bar"</code> being written to
<code>"a"</code>.</p>
<p>Because of this, we have generalised generation and shrinking to work
on a set of states rather than just a single state:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">StateModel</span> state, <span class="dt">Ord</span> state) <span class="ot">=&gt;</span> <span class="dt">ParallelModel</span> state <span class="kw">where</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommandParallel ::</span> [state] <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  generateCommandParallel ss <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    s <span class="ot">&lt;-</span> elements ss</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    generateCommand s</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  shrinkCommandParallel ::</span> [state] <span class="ot">-&gt;</span> <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>                        <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))]</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>  shrinkCommandParallel ss cmd <span class="ot">=</span> shrinkCommand (<span class="fu">maximum</span> ss) cmd</span></code></pre></div>
<p>Notice that the default implementation for generation, which should
be good enough for most examples, picks an arbitrary state and reuses
the generation function from the sequential case. Similar shrinking
picks the biggest state (determined by the <code>Ord</code> instance) as
the default implementation. The user is able to override these defaults,
in case generation or shrinking depends on some more specific state.</p>
<p>We can now write a generator for parallel programs.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> (<span class="dt">ParallelCommands</span> state)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> <span class="dt">ParallelCommands</span> <span class="op">&lt;$&gt;</span> go [initialState]</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      go ::</span> [state] <span class="ot">-&gt;</span> <span class="dt">Gen</span> [<span class="dt">Fork</span> state]</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>      go ss <span class="ot">=</span> sized <span class="op">$</span> \n <span class="ot">-&gt;</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>          w <span class="ot">=</span> n <span class="ot">`div`</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>          frequency</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>            [ (<span class="dv">1</span>, <span class="fu">return</span> [])</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>            , (w, <span class="kw">do</span> k <span class="ot">&lt;-</span> frequency [ (<span class="dv">50</span>, <span class="fu">return</span> <span class="dv">1</span>) <span class="co">-- 50% single threaded</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>                                    , (<span class="dv">30</span>, <span class="fu">return</span> <span class="dv">2</span>) <span class="co">-- 30% double threaded</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>                                    , (<span class="dv">20</span>, <span class="fu">return</span> <span class="dv">3</span>) <span class="co">-- 20% triple threaded</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>                                    ]</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>                     mCmds <span class="ot">&lt;-</span> vectorOf k (generateCommandParallel ss)</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>                                <span class="ot">`suchThatMaybe`</span> (parallelSafe ss <span class="op">.</span> <span class="dt">Fork</span>)</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">case</span> mCmds <span class="kw">of</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="fu">return</span> []</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Just</span> cmds <span class="ot">-&gt;</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>                         (<span class="dt">Fork</span> cmds <span class="op">:</span>) <span class="op">&lt;$&gt;</span> go (nextStates ss cmds))</span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>            ]</span></code></pre></div>
<p>Where <code>nextStates</code> gives all potential next states and is
defined as follows.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nextStates ::</span> (<span class="dt">StateModel</span> state, <span class="dt">Ord</span> state)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=&gt;</span> [state] <span class="ot">-&gt;</span> [<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))] <span class="ot">-&gt;</span> [state]</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>nextStates ss cmds <span class="ot">=</span> nubOrd [ foldl&#39; nextState s cmds <span class="op">|</span> s <span class="ot">&lt;-</span> ss ]</span></code></pre></div>
<p>The other helper function that we need for generation is
<code>parallelSafe</code>, which requires a bit of background.</p>
<p>In the sequential case a precondition is a contract that needs to be
fulfilled by the client before the command is issued. In the parallel
case there are multiple clients, so it could be the case that one client
unknowingly breaks another clients precondition. For example
<code>Fork [Write "a" "foo", Delete "a"]</code>, where the precondition
for both commands is that <code>"a"</code> exists. If
<code>Delete</code> gets executed first then it would break
<code>Write</code>’s precondition.</p>
<p>The solution to the precondition problem is to check that they hold
in all possible interleavings of a <code>Fork</code>, which is what
<code>parallelSafe</code> does:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parallelSafe ::</span> <span class="dt">ParallelModel</span> state <span class="ot">=&gt;</span> [state] <span class="ot">-&gt;</span> <span class="dt">Fork</span> state <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>parallelSafe ss (<span class="dt">Fork</span> cmds0) <span class="ot">=</span> <span class="fu">and</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  [ preconditionsHold s cmds <span class="op">|</span> s <span class="ot">&lt;-</span> toList ss, cmds <span class="ot">&lt;-</span> permutations cmds0 ]</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    preconditionsHold s0 <span class="ot">=</span> <span class="fu">all</span> (go s0) <span class="op">.</span> permutations</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        go _s [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        go  s (cmd <span class="op">:</span> cmds)</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> precondition s cmd <span class="ot">=</span> go (nextState s cmd) cmds</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span>          <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>While shrinking we also use <code>parallelSafe</code>:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  shrink ::</span> <span class="dt">ParallelCommands</span> state <span class="ot">-&gt;</span> [<span class="dt">ParallelCommands</span> state]</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  shrink <span class="ot">=</span> pruneShrinks <span class="op">.</span> possibleShrinks</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      possibleShrinks ::</span> <span class="dt">ParallelCommands</span> state <span class="ot">-&gt;</span> [<span class="dt">ParallelCommands</span> state]</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>      possibleShrinks</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">=</span> <span class="fu">map</span> (coerce <span class="op">.</span> <span class="fu">map</span> (<span class="fu">map</span> <span class="fu">fst</span>))</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span> shrinkList (shrinkList shrinker) <span class="op">.</span> withParStates <span class="op">.</span> unParallelCommands</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="ot">          withParStates ::</span> (<span class="dt">StateModel</span> state, <span class="dt">Ord</span> state)</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>                        <span class="ot">=&gt;</span> [<span class="dt">Fork</span> state]</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>                        <span class="ot">-&gt;</span> [[(<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)), [state])]]</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>          withParStates <span class="ot">=</span> go [initialState] [] <span class="op">.</span> coerce</span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>              go _ss acc []             <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>              go  ss acc (cmds <span class="op">:</span> cmdss) <span class="ot">=</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>                go (nextStates ss cmds) (<span class="fu">map</span> (\cmd <span class="ot">-&gt;</span> (cmd, ss)) cmds <span class="op">:</span> acc) cmdss</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a><span class="ot">          shrinker ::</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)), [state])</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">-&gt;</span> [(<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)), [state])]</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>          shrinker (cmd, ss) <span class="ot">=</span> [ (cmd&#39;, ss) <span class="op">|</span> cmd&#39; <span class="ot">&lt;-</span> shrinkCommandParallel ss cmd ]</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a><span class="ot">      pruneShrinks ::</span> [<span class="dt">ParallelCommands</span> state] <span class="ot">-&gt;</span> [<span class="dt">ParallelCommands</span> state]</span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>      pruneShrinks <span class="ot">=</span> coerce <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span>)</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>                   <span class="op">.</span> <span class="fu">map</span> (go [initialState] Set.empty [] <span class="op">.</span> unParallelCommands)</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a><span class="ot">          go ::</span> [state] <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">Var</span> (<span class="dt">Reference</span> state)) <span class="ot">-&gt;</span> [<span class="dt">Fork</span> state] <span class="ot">-&gt;</span> [<span class="dt">Fork</span> state] <span class="ot">-&gt;</span> [<span class="dt">Fork</span> state]</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>          go _ss _vars acc [] <span class="ot">=</span> <span class="fu">reverse</span> acc</span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>          go  ss  vars acc (fork<span class="op">@</span>(<span class="dt">Fork</span> cmds) <span class="op">:</span> forks)</span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">all</span> (scopeCheck vars) cmds</span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>            , parallelSafe ss fork <span class="ot">=</span></span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span></span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>                ss&#39;   <span class="ot">=</span> nextStates ss cmds</span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>                vars&#39; <span class="ot">=</span> getReturnedVars (<span class="fu">head</span> ss) vars cmds <span class="co">-- </span><span class="al">NOTE</span><span class="co">: head is safe</span></span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span></span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a>                go ss&#39; vars&#39; (fork <span class="op">:</span> acc) forks</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span>            <span class="ot">=</span> go ss vars acc forks</span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-38"><a href="#cb58-38" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- It doesn&#39;t matter which of the possible states we start in, as all</span></span>
<span id="cb58-39"><a href="#cb58-39" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- commands in a fork pass their preconditions in all states. It also</span></span>
<span id="cb58-40"><a href="#cb58-40" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- doesn&#39;t matter in which interleaving we gather the responses, as</span></span>
<span id="cb58-41"><a href="#cb58-41" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- all we do is collect the `Var`s that get returned into an unordered</span></span>
<span id="cb58-42"><a href="#cb58-42" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- `Set`.</span></span>
<span id="cb58-43"><a href="#cb58-43" aria-hidden="true" tabindex="-1"></a>          getReturnedVars _s vars [] <span class="ot">=</span> vars</span>
<span id="cb58-44"><a href="#cb58-44" aria-hidden="true" tabindex="-1"></a>          getReturnedVars s vars (cmd <span class="op">:</span> cmds) <span class="ot">=</span> <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb58-45"><a href="#cb58-45" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Left</span> _preconditionFailed <span class="ot">-&gt;</span></span>
<span id="cb58-46"><a href="#cb58-46" aria-hidden="true" tabindex="-1"></a>              <span class="fu">error</span> <span class="st">&quot;getReturnedVars: impossible, parallelSafe checks that all preconditions hold&quot;</span></span>
<span id="cb58-47"><a href="#cb58-47" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Right</span> (_s&#39;, resp) <span class="ot">-&gt;</span></span>
<span id="cb58-48"><a href="#cb58-48" aria-hidden="true" tabindex="-1"></a>              getReturnedVars s (vars <span class="ot">`Set.union`</span> Set.fromList (toList resp)) cmds</span></code></pre></div>
<p>In addition we also check that shrinking doesn’t create any scoping
issues, i.e. if we remove a command which creates a symbolic variable we
also need to remove any fork that contains a command which uses said
symbolic variable.</p>
<p>Another option is to skip the scope checking and instead require the
user to explicitly require preconditions which ensure the scope<a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p>
</section>
<section id="parallel-running" class="level5">
<h5><a href="#parallel-running" title="Parallel running">Parallel
running</a></h5>
<p>One final difference between the sequential and the parallel case is
that because of the use of threads to achieve parallel execution, and
the fact we can only spawn threads of things of type <code>IO</code>, we
also need to be able to interpret our <code>CommandMonad</code> into
<code>IO</code>, which is what <code>runCommandMonad</code> (which is
also part of the <code>ParallelModel</code> type class) does.</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- If another command monad is used we need to provide a way run it inside the</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- IO monad. This is only needed for parallel testing, because IO is the only</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- monad we can execute on different threads.</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  runCommandMonad ::</span> proxy state <span class="ot">-&gt;</span> <span class="dt">CommandMonad</span> state a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>We can now implement parallel execution of commands as follows:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">History</span> state <span class="ot">=</span> <span class="dt">History</span> [<span class="dt">Event</span> state]</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> stock <span class="kw">instance</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>   (<span class="dt">Show</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))),</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Show</span> (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">History</span> state)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Event</span> state</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Invoke</span> <span class="dt">Pid</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Ok</span>     <span class="dt">Pid</span> (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> stock <span class="kw">instance</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Show</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))),</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Show</span> (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Event</span> state)</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Pid</span> <span class="ot">=</span> <span class="dt">Pid</span> <span class="dt">Int</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> <span class="dt">Enum</span></span></code></pre></div>
<div class="sourceCode" id="cb61"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runParallelCommands ::</span> <span class="kw">forall</span> state<span class="op">.</span> <span class="dt">ParallelModel</span> state</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">=&gt;</span> <span class="dt">ParallelCommands</span> state <span class="ot">-&gt;</span> <span class="dt">PropertyM</span> <span class="dt">IO</span> ()</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>runParallelCommands cmds0<span class="op">@</span>(<span class="dt">ParallelCommands</span> forks0) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  forM_ (parallelCommands cmds0) <span class="op">$</span> \cmd <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> name <span class="ot">=</span> commandName cmd</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    monitor (tabulate <span class="st">&quot;Commands&quot;</span> [name] <span class="op">.</span> classify <span class="dt">True</span> name)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  monitor (tabulate <span class="st">&quot;Concurrency&quot;</span> (<span class="fu">map</span> (<span class="fu">show</span> <span class="op">.</span> <span class="fu">length</span> <span class="op">.</span> unFork) forks0))</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  q   <span class="ot">&lt;-</span> liftIO newTQueueIO</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>  c   <span class="ot">&lt;-</span> liftIO newAtomicCounter</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  env <span class="ot">&lt;-</span> liftIO (runForks q c emptyEnv forks0)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  hist <span class="ot">&lt;-</span> <span class="dt">History</span> <span class="op">&lt;$&gt;</span> liftIO (atomically (flushTQueue q))</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ok <span class="ot">=</span> linearisable env (interleavings hist)</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>  unless ok (monitor (counterexample (<span class="fu">show</span> hist)))</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>  assert ok</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    runForks ::</span> <span class="dt">TQueue</span> (<span class="dt">Event</span> state) <span class="ot">-&gt;</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> state <span class="ot">-&gt;</span> [<span class="dt">Fork</span> state]</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Env</span> state)</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>    runForks _q _c env [] <span class="ot">=</span> <span class="fu">return</span> env</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    runForks  q  c env (<span class="dt">Fork</span> cmds <span class="op">:</span> forks) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>      envs <span class="ot">&lt;-</span> liftIO <span class="op">$</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>        mapConcurrently (runParallelReal q c env) (<span class="fu">zip</span> [<span class="dt">Pid</span> <span class="dv">0</span><span class="op">..</span>] cmds)</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> env&#39; <span class="ot">=</span> combineEnvs (env <span class="op">:</span> envs)</span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>      runForks q c env&#39; forks</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a><span class="ot">    runParallelReal ::</span> <span class="dt">TQueue</span> (<span class="dt">Event</span> state) <span class="ot">-&gt;</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> <span class="dt">Env</span> state</span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">-&gt;</span> (<span class="dt">Pid</span>, <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state))) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Env</span> state)</span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>    runParallelReal q c env (pid, cmd) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>      atomically (writeTQueue q (<span class="dt">Invoke</span> pid cmd))</span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>      eResp <span class="ot">&lt;-</span> try (runCommandMonad (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> state) (runReal (<span class="fu">fmap</span> (lookupEnv env) cmd)))</span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> eResp <span class="kw">of</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> (<span class="ot">err ::</span> <span class="dt">SomeException</span>) <span class="ot">-&gt;</span></span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>          <span class="fu">error</span> (<span class="st">&quot;runParallelReal: &quot;</span> <span class="op">++</span> displayException err)</span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> resp <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- </span><span class="al">NOTE</span><span class="co">: It&#39;s important that we extend the environment before writing `Ok`</span></span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- to the history, otherwise we might get scope issues.</span></span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>          env&#39; <span class="ot">&lt;-</span> extendEnvParallel env c (toList resp)</span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>          atomically (writeTQueue q (<span class="dt">Ok</span> pid resp))</span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>          <span class="fu">return</span> env&#39;</span></code></pre></div>
<p>Extending the environment in the parallel case requires an atomic
counter in order to avoid more than one thread adding the same
variable:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">AtomicCounter</span> <span class="ot">=</span> <span class="dt">AtomicCounter</span> (<span class="dt">IORef</span> <span class="dt">Int</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="ot">newAtomicCounter ::</span> <span class="dt">IO</span> <span class="dt">AtomicCounter</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>newAtomicCounter <span class="ot">=</span> <span class="dt">AtomicCounter</span> <span class="op">&lt;$&gt;</span> newIORef <span class="dv">0</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Returns old value.</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="ot">incrAtomicCounter ::</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>incrAtomicCounter (<span class="dt">AtomicCounter</span> ioRef) n <span class="ot">=</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>  atomicModifyIORef&#39; ioRef (\old <span class="ot">-&gt;</span> (old <span class="op">+</span> n, old))</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span class="ot">extendEnvParallel ::</span> <span class="dt">Env</span> state <span class="ot">-&gt;</span> <span class="dt">AtomicCounter</span> <span class="ot">-&gt;</span> [<span class="dt">Reference</span> state] <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Env</span> state)</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>extendEnvParallel env c refs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> incrAtomicCounter c (<span class="fu">length</span> refs)</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (extendEnv env (<span class="fu">zip</span> [i<span class="op">..</span>] refs))</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a><span class="ot">combineEnvs ::</span> [<span class="dt">Env</span> state] <span class="ot">-&gt;</span> <span class="dt">Env</span> state</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>combineEnvs <span class="ot">=</span> <span class="dt">Env</span> <span class="op">.</span> IntMap.unions <span class="op">.</span> <span class="fu">map</span> unEnv</span></code></pre></div>
<p>Hopefully the execution part is clear, next let’s have a look at how
we check the result of an execution.</p>
</section>
<section id="linearisability-checking" class="level5">
<h5><a href="#linearisability-checking"
title="Linearisability checking">Linearisability checking</a></h5>
<p>Recall from our parallel counter example in the introduction to
parallel testing that it’s enough to find <em>any</em> possible
interleaving which respects the sequential model. So let’s start by
enumerating all possible interleavings using a <a
href="https://hackage.haskell.org/package/containers-0.7/docs/Data-Tree.html"><code>Rose</code>
tree</a> data structure:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Op</span> state <span class="ot">=</span> <span class="dt">Op</span> (<span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>                   (<span class="dt">Response</span> state (<span class="dt">Reference</span> state))</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="ot">interleavings ::</span> <span class="dt">History</span> state <span class="ot">-&gt;</span> <span class="dt">Forest</span> (<span class="dt">Op</span> state)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>interleavings (<span class="dt">History</span> [])  <span class="ot">=</span> []</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>interleavings (<span class="dt">History</span> evs0) <span class="ot">=</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">Node</span> (<span class="dt">Op</span> cmd resp) (interleavings (<span class="dt">History</span> evs&#39;))</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> (tid, cmd)   <span class="ot">&lt;-</span> takeInvocations evs0</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>  , (resp, evs&#39;) <span class="ot">&lt;-</span> findResponse tid</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>                      (filter1 (<span class="fu">not</span> <span class="op">.</span> matchInvocation tid) evs0)</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    takeInvocations ::</span> [<span class="dt">Event</span> state] <span class="ot">-&gt;</span> [(<span class="dt">Pid</span>, <span class="dt">Command</span> state (<span class="dt">Var</span> (<span class="dt">Reference</span> state)))]</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>    takeInvocations []                         <span class="ot">=</span> []</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>    takeInvocations ((<span class="dt">Invoke</span> pid cmd)   <span class="op">:</span> evs) <span class="ot">=</span> (pid, cmd) <span class="op">:</span> takeInvocations evs</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    takeInvocations ((<span class="dt">Ok</span>    _pid _resp) <span class="op">:</span> _)   <span class="ot">=</span> []</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a><span class="ot">    findResponse ::</span> <span class="dt">Pid</span> <span class="ot">-&gt;</span> [<span class="dt">Event</span> state] <span class="ot">-&gt;</span> [(<span class="dt">Response</span> state (<span class="dt">Reference</span> state), [<span class="dt">Event</span> state])]</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    findResponse _pid []                                   <span class="ot">=</span> []</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>    findResponse  pid ((<span class="dt">Ok</span> pid&#39; resp) <span class="op">:</span> evs) <span class="op">|</span> pid <span class="op">==</span> pid&#39; <span class="ot">=</span> [(resp, evs)]</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>    findResponse  pid (ev             <span class="op">:</span> evs)               <span class="ot">=</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>      [ (resp, ev <span class="op">:</span> evs&#39;) <span class="op">|</span> (resp, evs&#39;) <span class="ot">&lt;-</span> findResponse pid evs ]</span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a><span class="ot">    matchInvocation ::</span> <span class="dt">Pid</span> <span class="ot">-&gt;</span> <span class="dt">Event</span> state <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>    matchInvocation pid (<span class="dt">Invoke</span> pid&#39; _cmd) <span class="ot">=</span> pid <span class="op">==</span> pid&#39;</span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>    matchInvocation _   _                  <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a><span class="ot">    filter1 ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>    filter1 _ []                   <span class="ot">=</span> []</span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>    filter1 p (x <span class="op">:</span> xs) <span class="op">|</span> p x       <span class="ot">=</span> x <span class="op">:</span> filter1 p xs</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>                       <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> xs</span></code></pre></div>
<p>We can then check if there is a path through this rose tree which
agrees with the sequential model:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearisable ::</span> <span class="kw">forall</span> state<span class="op">.</span> <span class="dt">StateModel</span> state</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">=&gt;</span> <span class="dt">Env</span> state <span class="ot">-&gt;</span> <span class="dt">Forest</span> (<span class="dt">Op</span> state) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>linearisable env <span class="ot">=</span> any&#39; (go initialState)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> state <span class="ot">-&gt;</span> <span class="dt">Tree</span> (<span class="dt">Op</span> state) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    go s (<span class="dt">Node</span> (<span class="dt">Op</span> cmd cresp) ts) <span class="ot">=</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> runFake cmd s <span class="kw">of</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> _preconditionFailure <span class="ot">-&gt;</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>          <span class="fu">error</span> <span class="st">&quot;linearisable: impossible, all precondtions are satisifed during generation&quot;</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> (s&#39;, resp) <span class="ot">-&gt;</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>          cresp <span class="op">==</span> <span class="fu">fmap</span> (lookupEnv env) resp <span class="op">&amp;&amp;</span> any&#39; (go s&#39;) ts</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    any&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    any&#39; _p [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    any&#39;  p xs <span class="ot">=</span> <span class="fu">any</span> p xs</span></code></pre></div>
</section>
</section>
<section id="example-parallel-counter" class="level4">
<h4><a href="#example-parallel-counter"
title="Example: parallel counter">Example: parallel counter</a></h4>
<p>Having defined the <code>ParallelModel</code> interface (which
depends on the <code>StateModel</code> interface from the sequential
testing) and programmed our parallel generation, shrinking and parallel
execution and linearisability checking against this interface, we
basically get parallel testing for free by reusing the sequential
model.</p>
<section id="testing-1" class="level5">
<h5><a href="#testing-1" title="Testing">Testing</a></h5>
<p>This is the only new code we need to add to enable parallel testing
of our <code>Counter</code> example<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a> from before:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ParallelModel</span> <span class="dt">Counter</span> <span class="kw">where</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The command monad is IO, so we don&#39;t need to do anything here.</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  runCommandMonad _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_parallelCounter ::</span> <span class="dt">ParallelCommands</span> <span class="dt">Counter</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>prop_parallelCounter cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  replicateM_ <span class="dv">10</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    run reset</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    runParallelCommands cmds</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span></code></pre></div>
<p>If we run the above property with <code>runReal</code></p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>  runReal <span class="dt">Incr</span> <span class="ot">=</span> <span class="dt">Incr_</span> <span class="op">&lt;$&gt;</span> incrRaceCondition</span></code></pre></div>
<p>being implemented using an increment with a race condition:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">incrRaceCondition ::</span> <span class="dt">IO</span> ()</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>incrRaceCondition <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>then a failure is found:</p>
<pre><code> Assertion failed (after 36 tests and 1 shrink):
      ParallelCommands [Fork [Incr,Incr],Fork [Incr],Fork [Get,Get,Get],
                        Fork [Incr],Fork [Get,Get],Fork [Get,Get],
                        Fork [Incr],Fork [Get,Get,Incr],Fork [Incr],
                        Fork [Get,Get,Get],Fork [Incr,Incr],
                        Fork [Incr,Get],Fork [Incr,Incr],Fork [Get],
                        Fork [Incr]]</code></pre>
<p>However, shrinking didn’t work well. The reason for this is that
QuickCheck tries a smaller test case (which still has the race
condition), but because of a different interleaving of threads the race
doesn’t get triggered and so QuickCheck thinks it found the minimal test
case (because the smaller test case, that the shrinker picked,
passes).</p>
<p>The proper solution to this problem is to use a deterministic thread
scheduler, this is what they do the parallel testing <a
href="https://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf">paper</a>.
A simpler workaround is to introduce a small sleep after each read or
write to shared memory, this will make it more likely that the same
interleaving happens when we shrink the test:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">incrRaceCondition ::</span> <span class="dt">IO</span> ()</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>incrRaceCondition <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readIORef gLOBAL_COUNTER</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  threadDelay <span class="dv">100</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  writeIORef gLOBAL_COUNTER (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>  threadDelay <span class="dv">100</span></span></code></pre></div>
<p>With this change we get the minimal test case that triggers the race
condition:</p>
<pre><code>Assertion failed (after 6 tests and 4 shrinks):
      ParallelCommands [Fork [Incr,Incr],Fork [Get]]</code></pre>
<p>We can avoid having to sprinkle sleeps around our interaction with
shared state by creating a module with the same operations as on shared
memory where the sleep is already included:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">SleepyIORef</span> (<span class="kw">module</span> <span class="dt">SleepyIORef</span>, <span class="dt">IORef</span>) <span class="kw">where</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span> (threadDelay)</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IORef</span> (<span class="dt">IORef</span>)</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.IORef</span> <span class="kw">as</span> <span class="dt">IORef</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="ot">readIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>readIORef ref <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>  threadDelay <span class="dv">1000</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>  IORef.readIORef ref</span></code></pre></div>
<p>That way if we find a race, we can change the import from
<code>import Data.IORef</code> to <code>import SleepyIORef</code> and
rerun the tests and get better shrinking. This situation is not ideal,
but save us the trouble of having to re-implement a scheduler. It’s
worth stressing that the race is found in the unmodified code and the
introduction of sleep is only needed to make the counterexample
smaller.</p>
</section>
</section>
<section id="example-process-registry" class="level4">
<h4><a href="#example-process-registry"
title="Example: process registry">Example: process registry</a></h4>
<p>For a slightly more complicated example containing race conditions,
let’s have a look at an implementation of the Erlang process registry<a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>.</p>
<section id="software-under-test-2" class="level5">
<h5><a href="#software-under-test-2"
title="Software under test">Software under test</a></h5>
<p>The idea behind Erlang’s process registry is that you can spawn
threads, register the <code>ThreadId</code> to some name of type string,
and then lookup the thread by name rather than its thread id. Threads
can also be unregistered and killed.</p>
<p>This is useful if threads die and get restarted and register the same
name, then other threads can easily find the thread id of the new thread
using the registry.</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE registry #-}</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="ot">registry ::</span> <span class="dt">IORef</span> [(<span class="dt">String</span>,<span class="dt">ThreadId</span>)]</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>registry <span class="ot">=</span> unsafePerformIO (newIORef [])</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="ot">alive ::</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>alive tid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>  s <span class="ot">&lt;-</span> threadStatus tid</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> s <span class="op">/=</span> <span class="dt">ThreadFinished</span> <span class="op">&amp;&amp;</span> s <span class="op">/=</span> <span class="dt">ThreadDied</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span class="ot">spawn ::</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>spawn <span class="ot">=</span> forkIO (threadDelay <span class="dv">100000000</span>)</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a><span class="ot">whereis ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">ThreadId</span>)</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>whereis name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>  reg <span class="ot">&lt;-</span> readRegistry</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">lookup</span> name reg</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a><span class="ot">register ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>register name tid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>  ok <span class="ot">&lt;-</span> alive tid</span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>  reg <span class="ot">&lt;-</span> readRegistry</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> ok <span class="op">&amp;&amp;</span> name <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">fst</span> reg <span class="op">&amp;&amp;</span> tid <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">snd</span> reg</span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef registry <span class="op">$</span> \reg&#39; <span class="ot">-&gt;</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>           <span class="kw">if</span> name <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">fst</span> reg&#39; <span class="op">&amp;&amp;</span> tid <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">snd</span> reg&#39;</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>             <span class="kw">then</span> ((name,tid)<span class="op">:</span>reg&#39;,())</span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>             <span class="kw">else</span> (reg&#39;,badarg)</span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> badarg</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a><span class="ot">unregister ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>unregister name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>  reg <span class="ot">&lt;-</span> readRegistry</span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> name <span class="ot">`elem`</span> <span class="fu">map</span> <span class="fu">fst</span> reg</span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> atomicModifyIORef registry <span class="op">$</span> \reg&#39; <span class="ot">-&gt;</span></span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>           (<span class="fu">filter</span> ((<span class="op">/=</span>name)<span class="op">.</span><span class="fu">fst</span>) reg&#39;,</span>
<span id="cb72-36"><a href="#cb72-36" aria-hidden="true" tabindex="-1"></a>            ())</span>
<span id="cb72-37"><a href="#cb72-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> badarg</span>
<span id="cb72-38"><a href="#cb72-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-39"><a href="#cb72-39" aria-hidden="true" tabindex="-1"></a><span class="ot">readRegistry ::</span> <span class="dt">IO</span> [(<span class="dt">String</span>, <span class="dt">ThreadId</span>)]</span>
<span id="cb72-40"><a href="#cb72-40" aria-hidden="true" tabindex="-1"></a>readRegistry <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-41"><a href="#cb72-41" aria-hidden="true" tabindex="-1"></a>  reg <span class="ot">&lt;-</span> readIORef registry</span>
<span id="cb72-42"><a href="#cb72-42" aria-hidden="true" tabindex="-1"></a>  garbage <span class="ot">&lt;-</span> filterM (<span class="fu">fmap</span> <span class="fu">not</span><span class="op">.</span>alive) (<span class="fu">map</span> <span class="fu">snd</span> reg)</span>
<span id="cb72-43"><a href="#cb72-43" aria-hidden="true" tabindex="-1"></a>  atomicModifyIORef&#39; registry <span class="op">$</span> \reg&#39; <span class="ot">-&gt;</span></span>
<span id="cb72-44"><a href="#cb72-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> reg&#39;&#39; <span class="ot">=</span> <span class="fu">filter</span> ((<span class="ot">`notElem`</span> garbage)<span class="op">.</span><span class="fu">snd</span>) reg&#39; <span class="kw">in</span> (reg&#39;&#39;,reg&#39;&#39;)</span>
<span id="cb72-45"><a href="#cb72-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-46"><a href="#cb72-46" aria-hidden="true" tabindex="-1"></a><span class="ot">badarg ::</span> a</span>
<span id="cb72-47"><a href="#cb72-47" aria-hidden="true" tabindex="-1"></a>badarg <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;bad argument&quot;</span></span>
<span id="cb72-48"><a href="#cb72-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-49"><a href="#cb72-49" aria-hidden="true" tabindex="-1"></a><span class="ot">kill ::</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb72-50"><a href="#cb72-50" aria-hidden="true" tabindex="-1"></a>kill tid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-51"><a href="#cb72-51" aria-hidden="true" tabindex="-1"></a>  killThread tid</span>
<span id="cb72-52"><a href="#cb72-52" aria-hidden="true" tabindex="-1"></a>  waitUntilDead <span class="dv">1000</span></span>
<span id="cb72-53"><a href="#cb72-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb72-54"><a href="#cb72-54" aria-hidden="true" tabindex="-1"></a><span class="ot">    waitUntilDead ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb72-55"><a href="#cb72-55" aria-hidden="true" tabindex="-1"></a>    waitUntilDead <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;kill: thread didn&#39;t die&quot;</span></span>
<span id="cb72-56"><a href="#cb72-56" aria-hidden="true" tabindex="-1"></a>    waitUntilDead n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb72-57"><a href="#cb72-57" aria-hidden="true" tabindex="-1"></a>      b <span class="ot">&lt;-</span> alive tid</span>
<span id="cb72-58"><a href="#cb72-58" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> b</span>
<span id="cb72-59"><a href="#cb72-59" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb72-60"><a href="#cb72-60" aria-hidden="true" tabindex="-1"></a>        threadDelay <span class="dv">1000</span></span>
<span id="cb72-61"><a href="#cb72-61" aria-hidden="true" tabindex="-1"></a>        waitUntilDead (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb72-62"><a href="#cb72-62" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="fu">return</span> ()</span></code></pre></div>
</section>
<section id="model-2" class="level5">
<h5><a href="#model-2" title="Model">Model</a></h5>
<p>The model of the process registry contains three things that we
haven’t seen before. The first thing to note is that
<code>Register</code> and <code>Unregister</code> might fail, so we use
an <code>Either ErrorCall</code> in their respective responses and a
function called <code>abstractError</code> to make the error from the
model and the error from the real implementation match up. It’s called
abstract, because it abstracts away details from the real
implementation, and it’s a useful technique to know as it can be applied
to other settings.</p>
<p>The second thing to notice is the use of <code>monitoring</code> to
keep statistics of how often <code>Register</code> and
<code>Unregister</code> actually do fail, this is useful coverage
information that ensures that our generators and or pre-conditions are
not too restrictive.</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RegState</span> <span class="ot">=</span> <span class="dt">RegState</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tids   ::</span> [<span class="dt">Var</span> <span class="dt">ThreadId</span>]</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> regs   ::</span> [(<span class="dt">String</span>, <span class="dt">Var</span> (<span class="dt">ThreadId</span>))]</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> killed ::</span> [<span class="dt">Var</span> <span class="dt">ThreadId</span>]</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StateModel</span> <span class="dt">RegState</span> <span class="kw">where</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  initialState ::</span> <span class="dt">RegState</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>  initialState <span class="ot">=</span> <span class="dt">RegState</span> [] [] []</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Reference</span> <span class="dt">RegState</span> <span class="ot">=</span> <span class="dt">ThreadId</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Command</span> <span class="dt">RegState</span> tid</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Spawn</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">WhereIs</span> <span class="dt">String</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Register</span> <span class="dt">String</span> tid</span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Unregister</span> <span class="dt">String</span></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Kill</span> tid</span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">Response</span> <span class="dt">RegState</span> tid</span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Spawn_</span> tid</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">WhereIs_</span> (<span class="dt">NonFoldable</span> (<span class="dt">Maybe</span> tid))</span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Register_</span> (<span class="dt">Either</span> <span class="dt">ErrorCall</span> ())</span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Unregister_</span> (<span class="dt">Either</span> <span class="dt">ErrorCall</span> ())</span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Kill_</span> ()</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a><span class="ot">  generateCommand ::</span> <span class="dt">RegState</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Command</span> <span class="dt">RegState</span> (<span class="dt">Var</span> <span class="dt">ThreadId</span>))</span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a>  generateCommand s <span class="ot">=</span> oneof <span class="op">$</span></span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a>    [ <span class="fu">return</span> <span class="dt">Spawn</span> ] <span class="op">++</span></span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">Register</span> <span class="op">&lt;$&gt;</span> arbitraryName <span class="op">&lt;*&gt;</span> elements (tids s) <span class="op">|</span> <span class="fu">not</span> (<span class="fu">null</span> (tids s)) ] <span class="op">++</span></span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">Unregister</span> <span class="op">&lt;$&gt;</span> arbitraryName</span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a>    , <span class="dt">WhereIs</span> <span class="op">&lt;$&gt;</span> arbitraryName</span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a>    ] <span class="op">++</span></span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">Kill</span> <span class="op">&lt;$&gt;</span> elements (tids s) <span class="op">|</span> <span class="fu">not</span> (<span class="fu">null</span> (tids s)) ]</span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a><span class="ot">      arbitraryName ::</span> <span class="dt">Gen</span> <span class="dt">String</span></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a>      arbitraryName <span class="ot">=</span> elements allNames</span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a><span class="ot">  runFake ::</span> <span class="dt">Command</span> <span class="dt">RegState</span> (<span class="dt">Var</span> <span class="dt">ThreadId</span>)<span class="ot">-&gt;</span> <span class="dt">RegState</span></span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Either</span> void (<span class="dt">RegState</span>, <span class="dt">Response</span> <span class="dt">RegState</span> (<span class="dt">Var</span> <span class="dt">ThreadId</span>))</span>
<span id="cb73-45"><a href="#cb73-45" aria-hidden="true" tabindex="-1"></a>  runFake <span class="dt">Spawn</span>               s <span class="ot">=</span> <span class="kw">let</span> tid <span class="ot">=</span> <span class="dt">Var</span> (<span class="fu">length</span> (tids s)) <span class="kw">in</span></span>
<span id="cb73-46"><a href="#cb73-46" aria-hidden="true" tabindex="-1"></a>                                  <span class="fu">return</span> (s { tids <span class="ot">=</span> tids s <span class="op">++</span> [tid] }, <span class="dt">Spawn_</span> tid)</span>
<span id="cb73-47"><a href="#cb73-47" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">WhereIs</span> name)      s <span class="ot">=</span> <span class="fu">return</span> (s, <span class="dt">WhereIs_</span> (<span class="dt">NonFoldable</span> (<span class="fu">lookup</span> name (regs s))))</span>
<span id="cb73-48"><a href="#cb73-48" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Register</span> name tid) s</span>
<span id="cb73-49"><a href="#cb73-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> tid <span class="ot">`elem`</span> tids s</span>
<span id="cb73-50"><a href="#cb73-50" aria-hidden="true" tabindex="-1"></a>    , name <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">fst</span> (regs s)</span>
<span id="cb73-51"><a href="#cb73-51" aria-hidden="true" tabindex="-1"></a>    , tid <span class="ot">`notElem`</span> <span class="fu">map</span> <span class="fu">snd</span> (regs s)</span>
<span id="cb73-52"><a href="#cb73-52" aria-hidden="true" tabindex="-1"></a>    , tid <span class="ot">`notElem`</span> killed s</span>
<span id="cb73-53"><a href="#cb73-53" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="fu">return</span> (s { regs <span class="ot">=</span> (name, tid) <span class="op">:</span> regs s }, <span class="dt">Register_</span> (<span class="dt">Right</span> ()))</span>
<span id="cb73-54"><a href="#cb73-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-55"><a href="#cb73-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span></span>
<span id="cb73-56"><a href="#cb73-56" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="fu">return</span> (s, <span class="dt">Register_</span> (<span class="dt">Left</span> (<span class="dt">ErrorCall</span> <span class="st">&quot;bad argument&quot;</span>)))</span>
<span id="cb73-57"><a href="#cb73-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-58"><a href="#cb73-58" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Unregister</span> name)   s</span>
<span id="cb73-59"><a href="#cb73-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> name <span class="ot">`elem`</span> <span class="fu">map</span> <span class="fu">fst</span> (regs s) <span class="ot">=</span></span>
<span id="cb73-60"><a href="#cb73-60" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (s { regs <span class="ot">=</span> remove name (regs s) }, <span class="dt">Unregister_</span> (<span class="dt">Right</span> ()))</span>
<span id="cb73-61"><a href="#cb73-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">return</span> (s, <span class="dt">Unregister_</span> (<span class="dt">Left</span> (<span class="dt">ErrorCall</span> <span class="st">&quot;bad argument&quot;</span>)))</span>
<span id="cb73-62"><a href="#cb73-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb73-63"><a href="#cb73-63" aria-hidden="true" tabindex="-1"></a>      remove x <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">/=</span> x) <span class="op">.</span> <span class="fu">fst</span>)</span>
<span id="cb73-64"><a href="#cb73-64" aria-hidden="true" tabindex="-1"></a>  runFake (<span class="dt">Kill</span> tid) s <span class="ot">=</span> <span class="fu">return</span> (s { killed <span class="ot">=</span> tid <span class="op">:</span> killed s</span>
<span id="cb73-65"><a href="#cb73-65" aria-hidden="true" tabindex="-1"></a>                                   , regs   <span class="ot">=</span> remove tid (regs s)}, <span class="dt">Kill_</span> ())</span>
<span id="cb73-66"><a href="#cb73-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb73-67"><a href="#cb73-67" aria-hidden="true" tabindex="-1"></a>      remove x <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">/=</span> x) <span class="op">.</span> <span class="fu">snd</span>)</span>
<span id="cb73-68"><a href="#cb73-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-69"><a href="#cb73-69" aria-hidden="true" tabindex="-1"></a><span class="ot">  runReal ::</span> <span class="dt">Command</span> <span class="dt">RegState</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">RegState</span> <span class="dt">ThreadId</span>)</span>
<span id="cb73-70"><a href="#cb73-70" aria-hidden="true" tabindex="-1"></a>  runReal <span class="dt">Spawn</span>               <span class="ot">=</span> <span class="dt">Spawn_</span>      <span class="op">&lt;$&gt;</span> spawn</span>
<span id="cb73-71"><a href="#cb73-71" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">WhereIs</span> name)      <span class="ot">=</span> <span class="dt">WhereIs_</span> <span class="op">.</span> <span class="dt">NonFoldable</span> <span class="op">&lt;$&gt;</span> whereis name</span>
<span id="cb73-72"><a href="#cb73-72" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Register</span> name tid) <span class="ot">=</span> <span class="dt">Register_</span>   <span class="op">&lt;$&gt;</span> <span class="fu">fmap</span> (left abstractError) (try (register name tid))</span>
<span id="cb73-73"><a href="#cb73-73" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Unregister</span> name)   <span class="ot">=</span> <span class="dt">Unregister_</span> <span class="op">&lt;$&gt;</span> <span class="fu">fmap</span> (left abstractError) (try (unregister name))</span>
<span id="cb73-74"><a href="#cb73-74" aria-hidden="true" tabindex="-1"></a>  runReal (<span class="dt">Kill</span> tid)          <span class="ot">=</span> <span class="dt">Kill_</span>       <span class="op">&lt;$&gt;</span> kill tid</span>
<span id="cb73-75"><a href="#cb73-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-76"><a href="#cb73-76" aria-hidden="true" tabindex="-1"></a><span class="ot">  monitoring ::</span> (<span class="dt">RegState</span>, <span class="dt">RegState</span>) <span class="ot">-&gt;</span> <span class="dt">Command</span> <span class="dt">RegState</span> <span class="dt">ThreadId</span></span>
<span id="cb73-77"><a href="#cb73-77" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="dt">RegState</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">Property</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb73-78"><a href="#cb73-78" aria-hidden="true" tabindex="-1"></a>  monitoring (_s, s&#39;) cmd resp <span class="ot">=</span></span>
<span id="cb73-79"><a href="#cb73-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb73-80"><a href="#cb73-80" aria-hidden="true" tabindex="-1"></a>      aux tag <span class="ot">=</span> classify <span class="dt">True</span> (<span class="fu">show</span> tag)</span>
<span id="cb73-81"><a href="#cb73-81" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span> counterexample (<span class="st">&quot;\n    State: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s&#39; <span class="op">++</span> <span class="st">&quot;\n&quot;</span>)</span>
<span id="cb73-82"><a href="#cb73-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb73-83"><a href="#cb73-83" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> (cmd, resp) <span class="kw">of</span></span>
<span id="cb73-84"><a href="#cb73-84" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Register</span>   {}, <span class="dt">Register_</span>   (<span class="dt">Left</span> _))  <span class="ot">-&gt;</span> aux <span class="dt">RegisterFailed</span></span>
<span id="cb73-85"><a href="#cb73-85" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Register</span>   {}, <span class="dt">Register_</span>   (<span class="dt">Right</span> _)) <span class="ot">-&gt;</span> aux <span class="dt">RegisterSucceeded</span></span>
<span id="cb73-86"><a href="#cb73-86" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Unregister</span> {}, <span class="dt">Unregister_</span> (<span class="dt">Left</span> _))  <span class="ot">-&gt;</span> aux <span class="dt">UnregisterFailed</span></span>
<span id="cb73-87"><a href="#cb73-87" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Unregister</span> {}, <span class="dt">Unregister_</span> (<span class="dt">Right</span> _)) <span class="ot">-&gt;</span> aux <span class="dt">UnregisterSucceeded</span></span>
<span id="cb73-88"><a href="#cb73-88" aria-hidden="true" tabindex="-1"></a>        _otherwise <span class="ot">-&gt;</span> counterexample <span class="op">$</span> <span class="st">&quot;\n    State: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s&#39; <span class="op">++</span> <span class="st">&quot;\n&quot;</span></span>
<span id="cb73-89"><a href="#cb73-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-90"><a href="#cb73-90" aria-hidden="true" tabindex="-1"></a><span class="co">-- Throws away the location information from the error, so that it matches up</span></span>
<span id="cb73-91"><a href="#cb73-91" aria-hidden="true" tabindex="-1"></a><span class="co">-- with the fake.</span></span>
<span id="cb73-92"><a href="#cb73-92" aria-hidden="true" tabindex="-1"></a><span class="ot">abstractError ::</span> <span class="dt">ErrorCall</span> <span class="ot">-&gt;</span> <span class="dt">ErrorCall</span></span>
<span id="cb73-93"><a href="#cb73-93" aria-hidden="true" tabindex="-1"></a>abstractError (<span class="dt">ErrorCallWithLocation</span> msg _loc) <span class="ot">=</span> <span class="dt">ErrorCall</span> msg</span>
<span id="cb73-94"><a href="#cb73-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-95"><a href="#cb73-95" aria-hidden="true" tabindex="-1"></a><span class="ot">allNames ::</span> [<span class="dt">String</span>]</span>
<span id="cb73-96"><a href="#cb73-96" aria-hidden="true" tabindex="-1"></a>allNames <span class="ot">=</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;e&quot;</span>]</span>
<span id="cb73-97"><a href="#cb73-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-98"><a href="#cb73-98" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tag</span> <span class="ot">=</span> <span class="dt">RegisterFailed</span> <span class="op">|</span> <span class="dt">RegisterSucceeded</span> <span class="op">|</span> <span class="dt">UnregisterFailed</span> <span class="op">|</span> <span class="dt">UnregisterSucceeded</span></span>
<span id="cb73-99"><a href="#cb73-99" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>The last new thing to note here is that <code>WhereIs_</code> returns
the thread id that we wanted to look up, but thread ids also happen to
be references. The way we implemented extending the environment with new
references is that we call <code>Data.Foldable.toList</code> on all
responses, which gives us all references from the responses. In the
<code>Spawn_</code> case this does the right thing, since spawn returns
a reference to the newly spawned thread id, but in this case the thread
id from <code>WhereIs_</code> is not a new reference (it’s merely a
reference to the thread id we wanted to look up), so we shouldn’t extend
the environment with the reference that <code>WhereIs_</code> returns.
We solve this problem with wrapping the response of
<code>WhereIs_</code> in <code>NonFoldable</code> which has a
<code>toList</code> which doesn’t return anything.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">NonFoldable</span> a <span class="ot">=</span> <span class="dt">NonFoldable</span> a</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">NonFoldable</span> <span class="kw">where</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">NonFoldable</span> x) <span class="ot">=</span> <span class="dt">NonFoldable</span> (f x)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">NonFoldable</span> <span class="kw">where</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldMap</span> _f (<span class="dt">NonFoldable</span> _x) <span class="ot">=</span> <span class="fu">mempty</span></span></code></pre></div>
</section>
<section id="testing-2" class="level5">
<h5><a href="#testing-2" title="Testing">Testing</a></h5>
<p>We can now write our sequential testing property as we’ve done
earlier for the other examples.</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_registry ::</span> <span class="dt">Commands</span> <span class="dt">RegState</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>prop_registry cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>  void (run cleanUp)</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>  runCommands cmds</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="ot">cleanUp ::</span> <span class="dt">IO</span> [<span class="dt">Either</span> <span class="dt">ErrorCall</span> ()]</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>cleanUp <span class="ot">=</span> <span class="fu">sequence</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>  [ try (unregister name)<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ErrorCall</span> ())</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> name <span class="ot">&lt;-</span> allNames</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>This property passes and we can see, thanks to our
<code>monitoring</code>, that we got good coverage of failing commands
as well:</p>
<pre><code>  +++ OK, passed 100 tests:
  83% Spawn
  82% WhereIs
  79% Unregister
  78% UnregisterFailed
  70% Kill
  70% Register
  62% RegisterFailed
  59% RegisterSucceeded
  29% UnregisterSucceeded</code></pre>
<p>To make sure everything works as expected, let’s introduce a bug on
purpose:</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>  register :: String -&gt; ThreadId -&gt; IO ()</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  register name tid = do</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    ok &lt;- alive tid</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    reg &lt;- readRegistry</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    if ok &amp;&amp; name `notElem` map fst reg &amp;&amp; tid `notElem` map snd reg</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>      then atomicModifyIORef&#39; registry $ \reg&#39; -&gt;</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>             if name `notElem` map fst reg&#39; &amp;&amp; tid `notElem` map snd reg&#39;</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="st">-              then ((name,tid):reg&#39;,())</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a><span class="va">+              then ([(name,tid)],())</span></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>               else (reg&#39;,badarg)</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>      else badarg</span></code></pre></div>
<p>If we rerun the tests with this bug in place, we get test failures
like the following:</p>
<pre><code>     *** Failed! Assertion failed (after 30 tests and 7 shrinks):
      Commands {unCommands = [Spawn,Spawn,Register &quot;e&quot; (Var 1),Register &quot;d&quot; (Var 0),Unregister &quot;e&quot;]}
      Spawn --&gt; Spawn_ (ThreadId 154)

          State: RegState {tids = [Var 0], regs = [], killed = []}

      Spawn --&gt; Spawn_ (ThreadId 155)

          State: RegState {tids = [Var 0,Var 1], regs = [], killed = []}

      Register &quot;e&quot; (Var 1) --&gt; Register_ (Right ())

          State: RegState {tids = [Var 0,Var 1], regs = [(&quot;e&quot;,Var 1)], killed = []}

      Register &quot;d&quot; (Var 0) --&gt; Register_ (Right ())

          State: RegState {tids = [Var 0,Var 1], regs = [(&quot;d&quot;,Var 0),(&quot;e&quot;,Var 1)], killed = []}

      Unregister &quot;e&quot; --&gt; Unregister_ (Left bad argument)

          State: RegState {tids = [Var 0,Var 1], regs = [(&quot;d&quot;,Var 0)], killed = []}

      Expected: Unregister_ (Right ())
      Got: Unregister_ (Left bad argument)</code></pre>
<p>As we can see, unregister fails when it in fact should succeed. We’ve
registered <code>"e"</code> so we should be allowed to unregister it,
but the real implementation has, due to the bug, forgot that the
registration happened.</p>
<p>Let’s move on to the parallel tests, all we need to add is:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ParallelModel</span> <span class="dt">RegState</span> <span class="kw">where</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  runCommandMonad _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_parallelRegistry ::</span> <span class="dt">ParallelCommands</span> <span class="dt">RegState</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>prop_parallelRegistry cmds <span class="ot">=</span> monadicIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>  replicateM_ <span class="dv">10</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    void (run cleanUp)</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    runParallelCommands cmds</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>  assert <span class="dt">True</span></span></code></pre></div>
<p>When we run the tests we get rather long counterexamples:</p>
<pre><code>      *** Failed! (after 24 tests and 7 shrinks):
      Exception:
        bad argument
        CallStack (from HasCallStack):
          error, called at src/Example/Registry/Real.hs:69:10 in stateful-pbt-with-fakes-0.0.0-inplace:Example.Registry.Real
      ParallelCommands [Fork [Spawn,WhereIs &quot;a&quot;],Fork [Spawn],
                        Fork [Register &quot;c&quot; (Var 1),Spawn],Fork [Register &quot;e&quot; (Var 2),Register &quot;a&quot; (Var 2)]]</code></pre>
<p>If we replace our shared memory operations with version that do a bit
of sleep beforehand:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="st">- import Data.IORef</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ import SleepyIORef</span></span></code></pre></div>
<p>We get better shrinking results:</p>
<pre><code>      *** Failed! (after 5 tests and 5 shrinks):
      Exception:
        bad argument
        CallStack (from HasCallStack):
          error, called at src/Example/Registry/Real.hs:69:10 in stateful-pbt-with-fakes-0.0.0-inplace:Example.Registry.Real
      ParallelCommands [Fork [Spawn],Fork [Register &quot;b&quot; (Var 0),Register &quot;c&quot; (Var 0)]]</code></pre>
<p>Here we see clearly that there’s some problem in
<code>Register</code>, as that’s the only thing that happens in
parallel. If we look at the implementation of <code>register</code> it’s
obvious where the race condition is, for example we are using
<code>atomicModifyIORef</code> to update the registry. The problem is
that we call <code>readRegistry</code> to check if a name has already
been registered and then call <code>atomicModifyIORef</code>, so the
race can be if another thread sneaks in between those two calls.</p>
<p>We can fix this problem by adding a global lock around
<code>register</code>:</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE lock #-}</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="ot">lock ::</span> <span class="dt">MVar</span> ()</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>lock <span class="ot">=</span> unsafePerformIO (newMVar ())</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="ot">registerNoRace ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>registerNoRace name tid <span class="ot">=</span> withMVar lock <span class="op">$</span> \_ <span class="ot">-&gt;</span> register name tid</span></code></pre></div>
<p>When rerunning the tests with this fixed version of
<code>registry</code>, we get:</p>
<pre><code>      *** Failed! Assertion failed (after 30 tests and 13 shrinks):
      ParallelCommands [Fork [Spawn],Fork [Spawn],Fork [Spawn],
                        Fork [Register &quot;d&quot; (Var 2)],Fork [Unregister &quot;d&quot;,Unregister &quot;d&quot;]]</code></pre>
<p>Which seems to suggest that we have a similar problem with
<code>unregister</code>, which is indeed the case. After applying the
same fix to <code>unregister</code>, we get:</p>
<pre><code>      *** Failed! Assertion failed (after 15 tests and 4 shrinks):
      ParallelCommands [Fork [Spawn],Fork [Register &quot;d&quot; (Var 0)],
                        Fork [Kill (Var 0),Register &quot;e&quot; (Var 0)]]</code></pre>
<p>Killing a thread will unregister it, so we get a similar problem
again. If we take the lock before calling <code>kill</code>, then the
parallel tests finally pass.</p>
<p>These race conditions are essentially variants on the parallel
counter bug, but I hope you agree that they’re not as obvious in the
process registry case. I also hope that by now it’s clear that as a user
we get these parallel tests basically without doing any extra work. All
the heavy lifting is done by the library by reusing the sequential
model, and this code can be written once and then reused for all our
parallel testing examples!</p>
</section>
</section>
</section>
<section id="integration-testing-with-contract-tested-fakes"
class="level3">
<h3><a href="#integration-testing-with-contract-tested-fakes"
title="Integration testing with contract tested fakes">Integration
testing with contract tested fakes</a></h3>
<p>Throughout this post we’ve used in-memory models, or fakes, as
reference implementations to test against. The use of fakes diverges
from the original work on Quviq’s Erlang QuickCheck, where a more
traditional state machine specification is used with
post-conditions.</p>
<p>As far as I know, Edsko de Vries’ <a
href="https://www.well-typed.com/blog/2019/01/qsm-in-depth/">post</a>
(2019) was the first to propose the use of fakes instead of state
machine specifications with post-conditions. Edsko also showed how one
can implement fake-based specifications on top of a library that uses
state machine specifications<a href="#fn7" class="footnote-ref"
id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<p>Using fakes instead of state machine specifications with
post-conditions is easier for programmers unfamiliar with formal
specifications, because most programmers are already familiar with mocks
and fakes are <a
href="https://martinfowler.com/bliki/TestDouble.html">similar</a> to
mocks.</p>
<p>There are other advantages to using fakes, for example we can use
this fake in integration tests with components that depend on the
software that we tested with the fake.</p>
<p>Imagine a situation where we have two components with the first
depending on the second:</p>
<pre><code>   +--------+              +---------+
   |        |  depends on  |         |
   | Real A +-------------&gt;|  Real B |
   |        |              |         |
   +--------+              +---------+</code></pre>
<p>If we want to integration test component <span
class="math inline"><em>A</em></span> and <span
class="math inline"><em>B</em></span> then we first need to start or
enable component <span class="math inline"><em>B</em></span> and then
start testing component <span class="math inline"><em>A</em></span>. In
a larger system there can be many dependencies and integration tests can
get slow and flaky due to the infrastructure for starting up the
dependencies.</p>
<p>With fakes we can get fast and deterministic integration tests by
depending on the fake of the dependency instead of the real
dependency:</p>
<pre><code>   +--------+              +---------+
   |        |  depends on  |         |
   | Real A +-------------&gt;|  Fake B |
   |        |              |         |
   +--------+              +---------+</code></pre>
<p>One of the problems with integration testing against fakes is that
the fake can be wrong. The standard solution to solve that problem is to
<a href="https://martinfowler.com/bliki/ContractTest.html">contract
test</a> the fake to make sure that it is faithful to the software it’s
supposed to be a fake of. We don’t have this problem, because our
stateful and parallel property-based tests assure that the fake is
faithful:</p>
<pre><code>   +--------+                  +---------+
   |        |  tested against  |         |
   | Real B +-----------------&gt;|  Fake B |
   |        | (contract test)  |         |
   +--------+                  +---------+</code></pre>
<p>In this, final, section we’ll look at examples of how integration
testing against fakes works. Hopefully this shows how the testing
methodology that we’ve explored in this post can be scaled to a bigger
system of components.</p>
<section id="example-queue-again" class="level4">
<h4><a href="#example-queue-again"
title="Example: queue (again)">Example: queue (again)</a></h4>
<p>As our first example of integration testing, let’s recall our queue
example from the section on stateful testing. We can introduce an
interface for it as follows:</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IQueue</span> q <span class="ot">=</span> <span class="dt">IQueue</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> iNew  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> q</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iPut  ::</span> q <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iGet  ::</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iSize ::</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The real implementation can instantiate this interface in a
straightforward way:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="ot">real ::</span> <span class="dt">IQueue</span> <span class="dt">Queue</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>real <span class="ot">=</span> <span class="dt">IQueue</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>  { iNew  <span class="ot">=</span> new</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>  , iPut  <span class="ot">=</span> put</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>  , iGet  <span class="ot">=</span> get</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>  , iSize <span class="ot">=</span> size</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The interesting part is that our fake can also instantiate the same
interface by storing the state in a mutable reference
(<code>IORef</code>) as follows.</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fake ::</span> <span class="dt">IO</span> (<span class="dt">IQueue</span> (<span class="dt">Var</span> <span class="dt">Queue</span>))</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>fake <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>  ref <span class="ot">&lt;-</span> newIORef emptyState</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">IQueue</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    { iNew  <span class="ot">=</span> \n   <span class="ot">-&gt;</span> updateIORef ref (fNew n)</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    , iPut  <span class="ot">=</span> \q i <span class="ot">-&gt;</span> updateIORef ref (fPut q i)</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>    , iGet  <span class="ot">=</span> \q   <span class="ot">-&gt;</span> updateIORef ref (fGet q)</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>    , iSize <span class="ot">=</span> \q   <span class="ot">-&gt;</span> updateIORef ref (fSize q)</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    updateIORef ::</span> <span class="dt">IORef</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    updateIORef ref op <span class="ot">=</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef&#39; ref (\fs <span class="ot">-&gt;</span> assoc fs (op fs)) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwIO err</span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> x  <span class="ot">-&gt;</span> <span class="fu">return</span> x</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        assoc fs  (<span class="dt">Left</span> err)       <span class="ot">=</span> (fs,  <span class="dt">Left</span> err)</span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>        assoc _fs (<span class="dt">Right</span> (fs&#39;, x)) <span class="ot">=</span> (fs&#39;, <span class="dt">Right</span> x)</span></code></pre></div>
<p>We can now write components or services <em>against</em> this
interface:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prog ::</span> <span class="dt">IQueue</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>prog iq <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>  q <span class="ot">&lt;-</span> iNew iq <span class="dv">3</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span class="dv">0</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span class="dv">1</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>  iPut iq q <span class="dv">2</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> iGet iq q</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>  assert (x <span class="op">==</span> <span class="dv">0</span>) (<span class="fu">return</span> ())</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>  sz <span class="ot">&lt;-</span> iSize iq q</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>  assert (sz <span class="op">==</span> <span class="dv">2</span>) (<span class="fu">return</span> ())</span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> prog <span class="op">=&lt;&lt;</span> fake</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> <span class="dt">IO</span> ()</span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a>deploy <span class="ot">=</span> prog real</span></code></pre></div>
<p>When we integration test our new component we can use the
<code>fake</code> instance to make the tests fast and deterministic,
while when we deploy we use the <code>real</code> instance and because
of our stateful property-based tests we know that the fake is faithful
to the real implementation.</p>
</section>
<section id="example-file-system" class="level4">
<h4><a href="#example-file-system" title="Example: file system">Example:
file system</a></h4>
<p>The next example is a file system, first used by Edsko in the <a
href="https://www.well-typed.com/blog/2019/01/qsm-in-depth/">post</a>
that also introduced using fakes as models.</p>
<p>The interface is parametrised by a file handle. We can create
directories, open files to get a hold of a file handle, file handles can
then be read from and written to, and finally closed:</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IFileSystem</span> h <span class="ot">=</span> <span class="dt">IFileSystem</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> iMkDir ::</span> <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iOpen  ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> h</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iWrite ::</span> h <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iClose ::</span> h <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> iRead  ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The real implementation of this interface uses the real file system.
In order to isolate the tests all operations will be relative to some
<code>root</code> directory:</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="ot">root ::</span> <span class="dt">FilePath</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>root <span class="ot">=</span> <span class="st">&quot;/tmp/qc-test&quot;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rMkDir ::</span> <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>rMkDir d <span class="ot">=</span> createDirectory (dirFP root d)</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="ot">rOpen ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Handle</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>rOpen f <span class="ot">=</span> openFile (fileFP root f) <span class="dt">AppendMode</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a><span class="ot">rWrite ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>rWrite h s <span class="ot">=</span> hPutStr h s</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a><span class="ot">rClose ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>rClose h <span class="ot">=</span> hClose h</span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a><span class="ot">rRead ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>rRead f <span class="ot">=</span> <span class="fu">readFile</span> (fileFP root f)</span></code></pre></div>
<div class="sourceCode" id="cb95"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="ot">real ::</span> <span class="dt">IFileSystem</span> <span class="dt">Handle</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>real <span class="ot">=</span> <span class="dt">IFileSystem</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>  { iMkDir <span class="ot">=</span> rMkDir</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>  , iOpen  <span class="ot">=</span> rOpen</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>  , iWrite <span class="ot">=</span> rWrite</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>  , iClose <span class="ot">=</span> rClose</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>  , iRead  <span class="ot">=</span> rRead</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The fake implementation of the interface is, as usual, implemented
using an in-memory data structure:</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FHandle</span> <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Handle</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FakeFS</span> <span class="ot">=</span> <span class="dt">F</span> {</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    dirs  ::</span> <span class="dt">Set</span> <span class="dt">Dir</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> files ::</span> <span class="dt">Map</span> <span class="dt">File</span> <span class="dt">String</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> open  ::</span> <span class="dt">Map</span> <span class="dt">FHandle</span> <span class="dt">File</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> next  ::</span> <span class="dt">FHandle</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyFakeFS ::</span> <span class="dt">FakeFS</span></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a>emptyFakeFS <span class="ot">=</span> <span class="dt">F</span> (Set.singleton (<span class="dt">Dir</span> [])) Map.empty Map.empty (<span class="dt">Var</span> <span class="dv">0</span>)</span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FakeOp</span> a <span class="ot">=</span> <span class="dt">FakeFS</span> <span class="ot">-&gt;</span> (<span class="dt">Either</span> <span class="dt">PrecondFail</span> a, <span class="dt">FakeFS</span>)</span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true" tabindex="-1"></a><span class="ot">fMkDir ::</span> <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> ()</span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true" tabindex="-1"></a>fMkDir d m<span class="op">@</span>(<span class="dt">F</span> ds fs hs n)</span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> d        <span class="ot">`Set.member`</span>    ds <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">AlreadyExists</span>, m)</span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> parent d <span class="ot">`Set.notMember`</span> ds <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">DoesNotExist</span>, m)</span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>                   <span class="ot">=</span> (<span class="dt">Right</span> (), <span class="dt">F</span> (Set.insert d ds) fs hs n)</span>
<span id="cb96-21"><a href="#cb96-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-22"><a href="#cb96-22" aria-hidden="true" tabindex="-1"></a><span class="ot">fOpen ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> <span class="dt">FHandle</span></span>
<span id="cb96-23"><a href="#cb96-23" aria-hidden="true" tabindex="-1"></a>fOpen f m<span class="op">@</span>(<span class="dt">F</span> ds fs hs n<span class="op">@</span>(<span class="dt">Var</span> n_))</span>
<span id="cb96-24"><a href="#cb96-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> alreadyOpen   <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">Busy</span>, m)</span>
<span id="cb96-25"><a href="#cb96-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">not</span> dirExists <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">DoesNotExist</span>, m)</span>
<span id="cb96-26"><a href="#cb96-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> fileExists    <span class="ot">=</span> (<span class="dt">Right</span> n, <span class="dt">F</span> ds fs hs&#39; n&#39;)</span>
<span id="cb96-27"><a href="#cb96-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>     <span class="ot">=</span> (<span class="dt">Right</span> n, <span class="dt">F</span> ds (Map.insert f <span class="st">&quot;&quot;</span> fs) hs&#39; n&#39;)</span>
<span id="cb96-28"><a href="#cb96-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb96-29"><a href="#cb96-29" aria-hidden="true" tabindex="-1"></a>    hs&#39; <span class="ot">=</span> Map.insert n f hs</span>
<span id="cb96-30"><a href="#cb96-30" aria-hidden="true" tabindex="-1"></a>    n&#39;  <span class="ot">=</span> <span class="dt">Var</span> (<span class="fu">succ</span> n_)</span>
<span id="cb96-31"><a href="#cb96-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-32"><a href="#cb96-32" aria-hidden="true" tabindex="-1"></a>    fileExists  <span class="ot">=</span>         f <span class="ot">`Map.member`</span> fs</span>
<span id="cb96-33"><a href="#cb96-33" aria-hidden="true" tabindex="-1"></a>    dirExists   <span class="ot">=</span> fileDir f <span class="ot">`Set.member`</span> ds</span>
<span id="cb96-34"><a href="#cb96-34" aria-hidden="true" tabindex="-1"></a>    alreadyOpen <span class="ot">=</span> f <span class="ot">`List.elem`</span> Map.elems hs</span>
<span id="cb96-35"><a href="#cb96-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-36"><a href="#cb96-36" aria-hidden="true" tabindex="-1"></a><span class="ot">fWrite ::</span> <span class="dt">FHandle</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> ()</span>
<span id="cb96-37"><a href="#cb96-37" aria-hidden="true" tabindex="-1"></a>fWrite h s m<span class="op">@</span>(<span class="dt">F</span> ds fs hs n)</span>
<span id="cb96-38"><a href="#cb96-38" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> f <span class="ot">&lt;-</span> Map.lookup h hs <span class="ot">=</span> (<span class="dt">Right</span> (), <span class="dt">F</span> ds (Map.adjust (<span class="op">++</span> s) f fs) hs n)</span>
<span id="cb96-39"><a href="#cb96-39" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>                 <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">HandleClosed</span>, m)</span>
<span id="cb96-40"><a href="#cb96-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-41"><a href="#cb96-41" aria-hidden="true" tabindex="-1"></a><span class="ot">fClose ::</span> <span class="dt">FHandle</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> ()</span>
<span id="cb96-42"><a href="#cb96-42" aria-hidden="true" tabindex="-1"></a>fClose h (<span class="dt">F</span> ds fs hs n) <span class="ot">=</span> (<span class="dt">Right</span> (), <span class="dt">F</span> ds fs (Map.delete h hs) n)</span>
<span id="cb96-43"><a href="#cb96-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-44"><a href="#cb96-44" aria-hidden="true" tabindex="-1"></a><span class="ot">fRead ::</span> <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> <span class="dt">String</span></span>
<span id="cb96-45"><a href="#cb96-45" aria-hidden="true" tabindex="-1"></a>fRead f m<span class="op">@</span>(<span class="dt">F</span> _ fs hs _)</span>
<span id="cb96-46"><a href="#cb96-46" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> alreadyOpen               <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">Busy</span>         , m)</span>
<span id="cb96-47"><a href="#cb96-47" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> s <span class="ot">&lt;-</span> Map.lookup f fs <span class="ot">=</span> (<span class="dt">Right</span> s           , m)</span>
<span id="cb96-48"><a href="#cb96-48" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>                 <span class="ot">=</span> (<span class="dt">Left</span> <span class="dt">DoesNotExist</span> , m)</span>
<span id="cb96-49"><a href="#cb96-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb96-50"><a href="#cb96-50" aria-hidden="true" tabindex="-1"></a>    alreadyOpen <span class="ot">=</span> f <span class="ot">`List.elem`</span> Map.elems hs</span></code></pre></div>
<div class="sourceCode" id="cb97"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fake ::</span> <span class="dt">IO</span> (<span class="dt">IFileSystem</span> <span class="dt">FHandle</span>)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>fake <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>  ref <span class="ot">&lt;-</span> newIORef emptyFakeFS</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">IFileSystem</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    { iMkDir <span class="ot">=</span> \d   <span class="ot">-&gt;</span> updateIORef ref (fMkDir d)</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>    , iOpen  <span class="ot">=</span> \f   <span class="ot">-&gt;</span> updateIORef ref (fOpen f)</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>    , iWrite <span class="ot">=</span> \h s <span class="ot">-&gt;</span> updateIORef ref (fWrite h s)</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    , iClose <span class="ot">=</span> \h   <span class="ot">-&gt;</span> updateIORef ref (fClose h)</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>    , iRead  <span class="ot">=</span> \f   <span class="ot">-&gt;</span> updateIORef ref (fRead f)</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    updateIORef ::</span> <span class="dt">IORef</span> <span class="dt">FakeFS</span> <span class="ot">-&gt;</span> <span class="dt">FakeOp</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>    updateIORef ref op <span class="ot">=</span></span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>      atomicModifyIORef&#39; ref (\fs <span class="ot">-&gt;</span> swap (op fs)) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> err <span class="ot">-&gt;</span> throwIO err</span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> x  <span class="ot">-&gt;</span> <span class="fu">return</span> x</span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>        swap (x, y) <span class="ot">=</span> (y, x)</span></code></pre></div>
<p>Assuming we’ve tested that the fake file system is faithful to the
real one, we can depend on the interface in all components of our system
that need the file system:</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prog ::</span> <span class="dt">IFileSystem</span> h <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>prog ifs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> d <span class="ot">=</span> <span class="dt">Dir</span> [<span class="st">&quot;foo&quot;</span>]</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>  iMkDir ifs d</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> f <span class="ot">=</span> <span class="dt">File</span> d <span class="st">&quot;bar&quot;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> iOpen ifs f</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>  iWrite ifs h <span class="st">&quot;baz&quot;</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>  iClose ifs h</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">=&lt;&lt;</span> iRead ifs f</span></code></pre></div>
<p>We can then use the fake file system when we integration test and
thus get fast and deterministic tests, and then use the real file system
when we deploy.</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> prog <span class="op">=&lt;&lt;</span> fake</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> <span class="dt">IO</span> ()</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>deploy <span class="ot">=</span> prog real</span></code></pre></div>
<p>Because of the fact that we know that the fake is faithful to the
real file system implementation, we can be relatively sure that swapping
in the real file system instead of the fake one when deploying will not
introduce bugs. If it does introduce a bug then we have a mismatch
between the fake and the real implementation and we need to investigate
how it slipped through our stateful property-based <a
href="https://github.com/stevana/stateful-pbt-with-fakes/blob/main/src/Example/FileSystem/Test.hs">tests</a>.</p>
<p>Note that <code>prog</code> is just a silly example, in a real system
the component that uses the file system can be more complex, for example
in the system that Edsko worked on the component that depended on the
file system is a database. In such cases it makes sense to write a whole
new stateful and parallel property-based test suite using database
commands and responses, it’s those tests that do the integration testing
between the database and the fake file system, while the stateful and
parallel property-based tests of the file system alone do the contract
tests that ensure that the file system fake is faithful to the real file
system. The picture looks like this, where “DB” is the database and “FS”
is the file system:</p>
<pre><code>   +---------+              +----------+
   |         |  depends on  |          |
   | Real DB +-------------&gt;|  Fake FS |
   |         |              |          |
   +----+----+              +----------+
        |
        | tested against
        v
   +---------+
   |         |
   | Fake DB |
   |         |
   +---------+</code></pre>
</section>
<section id="example-bigger-system-of-components" class="level4">
<h4><a href="#example-bigger-system-of-components"
title="Example: bigger system of components">Example: bigger system of
components</a></h4>
<p>The examples given above, a queue and a file system, might not seems
necessary to fake<a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a> so to finish of let’s sketch how the
same technique scales to a bigger system of components or services.</p>
<p>Imagine we have three components or services, where component
<em>A</em> depends on component <em>B</em> which depends on component
<em>C</em>:</p>
<pre><code>  +---+      +---+      +---+
  |   |      |   |      |   |
  | A +-----&gt;| B +-----&gt;| C |
  |   |      |   |      |   |
  +---+      +---+      +---+</code></pre>
<p>Following the pattern that we did for the queue and file system
example, we’d define three interfaces:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IA</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IB</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IC</span> <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>And the dependencies are made clear when we instantiate the
interfaces:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="ot">iC ::</span> <span class="dt">IO</span> <span class="dt">IC</span>       <span class="co">-- C has no dependencies.</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="ot">iB ::</span> <span class="dt">IC</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">IB</span> <span class="co">-- B depends on C.</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="ot">iA ::</span> <span class="dt">IB</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">IA</span> <span class="co">-- A depends on B.</span></span></code></pre></div>
<p>The testing strategy is then as follows:</p>
<ol type="1">
<li>Stateful and parallel test C, this gives us a fake of C which is
contract tested;</li>
<li>Use C fake when integration testing B;</li>
<li>Use B fake (which uses the C fake) when testing A.</li>
</ol>
<p>Hopefully it should be clear that this strategy scales to more
components or services<a href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>.</p>
</section>
</section>
</section>
<section id="conclusion-and-future-work" class="level2">
<h2><a href="#conclusion-and-future-work"
title="Conclusion and future work">Conclusion and future work</a></h2>
<p>We’ve seen how stateful and parallel property-based testing can be
implemented in about 400 lines of code, which is comparable to the 300
lines of code of the first version of QuickCheck (which didn’t have
shrinking). We’ve also had a look at several examples of how we can use
fakes as models and how to test bigger systems in a compositional manner
by reusing the fakes.</p>
<p>I hope that this is enough material to get people curious and
experimenting in their favorite programming languages<a href="#fn10"
class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>.
Feel free to get <a href="https://stevana.github.io/about.html">in
touch</a> or open an <a
href="https://github.com/stevana/stateful-pbt-with-fakes">issue</a> in
case there’s anything I can help with. Who knows, together, we might
even be able to slightly improve the state of property-based testing
libraries!</p>
</section>
<section id="acknowledgments" class="level2">
<h2><a href="#acknowledgments"
title="Acknowledgments">Acknowledgments</a></h2>
<p>I’d like to thank Daniel Gustafsson for helping implement the
<code>quickcheck-state-machine</code> library with me seven years ago,
discussing a fix for parallel commands generation <a
href="https://github.com/stevana/quickcheck-state-machine/issues/51">issue</a>
that I found while writing this post, and for proofreading.</p>
<p>I also want to thank Larry Diehl for proofreading and making several
suggestions on how to improve the text and make it more readable.</p>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Is there a source for this story? I can’t remember where
I’ve heard it. This short <a
href="http://www.erlang-factory.com/conference/London2011/speakers/JohnHughes">biography</a>
gives some of the details:</p>
<blockquote>
<p>“From 2002-2005 he led a major research project in software
verification, funded by the Swedish Strategic Research Foundation. This
led to the development of Quviq QuickCheck in Erlang.”</p>
</blockquote>
<p>I believe <a
href="https://strategiska.se/forskning/genomford-forskning/ramanslag-inom-it-omradet/projekt/2010/">this</a>
must be the project mentioned above.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>There’s some room for error here from the users side,
e.g. the user could create non-unique references. In a proper library
one might want to introduce a <code>genSym</code> construct which
guarantees uniqueness.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>So stateful property-based testing with a trivial
<code>runReal</code> can be seen as crude version of a random path
exploring “model checker”. One could perhaps implement something closer
to TLC (the model checker for TLA+), which enumerates all paths up to
some depth, by using <code>smallcheck</code> rather than
<code>QuickCheck</code>. If this topic interests you, you might also
want to have a look at Gabriella Gonzalez’s <a
href="https://github.com/Gabriella439/HasCal">HasCal</a>.</p>
<p>I don’t have an example for this, but I guess one can also think of
stateful property-based testing with a trivial <code>runFake</code> as a
crude version of a fuzzer (without coverage guidance). For more on this
and how to add coverage guidance, see <a
href="https://dl.acm.org/doi/10.1145/3360607"><em>Coverage guided,
property based testing</em></a> (2019).<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Another idea might be to drop all preconditions in the
parallel case and make all commands be able to fail gracefully instead
of crashing, e.g. <code>Write_ (Either DoesntExist ())</code>.</p>
<p>The problem with this approach is that some examples, such as the <a
href="https://github.com/stevana/stateful-pbt-with-fakes/blob/main/src/Example/TicketDispenser.hs">ticket
dispenser</a>, have initialisation commands such as <code>New</code>
which create a ticket dispenser reference upon which the later commands
depend on, so without preconditions forbidding more than one
<code>New</code> we can end up generating: <code>Fork [New, New]</code>,
which doesn’t make sense. It should also be noted that making
<code>New</code> fail gracefully when a <code>New</code> has already
been executed would need a global boolean flag, which is ugly.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The parallel counter example is similar to the <a
href="https://github.com/stevana/stateful-pbt-with-fakes/blob/main/src/Example/TicketDispenser.hs">ticket
dispenser</a> example that appears in John’s paper <a
href="https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"><em>Testing
the hard stuff and staying sane</em></a> (2014).<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>The sequential variant of the process registry example
first appeared in the paper <a
href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=5ae25681ff881430797268c5787d7d9ee6cf542c"><em>QuickCheck
testing for fun and profit</em></a> (2007) and is also part of John’s
Midlands Graduate School course (2019). The parallel tests were
introduced in <a
href="https://www.cse.chalmers.se/~nicsma/papers/finding-race-conditions.pdf"><em>Finding
Race Conditions in Erlang with QuickCheck and PULSE</em></a> (2009).<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>I believe the post-condition formulation is more
general, as it allows a relational rather than a functional
specification. So I don’t think we can show the converse of what Edsko
did, i.e. implement a post-condition style specification on top of our
fake-based one.<a href="#fnref7" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Unless we want to test what happens when failures, such
as the disk being full etc. <a
href="http://www.eecg.toronto.edu/~yuan/papers/failure_analysis_osdi14.pdf">Research</a>
shows that “almost all (92%) of the catastrophic system failures are the
result of incorrect handling of non-fatal errors explicitly signaled in
software. […] in 58% of the catastrophic failures, the underlying faults
could easily have been detected through simple testing of error handling
code.”. Fakes make it easier to inject faults, but that’s a story for
another day.<a href="#fnref8" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>See the talk <a
href="https://www.youtube.com/watch?v=fhFa4tkFUFw">Integrated Tests Are
A Scam</a> by J.B. Rainsberger for a longer presentation of this idea.<a
href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>In the unlikely case that there’s someone out there who
wants to dig even deeper into this topic, then I’ve compiled a list of
<a
href="https://github.com/stevana/stateful-pbt-with-fakes/blob/main/TODO.md">ideas</a>
for improvements and further exploration.<a href="#fnref10"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></description>
      <category>Testing</category>
    </item>

    <item>
      <title>Towards zero-downtime upgrades of stateful systems</title>
      <link>https://stevana.github.io/towards_zero-downtime_upgrades_of_stateful_systems.html</link>
      <guid>https://stevana.github.io/towards_zero-downtime_upgrades_of_stateful_systems.html</guid>
      <pubDate>Thu, 7 Mar 2024 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>Towards zero-downtime upgrades of stateful systems</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#terminology" id="toc-terminology">Terminology</a>
<ul>
<li><a href="#software-systems" id="toc-software-systems">Software
systems</a></li>
<li><a href="#programs-and-their-upgrades"
id="toc-programs-and-their-upgrades">Programs and their
upgrades</a></li>
</ul></li>
<li><a href="#implementation" id="toc-implementation">Implementation</a>
<ul>
<li><a href="#state-machines" id="toc-state-machines">State
machines</a></li>
<li><a href="#example" id="toc-example">Example</a></li>
<li><a href="#semantics" id="toc-semantics">Semantics</a></li>
<li><a href="#pipelines" id="toc-pipelines">Pipelines</a></li>
<li><a href="#deployment" id="toc-deployment">Deployment</a></li>
<li><a href="#upgrades" id="toc-upgrades">Upgrades</a></li>
<li><a href="#sources-and-sinks" id="toc-sources-and-sinks">Sources and
sinks</a></li>
<li><a href="#remote-upgrades" id="toc-remote-upgrades">Remote
upgrades</a></li>
</ul></li>
<li><a href="#discussion-and-future-work"
id="toc-discussion-and-future-work">Discussion and future work</a></li>
</ul>
</nav>
<div class="date">Posted on Mar  7, 2024</div>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>Most deployed programs need to be upgraded at some point. The reasons
vary from adding new features to patching a bug and potentially fixing a
broken state. Even though upgrades are an essential part of software
development and maintenance, programming languages tend to not help the
programmer deal with them in any way.</p>
<p>The situation reminds me of a remark made by Barbara Liskov about
deployment of software (which is related to upgrades) in her Turing
award <a href="https://youtu.be/qAKrMdUycb8?t=3058">lecture</a>
(2009):</p>
<blockquote>
<p>“There’s a funny disconnect in how we write distributed programs. You
write your individual modules, but then when you want to connect them
together you’re out of the programming language and into this other
world. Maybe we need languages that are a little bit more complete now,
so that we can write the whole thing in the language.”</p>
</blockquote>
<p>There’s one exception, that I know of, where upgrades are talked
about from within the language: Erlang/OTP. In OTP there’s a library
construct called <a
href="https://www.erlang.org/doc/design_principles/release_structure"><em>release</em></a>,
which can be used to perform up- and downgrades. Furthermore, these up-
and downgrades can hot swap the running code resulting in zero-downtime
and no interruption of the service of connected clients.</p>
<p>If you haven’t seen Erlang’s hot swapping feature before, then you
might want to have a look at the classic <a
href="https://www.youtube.com/watch?v=xrIjfIjssLE">Erlang the movie</a>,
which contains a telecommunications example of this. If you prefer
reading over watching, then I’ve written an earlier <a
href="https://stevana.github.io/hot-code_swapping_a_la_erlang_with_arrow-based_state_machines.html">post</a>
which starts off by explaining a REPL session which performs an upgrade
(my example isn’t nearly as cool as in the movie though).</p>
<p>What is it that Erlang’s releases and hot swapping facilities do? Can
we steal those ideas and build upon them? These are the main questions
that motivated me in writing this post.</p>
<p>Let’s take a step back, ignoring Erlang for a moment, and ask
ourselves: what would good support for upgrades look like?</p>
<ul>
<li>Zero-downtime: seamless, don’t interrupt existing client connections
or sessions;</li>
<li>If there’s any state then migrate it in a type-safe way;</li>
<li>Backwards and forwards compatibility: old clients should be able to
talk to newer servers, and newer clients should be able to talk to old
servers;</li>
<li>Atomicity: upgrades either succeed, or fail and rollback any
changes;</li>
<li>Downgrades: even if an upgrade succeeds we might want to rollback to
an earlier version.</li>
</ul>
<p>In the rest of this post I’d like to explore how we can achieve some
of this.</p>
</section>
<section id="terminology" class="level2">
<h2><a href="#terminology" title="Terminology">Terminology</a></h2>
<p>Having defined some desirable characteristics of upgrades, let’s move
on to defining what we mean by upgrades.</p>
<p>There are two notions I’d like clarify: what kind of software systems
the upgrades are targeting, and then how we represent programs and their
upgrades.</p>
<section id="software-systems" class="level3">
<h3><a href="#software-systems" title="Software systems">Software
systems</a></h3>
<p>There’s different kinds of software systems one might want to
upgrade.</p>
<ol type="1">
<li><p>Client-only, e.g. a compiler, editor, or some command line
utility which runs locally on your computer and doesn’t interact with
any server. Downtime is typically not a problem, and the state of the
program is typically saved to disk. The operating system’s package
manager typically takes care of the upgrades, with minimal user
involvement. However there are situations where one might like to
perform an upgrade without first terminating the old version of a
client-only application, e.g. the fix-and-continue debugging <a
href="https://lispcookbook.github.io/cl-cookbook/debugging.html#resume-a-program-execution-from-anywhere-in-the-stack">workflow</a>
from Lisp and Smalltalk, <a
href="https://en.wikipedia.org/wiki/TidalCycles">live coding music</a>,
or when working with large data sets, e.g. in <a
href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1386713/">bioinformatics</a>;</p></li>
<li><p>Client-server applications where the target of the upgrade is a
<em>stateless</em> component of the server, e.g. a front-end or a REST
API. The stateless components typically retrieve the state they need to
service a request from a stateful component, e.g. a database, but they
don’t maintain any state of their own, which makes stateless components
easier to upgrade. A common strategy is to stick a load balancer
in-front of the stateless component(s), spin up the new version of the
component while keeping the old version around, and then (slowly)
migrate traffic over to the new version. Notice that this wouldn’t
necessarily work if there was state in the components, as then the state
of the old and new versions of the components might diverge and
potentially have unexpected results;</p></li>
<li><p>Client-server applications where the target of the upgrade is a
<em>stateful</em> component of the server, e.g. a database or a service
with a stateful protocol like FTP. Databases were designed for
supporting upgrades, with features like schema migrations and
replication. The high-level idea would be to spin up the new version,
take a snapshot of the old database, start logically replicating all new
requests from the old to the new database while also restoring the
snapshot to the new database, once the new database has caught up, we
can switch over and tear down the old database. Depending on the volume
of the database and the rate of new traffic this can still be a
difficult operation.</p>
<p>A service like FTP, where once the user is connected they can “move
around” by e.g. changing the working directory and list the contents of
the current working directory, are typically not possible to upgrade
without downtime. The problem is that the response of one command
depends on the history of previous commands in that user sessions, and
this state is transient. If you think FTP is a silly protocol (it’s),
then consider the similarly stateful POSIX filesystem API, with its file
handles that can be opened, read, written, and closed;</p></li>
<li><p>Distributed stateful systems, e.g. a distributed key-value
database. This is similar to the above, but the replication of data is
performed all the time rather than only at the moment an upgrade is
performed. The disadvantage is that we need more hardware and bandwidth,
but on the other hand it makes upgrades much easier. Distributed systems
can typically tolerate and repair some amount of faulty replicas, which
allows for rolling upgrades where we replace one of the server
components at the time;</p></li>
<li><p>There’s also <a
href="https://www.inkandswitch.com/local-first/">local-first</a>
systems, which are different to all the above. I’ve not had a chance to
think about upgrades in that context, so I won’t talk about them any
further.</p></li>
</ol>
<p>In this post I’d like to focus on upgrading stateful systems, like
non-distributed databases and stateful services like FTP or
filesystems.</p>
<p>Stateful systems arguably have the worst upgrade path of the ones
listed above, making them more interesting to work on. That said I hope
that the techniques can be used to simplify upgrades in the other kinds
of systems too, and potentially enabling other possibilities like better
debugging experience and live coding.</p>
</section>
<section id="programs-and-their-upgrades" class="level3">
<h3><a href="#programs-and-their-upgrades"
title="Programs and their upgrades">Programs and their upgrades</a></h3>
<p>Having defined what kind of systems we’d like to upgrade, let’s turn
our attention to how we can represent programs and their upgrades.</p>
<p>We could choose to use the syntax of a specific programming language
to represent programs, but programming languages tend to be too big and
complicated. Or, we could be general and represent programs as
λ-calculus terms or equivalently Turing machines, but that would be too
clumsy and too low-level.</p>
<p>A happy middle ground, which is easy to implement in any programming
language while at the same time expressive enough to express any
algorithm at a desired level of abstraction, is the humble state
machine<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>. There are different ways to define
state machines, we’ll go for a definition which is a simple function
from some input and a state to a pair of some output and a new
state:</p>
<pre><code>  input -&gt; state -&gt; (state, output)</code></pre>
<p>where inputs, states and outputs are algebraic datatypes
(records/structs and tagged unions).</p>
<p>To make things concrete, let’s consider an example where we represent
a counter as a state machine. One way to define such a state machine is
to use the enum <code>{ReadCount, IncrCount}</code> as input, set the
state to be an integer and the output to be a tagged union where in the
read case we return an integer and in the increment case we return an
acknowledgment (unit or void type). Given these types, the state machine
function of the counter can be defined as follows (in Python):</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> counter(<span class="bu">input</span>: Input, state: <span class="bu">int</span>) <span class="op">-&gt;</span> (<span class="bu">int</span>, <span class="bu">int</span> <span class="op">|</span> <span class="va">None</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">match</span> <span class="bu">input</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> Input.ReadCount: <span class="cf">return</span> (state, state)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> Input.IncrCount: <span class="cf">return</span> (state <span class="op">+</span> <span class="dv">1</span>, <span class="va">None</span>)</span></code></pre></div>
<p>Assuming our programs are such state machines, what would it mean to
upgrade them? I think this is where having a simple representation of
programs where all of the state is explicit starts to shine. By merely
looking at the function type of a state machine, we can see that it
would make sense to be able to:</p>
<ol type="1">
<li>Extend the input type with more cases, e.g. a
<code>ResetCount</code> which sets the new state to <code>0</code>;</li>
<li>Refine an existing output with more data, e.g. we could return the
old count when we increment;</li>
<li>Extending the state, e.g. we could add a boolean to the state which
determines if we should increment by +1 or -1 (i.e. decrementing);</li>
<li>Refine an existing input, e.g. make <code>IncrCount</code> have an
integer value associated with it which determines by how much we want to
increment.</li>
</ol>
<p>I don’t know if the above list complete, but it’s a start.</p>
<p>If we go back to the list of criteria for good upgrade support, we
can see how some of the items there are more tangible now.</p>
<p>For example, typed state migrations means that if we change the state
type from <code>state</code> to <code>state'</code> then when we migrate
to old to the new state using a function of type
<code>state -&gt; state'</code>.</p>
<p>Similarly, what it means to support backwards compatibility is more
clear now. Imagine we upgrade from a server state machine:</p>
<pre><code>  input -&gt; state -&gt; (output, state)</code></pre>
<p>to a new version that has the following type:</p>
<pre><code>  input&#39; -&gt; state&#39; -&gt; (output&#39;, state&#39;)</code></pre>
<p>What would it take to still be able to serve old clients which make
requests using the old <code>input</code> type? If we had a function
from <code>input -&gt; input'</code> we could upgrade the request, feed
it to the new state machine and get an <code>output'</code> back, we
then see that we’d also need a way to downgrade the output, i.e. a
function <code>output' -&gt; output</code><a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<p>Forward compatibility, i.e. an upgraded client sends an
<code>input'</code> to a server which haven’t been upgraded yet
(i.e. expects <code>input</code>), is a bit more tricky, but again at
least we can now start to be able to talk about these things in a more
concrete way.</p>
<p>One last thing with regard to how to represent programs. Our state
machines run entirely sequentially, which is a problem if we want to
implement servers that can handle more than one client at the time. A
simple way adding parallelism is make it possible to construct pipelines
of state machines, where the state machines run in parallel. Picture the
state machines as processing stages on a conveyor belt.</p>
<p><img
src="https://raw.githubusercontent.com/stevana/hot-swapping-state-machines2/main/data/bottling_factory.png" /></p>
<p>The conveyor belt in our case, i.e. our pipeline, will be queues
which connect the state machines.</p>
<p>A typical TCP-based service can then be composed of a pipeline
that:</p>
<ol type="1">
<li>Accepts new connections/sockets from a client;</li>
<li>Waits for some of the accepted sockets to be readable (this requires
some <code>select/poll/io_uring</code>-like constructs);</li>
<li><code>recv</code> the bytes of a request;</li>
<li>Deserialise the request bytes into an input;</li>
<li>Process the input using the a state machine to produce an output
(potentially reading and writing to disk);</li>
<li>Serialise the output into a response in bytes;</li>
<li>Wait for the socket to be writable;</li>
<li><code>send</code> the response bytes back to the client and close
the socket.</li>
</ol>
<p>Each of these stages could be a state machine which runs in parallel
with all the other stages. Structuring services in this pipeline fashion
was <a
href="https://www.youtube.com/watch?v=U3eo49nVxcA&amp;t=1949s">advocated</a>
by the late Jim Gray and more recently Martin Thompson et al have <a
href="https://www.youtube.com/watch?v=qDhTjE0XmkE">been</a> giving <a
href="https://www.youtube.com/watch?v=_KvFapRkR9I">talks</a> using a
similar approach. If a stage is slow, we can shard (or partition, using
Jim’s terminology) it by dedicating another CPU/core to that stage and
have even numbered requests to one CPU/core while odd numbered requests
go to the other. That way we effectively double the throughput, without
breaking determinism.</p>
<p>Let me just leave you with one final image. I like to think of state
machines on top of pipelines as a limited form of actors or Erlang
processes (<code>gen_server</code>s more precisely) that cannot send
messages to which other process they like (graph-like structure), but
rather only downstream (DAG-like structure)<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
</section>
</section>
<section id="implementation" class="level2">
<h2><a href="#implementation"
title="Implementation">Implementation</a></h2>
<p>I hope that I’ve managed to convey what I’d like to do, why and where
my inspiration is coming from.</p>
<p>Next I’d like to make things more concrete with some code. But first
I’d like to apologies for my choice of using Haskell. I know it’s a
language that not that many people are comfortable with, but its
advanced type system (GADTs in particular) helps me express things more
cleanly. If anything isn’t clear, feel free to ask, I’m happy to try to
explain things in simpler terms. Also if anyone knows how to express
this without GADTs, while retaining type safety, then please let me
know. The code doesn’t add anything new to our previous discussion,
merely validates that at least some of it can be implemented, so even if
you can’t follow everything you won’t be missing out on anything
important.</p>
<p>A few notes on the implementation:</p>
<ul>
<li>To keep things simple we’ll only implement linear pipelines. Each
stage of the pipeline runs in parallel with all other stages, thus
giving us pipelining parallelism à la assembly lines;</li>
<li>The transformation at each stage is done via a state machine. The
syntax of state machines needs to be easily serialisable, so that we can
send upgrades over the wire;</li>
<li>The remote end will need to deserialise and typecheck the receiving
code in order to assure that it’s compatible with the already deployed
code.</li>
</ul>
<p>In the rest of this section we’ll try to fleshing out details of the
above.</p>
<section id="state-machines" class="level3">
<h3><a href="#state-machines" title="State machines">State
machines</a></h3>
<p>Typed state machines are represented using a datatype parametrised by
the state, <code>s</code>, and indexed by its input type,
<code>a</code>, and output type <code>b</code><a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.
For example the <code>Id</code>entity state machine has the same input
and output type, while if we want to <code>Compose</code> to state
machines then output type of the first needs to be the same as the input
type of the second, and so on.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> s a b <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Identity and composition.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Id</span><span class="ot">      ::</span> <span class="dt">T</span> s a a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Compose</span><span class="ot"> ::</span> <span class="dt">T</span> s b c <span class="ot">-&gt;</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">T</span> s a c</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Introducing and incrementing integers.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Int</span><span class="ot">     ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">T</span> s () <span class="dt">Int</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Incr</span><span class="ot">    ::</span> <span class="dt">T</span> s <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Mapping over sum types.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Case</span><span class="ot">    ::</span> <span class="dt">T</span> s a c <span class="ot">-&gt;</span> <span class="dt">T</span> s b d <span class="ot">-&gt;</span> <span class="dt">T</span> s (<span class="dt">Either</span> a b) (<span class="dt">Either</span> c d)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Read and update the state.</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Get</span><span class="ot">     ::</span> <span class="dt">T</span> s () s</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Put</span><span class="ot">     ::</span> <span class="dt">T</span> s s ()</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Converting values from and to strings.</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Read</span><span class="ot">    ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">T</span> s <span class="dt">String</span> a</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Show</span><span class="ot">    ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">T</span> s a <span class="dt">String</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- Forward composition.</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;&gt;) ::</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">T</span> s b c <span class="ot">-&gt;</span> <span class="dt">T</span> s a c</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;&gt;</span> g <span class="ot">=</span> g <span class="ot">`Compose`</span> f</span></code></pre></div>
</section>
<section id="example" class="level3">
<h3><a href="#example" title="Example">Example</a></h3>
<p>To keep things concrete let’s reimplement the counter example from
above.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">InputV1</span>  <span class="ot">=</span> <span class="dt">Either</span> () ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">OutputV1</span> <span class="ot">=</span> <span class="dt">Either</span> <span class="dt">Int</span> ()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV1</span><span class="ot"> ::</span> <span class="dt">InputV1</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV1</span> <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">IncrCountV1</span><span class="ot"> ::</span> <span class="dt">InputV1</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">IncrCountV1</span> <span class="ot">=</span> <span class="dt">Right</span> ()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="ot">counterV1 ::</span> <span class="dt">T</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>counterV1 <span class="ot">=</span> <span class="dt">Read</span> <span class="op">&gt;&gt;&gt;</span> counterV1&#39; <span class="op">&gt;&gt;&gt;</span> <span class="dt">Show</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    counterV1&#39; ::</span> <span class="dt">T</span> <span class="dt">Int</span> <span class="dt">InputV1</span> <span class="dt">OutputV1</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    counterV1&#39; <span class="ot">=</span> <span class="dt">Get</span> <span class="ot">`Case`</span> (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Incr</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>)</span></code></pre></div>
<p>Notice how the two operations’ inputs and outputs are represented
with an <code>Either</code> over which the <code>Case</code>
operates.</p>
</section>
<section id="semantics" class="level3">
<h3><a href="#semantics" title="Semantics">Semantics</a></h3>
<p>We can interpret our typed state machines in terms of the
<code>State</code> monad as follows.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runT ::</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (b, s)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>runT f x s <span class="ot">=</span> runState (eval f x) s</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> s b</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Id</span>            <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Compose</span> g f) <span class="ot">=</span> eval g <span class="op">&lt;=&lt;</span> eval f</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Int</span> i)       <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> <span class="fu">const</span> i</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Incr</span>          <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Case</span> f g)    <span class="ot">=</span> <span class="fu">either</span> (<span class="fu">fmap</span> <span class="dt">Left</span> <span class="op">.</span> eval f) (<span class="fu">fmap</span> <span class="dt">Right</span> <span class="op">.</span> eval g)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Get</span>           <span class="ot">=</span> <span class="fu">const</span> get</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Put</span>           <span class="ot">=</span> put</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Read</span>          <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> <span class="fu">read</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Show</span>          <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> <span class="fu">show</span></span></code></pre></div>
<p>Using the above interpreter we can run our example from before.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runT counterV1 (<span class="fu">show</span> <span class="dt">ReadCountV1</span>) <span class="dv">0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;Left 0&quot;</span>,<span class="dv">0</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runT counterV1 (<span class="fu">show</span> <span class="dt">IncrCountV1</span>) <span class="dv">0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;Right ()&quot;</span>,<span class="dv">1</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runT counterV1 (<span class="fu">show</span> <span class="dt">ReadCountV1</span>) <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;Left 1&quot;</span>,<span class="dv">1</span>)</span></code></pre></div>
<p>These runs only step the counter by one input at the time, things get
more interesting when state machines get streams of inputs via
pipelines.</p>
</section>
<section id="pipelines" class="level3">
<h3><a href="#pipelines" title="Pipelines">Pipelines</a></h3>
<p>Pipelines are represented by a type similar to that for typed state
machines, it’s also indexed by the input and output types.</p>
<p>We can picture a pipeline as a conveyor belt with state machines
operating on the items passing through.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">P</span> a b <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IdP</span><span class="ot">    ::</span> <span class="dt">P</span> a a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&gt;&gt;&gt;) ::</span> <span class="dt">Typeable</span> b <span class="ot">=&gt;</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">P</span> b c <span class="ot">-&gt;</span> <span class="dt">P</span> a c</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SM</span><span class="ot">     ::</span> <span class="dt">Typeable</span> s <span class="ot">=&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">P</span> a b</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span></code></pre></div>
<p>Notice how the state type of the state machines is existentially
quantified, meaning each state machine can have its own state.</p>
</section>
<section id="deployment" class="level3">
<h3><a href="#deployment" title="Deployment">Deployment</a></h3>
<p>Pipelines can be deployed. Each state machine will be spawned on its
own thread, meaning that all state machines run in parallel, and they
will be connected via queues.</p>
<p>Given a pipeline <code>P a b</code> and an input
<code>Queue (Msg a)</code> we get an output
<code>Queue (Msg b)</code>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=&gt;</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> (<span class="dt">Msg</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Queue</span> (<span class="dt">Msg</span> b))</span></code></pre></div>
<p>where <code>Msg</code> is defined as follows.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Msg</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Item</span> (<span class="dt">Maybe</span> <span class="dt">Socket</span>) a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Upgrade</span> (<span class="dt">Maybe</span> <span class="dt">Socket</span>) <span class="dt">Name</span> <span class="dt">UpgradeData_</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Think of <code>Msg a</code> as small wrapper around <code>a</code>
which might contain a client socket (so that we know where to send the
reply), or an upgrade. Upgrades are targeting a specific state machine
in our pipeline, that’s what the <code>Name</code> parameter is for, and
they also carry an untyped <code>UpgradeData_</code> payload which will
come back to shortly.</p>
<p>Given the above we can define deployment of pipelines as follows
(I’ll explain each case below the code).</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>deploy <span class="dt">IdP</span>             q <span class="ot">=</span> <span class="fu">return</span> q</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>deploy (f <span class="op">:&gt;&gt;&gt;</span> g)      q <span class="ot">=</span> deploy g <span class="op">=&lt;&lt;</span> deploy f q</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>deploy (<span class="dt">SM</span> name s0 f0) q <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  q&#39; <span class="ot">&lt;-</span> newQueue</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> go ::</span> <span class="dt">Typeable</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      go s f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        m <span class="ot">&lt;-</span> readQueue q</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> m <span class="kw">of</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Item</span> msock i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (o, s&#39;) <span class="ot">=</span> runT f i s</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            writeQueue q&#39; (<span class="dt">Item</span> msock o)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            go s&#39; f</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Upgrade</span> msock name&#39; ud</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> name <span class="op">/=</span> name&#39; <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                writeQueue q&#39; (<span class="dt">Upgrade</span> msock name&#39; ud)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                go s f</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> typeCheckUpgrade f ud <span class="kw">of</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">Just</span> (<span class="dt">UpgradeData</span> (<span class="ot">f&#39; ::</span> <span class="dt">T</span> t&#39; a b) (<span class="ot">g ::</span> <span class="dt">T</span> () s t&#39;)) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> (t&#39;, ()) <span class="ot">=</span> runT g s ()</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">case</span> cast t&#39; <span class="kw">of</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Just</span> s&#39; <span class="ot">-&gt;</span> go s&#39; f&#39;</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> go s f</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> go s f</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>          <span class="op">...</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>  _pid <span class="ot">&lt;-</span> forkIO (go s0 f0)</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> q&#39;</span></code></pre></div>
<p>The identity pipeline simply returns the input queue. We deploy
compositions of pipelines by deploying the components and connecting the
queues. Deploying state machines is the interesting part.</p>
<p>When we deploy state machines, we first create a new queue which will
hold the outputs, we then fork a new thread which reads from the input
queue and writes to this new output queue, and finally we return the
output queue. When reading from the input queue there’re two cases:</p>
<ol type="1">
<li>We can either get a regular <code>Item</code> in which case we step
our state machine using the <code>runT</code> function to obtain an
output and a new state, we write the output to the output queue and
continue processing with the new state;</li>
<li>Or, if the <code>Msg</code> is an <code>Upgrade</code> we first
check if the upgrade is targeting this state machine by checking if the
names match, if not we simply pass it further downstream. If the names
to match then we try to typecheck the untyped <code>UpgradeData_</code>.
If the typechecking succeeds, we’ll get a new state machine and a state
migration function, which allows us to migrate the current state and
continue processing with the new state machine.</li>
</ol>
<p>Next let’s have a look at how upgrades are represented and
typechecked.</p>
</section>
<section id="upgrades" class="level3">
<h3><a href="#upgrades" title="Upgrades">Upgrades</a></h3>
<p>Upgrades are sent over the wire in a serialised format and
deserialised at the other end, so they need to be plain first-order
data.</p>
<p>This means we can’t merely send over our typed state machine type
<code>t :: T s a b</code>, or rather the receiver will have to
reconstruct the type information. If this sounds strange, the perhaps
easiest way to convince yourself is to imagine you receive
<code>show t</code> and now you want to reconstruct <code>t</code>. When
you call <code>read (show t)</code> you need to annotate it with what
type to read into, and that’s the problem: at this point you don’t have
the type annotation <code>T s a b</code>.</p>
<p>So the plan around this is to introduce a plain first-order datatype
for upgrades, which can easily be serialised and deserialised, and then
use <em>typechecking</em> to reconstruct the type information.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UpgradeData_</span> <span class="ot">=</span> <span class="dt">UpgradeData_</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> oldState        ::</span> <span class="dt">Ty_</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> newState        ::</span> <span class="dt">Ty_</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> newInput        ::</span> <span class="dt">Ty_</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> newOutput       ::</span> <span class="dt">Ty_</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> newStateMachine ::</span> <span class="dt">U</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> stateMigration  ::</span> <span class="dt">U</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>)</span></code></pre></div>
<p>We can to typecheck the above untyped upgrade into the following
typed version.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UpgradeData</span> s a b <span class="ot">=</span> <span class="kw">forall</span> s&#39;<span class="op">.</span> <span class="dt">Typeable</span> s&#39; <span class="ot">=&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UpgradeData</span> (<span class="dt">T</span> s&#39; a b) (<span class="dt">T</span> () s s&#39;)</span></code></pre></div>
<p>The way typechecking for upgrades work is basically the user needs to
provide the untyped types of the state, input and output types of the
new state machine as well as the state migration function, from the
untyped types we can infer the typed types which we then typecheck the
new state machine and migration function against.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeCheckUpgrade ::</span> <span class="kw">forall</span> s a b<span class="op">.</span> (<span class="dt">Typeable</span> s, <span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=&gt;</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">UpgradeData_</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">UpgradeData</span> s a b)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>typeCheckUpgrade _f (<span class="dt">UpgradeData_</span> t_ t&#39;_ a&#39;_ b&#39;_ f_ g_) <span class="ot">=</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> (inferTy t_, inferTy t&#39;_, inferTy a&#39;_, inferTy b&#39;_) <span class="kw">of</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">ETy</span> (<span class="ot">t ::</span> <span class="dt">Ty</span> t), <span class="dt">ETy</span> (<span class="ot">t&#39; ::</span> <span class="dt">Ty</span> t&#39;), <span class="dt">ETy</span> (<span class="ot">a&#39; ::</span> <span class="dt">Ty</span> a&#39;), <span class="dt">ETy</span> (<span class="ot">b&#39; ::</span> <span class="dt">Ty</span> b&#39;)) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Refl</span> <span class="ot">&lt;-</span> decT <span class="op">@</span>a <span class="op">@</span>a&#39;</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Refl</span> <span class="ot">&lt;-</span> decT <span class="op">@</span>b <span class="op">@</span>b&#39;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Refl</span> <span class="ot">&lt;-</span> decT <span class="op">@</span>s <span class="op">@</span>t</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>      f <span class="ot">&lt;-</span> typeCheck f_ t&#39; a&#39; b&#39;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>      g <span class="ot">&lt;-</span> typeCheck g_ <span class="dt">TUnit</span> t t&#39;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (<span class="dt">UpgradeData</span> f g)</span></code></pre></div>
<p>Where untyped types are defined as follows:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty_</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">UTUnit</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTInt</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTBool</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTString</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTPair</span> <span class="dt">Ty_</span> <span class="dt">Ty_</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTEither</span> <span class="dt">Ty_</span> <span class="dt">Ty_</span></span></code></pre></div>
<p>and typed types as follows:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty</span> a <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TUnit</span><span class="ot">   ::</span> <span class="dt">Ty</span> ()</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TInt</span><span class="ot">    ::</span> <span class="dt">Ty</span> <span class="dt">Int</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TBool</span><span class="ot">   ::</span> <span class="dt">Ty</span> <span class="dt">Bool</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TString</span><span class="ot"> ::</span> <span class="dt">Ty</span> <span class="dt">String</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TPair</span><span class="ot">   ::</span> <span class="dt">Ty</span> a <span class="ot">-&gt;</span> <span class="dt">Ty</span> b <span class="ot">-&gt;</span> <span class="dt">Ty</span> (a, b)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TEither</span><span class="ot"> ::</span> <span class="dt">Ty</span> a <span class="ot">-&gt;</span> <span class="dt">Ty</span> b <span class="ot">-&gt;</span> <span class="dt">Ty</span> (<span class="dt">Either</span> a b)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>and the way we infer typed types from the untyped ones is done as
follows:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ETy</span> <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ETy</span><span class="ot"> ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Ty</span> a <span class="ot">-&gt;</span> <span class="dt">ETy</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">inferTy ::</span> <span class="dt">Ty_</span> <span class="ot">-&gt;</span> <span class="dt">ETy</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>inferTy <span class="dt">UTUnit</span> <span class="ot">=</span> <span class="dt">ETy</span> <span class="dt">TUnit</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>inferTy <span class="dt">UTInt</span>  <span class="ot">=</span> <span class="dt">ETy</span> <span class="dt">TInt</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>inferTy <span class="dt">UTBool</span> <span class="ot">=</span> <span class="dt">ETy</span> <span class="dt">TBool</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>inferTy <span class="dt">UTString</span> <span class="ot">=</span> <span class="dt">ETy</span> <span class="dt">TString</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>inferTy (<span class="dt">UTPair</span> ua ub) <span class="ot">=</span> <span class="kw">case</span> (inferTy ua, inferTy ub) <span class="kw">of</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ETy</span> a, <span class="dt">ETy</span> b) <span class="ot">-&gt;</span> <span class="dt">ETy</span> (<span class="dt">TPair</span> a b)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>inferTy (<span class="dt">UTEither</span> ua ub) <span class="ot">=</span> <span class="kw">case</span> (inferTy ua, inferTy ub) <span class="kw">of</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ETy</span> a, <span class="dt">ETy</span> b) <span class="ot">-&gt;</span> <span class="dt">ETy</span> (<span class="dt">TEither</span> a b)</span></code></pre></div>
<p>Now the only piece missing is untyped state machines and how to
typecheck those into typed ones.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeCheck ::</span> <span class="dt">U</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> s <span class="ot">-&gt;</span> <span class="dt">Ty</span> a <span class="ot">-&gt;</span> <span class="dt">Ty</span> b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">T</span> s a b)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">U</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">IdU</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ComposeU</span> <span class="dt">U</span> <span class="dt">U</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">IntU</span> <span class="dt">Int</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">CaseU</span> <span class="dt">U</span> <span class="dt">U</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">IncrU</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">GetU</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PutU</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ReadU</span> <span class="dt">Ty_</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ShowU</span> <span class="dt">Ty_</span></span></code></pre></div>
<p>I’ll spare you from the <a
href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/src/TypeCheck/StateMachine.hs">details</a>,
but the main ingredient is to use the <code>Data.Typeable</code>
instances to check if the types match up, similarly to how it was done
above in <code>typeCheckUpgrade</code>.</p>
</section>
<section id="sources-and-sinks" class="level3">
<h3><a href="#sources-and-sinks" title="Sources and sinks">Sources and
sinks</a></h3>
<p>Almost there. When we deploy a pipeline <code>P a b</code> we need to
provide a <code>Queue (Msg a)</code> and get a
<code>Queue (Msg b)</code>, what are we supposed to do with those
queues? We could manually feed them with items, but for convenience it’s
nice to have some basic reusable adapters that we can connect these
“garden hoses” to.</p>
<p>We call something that provides an input queue a <code>Source</code>
and something that consumes an output queue a <code>Sink</code>. Useful
sources and sinks include stdin/stdout, files, and TCP streams.</p>
<p>We can then implement a run function with the following type:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">run ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Source</span> a <span class="ot">-&gt;</span> <span class="dt">Codec</span> (<span class="dt">Msg</span> a) (<span class="dt">Msg</span> b) <span class="ot">-&gt;</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">Sink</span> b r <span class="ot">-&gt;</span> <span class="dt">IO</span> r</span></code></pre></div>
<p>Where <code>Codec a b</code> contains a deserialiser from
<code>ByteString</code> to <code>Maybe a</code> and a serialiser from
<code>b</code> to <code>ByteString</code>. We need this because our
sources and sinks produce and consume <code>ByteString</code>s.</p>
</section>
<section id="remote-upgrades" class="level3">
<h3><a href="#remote-upgrades" title="Remote upgrades">Remote
upgrades</a></h3>
<p>Putting it all together we can now create a TCP server for our
counter:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>run (<span class="dt">FromTCP</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span>) readShowCodec (<span class="dt">SM</span> <span class="st">&quot;counter&quot;</span> <span class="dv">0</span> counterV1) <span class="dt">ToTCP</span></span></code></pre></div>
<p>If we run the above in a REPL, then from another terminal we can
interact with the server as follows.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the current state of the counter.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="st">&#39;Item &quot;Left ()&quot;&#39;</span> <span class="kw">|</span> <span class="ex">nc</span> 127.0.0.1 3000</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Item</span> <span class="st">&quot;Left 0&quot;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Increment the counter.</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="st">&#39;Item &quot;Right ()&quot;&#39;</span> <span class="kw">|</span> <span class="ex">nc</span> 127.0.0.1 3000</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Item</span> <span class="st">&quot;Right ()&quot;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the counter again.</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="st">&#39;Item &quot;Left ()&quot;&#39;</span> <span class="kw">|</span> <span class="ex">nc</span> 127.0.0.1 3000</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="ex">Item</span> <span class="st">&quot;Left 1&quot;</span></span></code></pre></div>
<p>In order to make life a bit easier for ourselves, we can implement a
simple TCP client in Haskell and use from another REPL to achieve the
same result.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV1</span>))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV1</span>))</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV1</span>))</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV1</span>))</span></code></pre></div>
<pre><code>Item &quot;Left 0&quot;               -- The initial value of the counter is 0.
Item &quot;Right ()&quot;             -- Two increments.
Item &quot;Right ()&quot;
Item &quot;Left 2&quot;               -- The value is now 2</code></pre>
<p>At this point, let’s imagine we want to add a reset feature to our
counter. Reset takes no argument and returns nothing, so we use the unit
type in both the input and output types.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">InputV2</span>  <span class="ot">=</span> <span class="dt">Either</span> () <span class="dt">InputV1</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">OutputV2</span> <span class="ot">=</span> <span class="dt">Either</span> () <span class="dt">OutputV1</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ResetCountV2</span><span class="ot"> ::</span> <span class="dt">InputV2</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ResetCountV2</span> <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV2</span><span class="ot"> ::</span> <span class="dt">InputV2</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV2</span>  <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">ReadCountV1</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">IncrCountV2</span><span class="ot"> ::</span> <span class="dt">InputV2</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">IncrCountV2</span>  <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">IncrCountV1</span></span></code></pre></div>
<p>The state machine looks the same, except for the first
<code>Case</code> where we update the state to be <code>0</code>, thus
resetting the counter.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">counterV2 ::</span> <span class="dt">T</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>counterV2 <span class="ot">=</span> <span class="dt">Read</span> <span class="op">&gt;&gt;&gt;</span> counterV2&#39; <span class="op">&gt;&gt;&gt;</span> <span class="dt">Show</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    counterV2&#39; ::</span> <span class="dt">T</span> <span class="dt">Int</span> <span class="dt">InputV2</span> <span class="dt">OutputV2</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    counterV2&#39; <span class="ot">=</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Int</span> <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>) <span class="ot">`Case`</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Get</span> <span class="ot">`Case`</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Incr</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>)</span></code></pre></div>
<p>Back in our REPL we can now do the upgrade, by sending over a type
<code>erase</code>d version of <code>counterV2</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span><span class="ot"> msg ::</span> <span class="dt">Msg</span> ()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    msg <span class="ot">=</span> <span class="dt">Upgrade</span> <span class="dt">Nothing</span> <span class="st">&quot;counter&quot;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">UpgradeData_</span> <span class="dt">UTInt</span> <span class="dt">UTInt</span> <span class="dt">UTString</span> <span class="dt">UTString</span> (erase counterV2) (erase <span class="dt">Id</span>))</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> msg</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV2</span>))</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ResetCountV2</span>))</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV2</span>))</span></code></pre></div>
<p>Which yields the following annotated output.</p>
<pre><code>UpgradeSucceeded &quot;counter&quot;
Item &quot;Right (Left 2)&quot;   -- The counter&#39;s state is preserved by the upgrade.
Item &quot;Left ()&quot;          -- Reset the counter.
Item &quot;Right (Left 0)&quot;   -- The value is back to 0.</code></pre>
<p>As a final example of an upgrade, let’s do a more interesting state
migration. Let’s say we want to add a boolean to the state which
determines if <code>IncrCount</code> should add by <code>1</code> or
<code>-1</code> (i.e. decrement). This boolean can be toggled by the
user using a new operation, while the signatures of the other operations
stay the same as before.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">InputV3</span>  <span class="ot">=</span> <span class="dt">Either</span> () <span class="dt">InputV2</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">OutputV3</span> <span class="ot">=</span> <span class="dt">Either</span> () <span class="dt">OutputV2</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ToggleCountV3</span><span class="ot"> ::</span> <span class="dt">InputV3</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ToggleCountV3</span> <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV3</span>, <span class="dt">IncrCountV3</span>, <span class="dt">ToggleCountV3</span><span class="ot"> ::</span> <span class="dt">InputV3</span></span></code></pre></div>
<p>In order to implement the toggle operation we need to extend the
syntax of our state machines to be able to deal with booleans and
products (the details can be found <a
href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/src/Interpreter.hs">here</a>).</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">counterV3 ::</span> <span class="dt">T</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>) <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>counterV3 <span class="ot">=</span> <span class="dt">Read</span> <span class="op">&gt;&gt;&gt;</span> counterV3&#39; <span class="op">&gt;&gt;&gt;</span> <span class="dt">Show</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    counterV3&#39; ::</span> <span class="dt">T</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>) <span class="dt">InputV3</span> <span class="dt">OutputV3</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    counterV3&#39; <span class="ot">=</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Toggle negates the boolean in the state (the second component).</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Second</span> <span class="dt">Not</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>) <span class="ot">`Case`</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Reset resets the counter and the boolean back to false (i.e. incrementing).</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Int</span> <span class="dv">0</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Bool</span> <span class="dt">False</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>) <span class="ot">`Case`</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Reading the counter picks out the first component from the state.</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Fst</span>) <span class="ot">`Case`</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Incrementing or decrementing, depending on the boolean in the state.</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">If</span> <span class="dt">Decr</span> <span class="dt">Incr</span> <span class="op">&gt;&gt;&gt;</span> (<span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> (<span class="dt">Consume</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Snd</span>)) <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>)</span></code></pre></div>
<p>We can then upgrade to our new version of the counter as follows.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> msg2 ::</span> <span class="dt">Msg</span> ()</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>      msg2 <span class="ot">=</span> <span class="dt">Upgrade</span> <span class="dt">Nothing</span> <span class="st">&quot;counter&quot;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>               (<span class="dt">UpgradeData_</span> <span class="dt">UTInt</span> (<span class="dt">UTPair</span> <span class="dt">UTInt</span> <span class="dt">UTBool</span>) <span class="dt">UTString</span> <span class="dt">UTString</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>                 (erase counterV3) (erase (<span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Bool</span> <span class="dt">False</span>)))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> msg2</span></code></pre></div>
<p>Notice how the state is migrated using
<code>Id :&amp;&amp;&amp; Bool False</code>, i.e. create a pair where
the first component is the old value of the state (this is the current
count) and the second component is <code>False</code> (this is whether
we are decrementing).</p>
<p>Here’s a final example of how we can use the new counter.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV3</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV3</span>))</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV3</span>))</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV3</span>))</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ToggleCountV3</span>))</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV3</span>))</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV3</span>))</span></code></pre></div>
<p>The above yields the following output.</p>
<pre><code>UpgradeSucceeded &quot;counter&quot;
Item &quot;Right (Right (Left 0))&quot;   -- The counter is 0.
Item &quot;Right (Right (Right ()))&quot; -- Two increments.
Item &quot;Right (Right (Right ()))&quot;
Item &quot;Right (Right (Left 2))&quot;   -- The counter is 2.
Item &quot;Left ()&quot;                  -- Toggle to decrementing.
Item &quot;Right (Right (Right ()))&quot; -- Decrement.
Item &quot;Right (Right (Left 1))&quot;   -- The value is 1.</code></pre>
</section>
</section>
<section id="discussion-and-future-work" class="level2">
<h2><a href="#discussion-and-future-work"
title="Discussion and future work">Discussion and future work</a></h2>
<p>If we look back at the list, from the introduction, of properties
that we wanted from our upgrades, then I hope that I’ve managed to
provide a glimpse of a possible way of achieving zero-downtime upgrades
with type-safe state migrations that are atomic.</p>
<p>Downgrades can be thought of as an upgrade to an earlier version,
although it could be interesting to experiment with requiring an inverse
function to the state migration as part of an upgrade. That way the
system itself could downgrade in case there’s more than N errors within
some time period, or something like that.</p>
<p>I didn’t talk about backwards and forwards compatibility. We could
probably use an <a
href="https://en.wikipedia.org/wiki/Interface_description_language">interface
description language</a>, such as Avro or Protobuf, but it could also be
interesting see if we could add input and output migrations as part of
upgrades (in addition to state migrations). Especially in conjunction
with being able to derive them generically and <a
href="https://www.manuelbaerenz.de/essence-of-live-coding/EssenceOfLiveCoding.pdf">automatically</a>
from the schema change.</p>
<p>There’s also a bunch of other <a
href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/TODO.md">things</a>
that I thought of while working on this, which I don’t have any good
answers for yet. If you feel that I’m missing something, or if you know
some answers or if any of these problems sound interesting to work on,
please do feel free to get in <a
href="https://stevana.github.io/about.html">touch</a>!</p>
<p>Let me close by trying to tie it back to Barbara Liskov’s remark
about the need for more complete programming languages. In a world where
software systems are expected to evolve over time, wouldn’t it be neat
if programming languages provided some notion of upgrade and could
typecheck our code <em>across versions</em>, as opposed to merely
typechecking a version of the code in isolation from the next?</p>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>State machines might seem like low-level clumsy way of
programming, but Yuri Gurevich has <a
href="https://www.microsoft.com/en-us/research/publication/103-evolving-algebras-1993-lipari-guide/">shown</a>
that abstract state machines (state machines where state can be any
first-order structure) can avoid the Turing tarpit and capture any
algorithm at any level of abstraction. This result is a generalisation
of the Church-Turing thesis from computable functions on natural numbers
to arbitrary sequential algorithms.</p>
<p>In case you’re not convinced by this theoretical argument, then here
are a couple of practical examples of state machine use from
industry.</p>
<p>In Joe Armstrong’s PhD <a
href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-4551">thesis</a>
(2003), Joe gives an example of a big Ericsson telecommunications system
built in Erlang/OTP using a handful of library constructs (behaviours).
The most commonly used of these building blocks is
<code>gen_server</code>, which is a state machine. I’ve written a
high-level summary of the ideas over <a
href="https://stevana.github.io/erlangs_not_about_lightweight_processes_and_message_passing.html">here</a>,
although I recommend reading his thesis and forming your own
conclusions.</p>
<p>Leslie Lamport is another proponent of state machines. His TLA+ is
basically a language for describing state machines. See his article <a
href="https://www.microsoft.com/en-us/research/publication/computation-state-machines/"><em>Computation
and State Machines</em></a> (2008) for an introduction. Fault tolerance
in distributed systems is often realised by means of replicated state
machines, which Leslie helped develop back in the 80s.</p>
<p>Jean-Raymond Abrial’s B-method (a successor to Z notation) is also
centered around state machines and has been used to verify the automatic
Paris Métro lines 14 and 1 and the Ariane 5 rocket.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Many years ago I had the pleasure to study interaction
structures (aka index containers aka polynomial functors). One of many
possible way to view these structures is as if they are state machines.
One can construct a category with the objects being interaction
structures and then think about what the morphisms must look like in
order to satisfy the necessary categorical laws.</p>
<p>I don’t know much about category theory myself, but I remember that
the morphisms in the resulting category have two components and they
look exactly like those that we needed to be able to support backwards
compatibility.</p>
<p>There’s also a strong <a
href="https://arxiv.org/abs/0905.4063v1">connection</a> between this
category and stepwise refinement or refinement calculus, which at least
intuitively has some connection with upgrades.</p>
<p>I suppose that there are more useful ideas to steal from there.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This restriction makes it easier to make everything
deterministic, which in turn makes it easier to (simulation) test. I
touch upon this in an earlier <a
href="https://stevana.github.io/erlangs_not_about_lightweight_processes_and_message_passing.html">post</a>
towards the end. I hope to expand upon this in a separate post at some
point in the future.</p>
<p>It also make it possible for the implementation to be more efficient.
For example, if we want to have a pipeline that takes the output of one
state machine and broadcasts it to two other state machines (on the same
computer) then in Erlang the output would be copied to the two state
machines downstream, whereas with pipelines we can do it <a
href="https://stevana.github.io/parallel_stream_processing_with_zero-copy_fan-out_and_sharding.html">without
copying</a>.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>People familiar with Haskell’s ecosystem might recognise
that this is an instance of <a
href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Category.html"><code>Category</code></a>
and partially an instance of <a
href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/src/Classes.hs#L13"><code>Cocartesian</code></a>,
plus some extras. In a “real” implementation we would want this datatype
to be an instance of <code>Cocartesian</code> instance as well as
<code>Cartesian</code>.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></description>
      <category>Development</category>
    </item>

    <item>
      <title>Parallel stream processing with zero-copy fan-out and sharding</title>
      <link>https://stevana.github.io/parallel_stream_processing_with_zero-copy_fan-out_and_sharding.html</link>
      <guid>https://stevana.github.io/parallel_stream_processing_with_zero-copy_fan-out_and_sharding.html</guid>
      <pubDate>Tue, 23 Jan 2024 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>Parallel stream processing with zero-copy fan-out and sharding</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation-and-inspiration"
id="toc-motivation-and-inspiration">Motivation and inspiration</a></li>
<li><a href="#prior-work" id="toc-prior-work">Prior work</a></li>
<li><a href="#plan" id="toc-plan">Plan</a></li>
<li><a href="#list-transformer-model"
id="toc-list-transformer-model">List transformer model</a></li>
<li><a href="#queue-pipeline-deployment"
id="toc-queue-pipeline-deployment">Queue pipeline deployment</a></li>
<li><a href="#disruptor" id="toc-disruptor">Disruptor</a></li>
<li><a href="#disruptor-pipeline-deployment"
id="toc-disruptor-pipeline-deployment">Disruptor pipeline
deployment</a></li>
<li><a href="#observability"
id="toc-observability">Observability</a></li>
<li><a href="#running" id="toc-running">Running</a></li>
<li><a href="#further-work-and-contributing"
id="toc-further-work-and-contributing">Further work and
contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
<li><a href="#discussion" id="toc-discussion">Discussion</a></li>
</ul>
</nav>
<div class="date">Posted on Jan 23, 2024</div>
<p>In a previous <a
href="https://stevana.github.io/pipelined_state_machines.html">post</a>
I explored how we can make better use of our parallel hardware by means
of pipelining.</p>
<p>In a nutshell the idea of pipelining is to break up the problem in
stages and have one (or more) thread(s) per stage and then connect the
stages with queues. For example, imagine a service where we read some
request from a socket, parse it, validate, update our state and
construct a response, serialise the response and send it back over the
socket. These are six distinct stages and we could create a pipeline
with six CPUs/cores each working on a their own stage and feeding the
output to the queue of the next stage. If one stage is slow we can shard
the input, e.g. even requests to go to one worker and odd requests go to
another thereby nearly doubling the throughput for that stage.</p>
<p>One of the concluding remarks to the previous post is that we can
gain even more performance by using a better implementation of queues,
e.g. the <a
href="https://en.wikipedia.org/wiki/Disruptor_(software)">LMAX
Disruptor</a>.</p>
<p>The Disruptor is a low-latency high-throughput queue implementation
with support for multi-cast (many consumers can in parallel process the
same event), batching (both on producer and consumer side),
back-pressure, sharding (for scalability) and dependencies between
consumers.</p>
<p>In this post we’ll recall the problem of using “normal” queues,
discuss how Disruptor helps solve this problem and have a look at how we
can we provide a declarative high-level language for expressing
pipelines backed by Disruptors where all low-level details are hidden
away from the user of the library. We’ll also have a look at how we can
monitor and visualise such pipelines for debugging and performance
troubleshooting purposes.</p>
<section id="motivation-and-inspiration" class="level2">
<h2><a href="#motivation-and-inspiration"
title="Motivation and inspiration">Motivation and inspiration</a></h2>
<p>Before we dive into <em>how</em> we can achieve this, let’s start
with the question of <em>why</em> I’d like to do it.</p>
<p>I believe the way we write programs for multiprocessor networks,
i.e. multiple connected computers each with multiple CPUs/cores, can be
improved upon. Instead of focusing on the pitfalls of the current
mainstream approaches to these problems, let’s have a look at what to me
seems like the most promising way forward.</p>
<p>Jim Gray gave a great explanation of dataflow programming in this
Turing Award Recipient <a
href="https://www.youtube.com/watch?v=U3eo49nVxcA&amp;t=1949s">interview</a>.
He uses props to make his point, which makes it a bit difficult to
summaries in text here. I highly recommend watching the video clip, the
relevant part is only three minutes long.</p>
<p>The key point is exactly that of pipelining. Each stage is running on
a CPU/core, this program is completely sequential, but by connecting
several stages we create a parallel pipeline. Further parallelism (what
Jim calls partitioned parallelism) can be gained by partitioning the
inputs, by say odd and even sequence number, and feeding one half of the
inputs to one copy of the pipeline and the other half to another copy,
thereby almost doubling the throughput. Jim calls this a “natural” way
to achieve parallelism.</p>
<p>While I’m not sure if “natural” is the best word, I do agree that
it’s a nice way to make good use of CPUs/cores on a single computer
without introducing non-determinism. Pipelining is also effectively used
to achieve parallelism in manufacturing and hardware, perhaps that’s why
Jim calls it “natural”?</p>
<p>Things get a bit more tricky if we want to involve more computers.
Part of the reason, I believe, is that we run into the problem
highlighted by Barbara Liskov at the very end of her Turing award <a
href="https://youtu.be/qAKrMdUycb8?t=3058">lecture</a> (2009):</p>
<blockquote>
<p>“There’s a funny disconnect in how we write distributed programs. You
write your individual modules, but then when you want to connect them
together you’re out of the programming language and into this other
world. Maybe we need languages that are a little bit more complete now,
so that we can write the whole thing in the language.”</p>
</blockquote>
<p>Ideally we’d like our pipelines to seamlessly span over multiple
computers. In fact it should be possible to deploy same pipeline to
different configurations of processors without changing the pipeline
code (nor having to add any networking related code).</p>
<p>A pipeline that is redeployed with additional CPUs or computers might
or might not scale, it depends on whether it makes sense to partition
the input of a stage further or if perhaps the introduction of an
additional computer merely adds more overhead. How exactly the pipeline
is best spread over the available computers and CPUs/cores will require
some combination of domain knowledge, measurement and judgment.
Depending on how quick we can make redeploying of pipelines, it might be
possible to autoscale them using a program that monitors the queue
lengths.</p>
<p>Also related to redeploying, but even more important than
autoscaling, are upgrades of pipelines. That’s both upgrading the code
running at the individual stages, as well as how the stages are
connected to each other, i.e. the pipeline itself.</p>
<p>Martin Thompson has given many <a
href="https://www.youtube.com/watch?v=_KvFapRkR9I">talks</a> which echo
the general ideas of Jim and Barbara. If you prefer reading then you can
also have a look at the <a
href="https://www.reactivemanifesto.org/">reactive manifesto</a> which
he cowrote. Martin is also one of the people behind the Disruptor, which
we will come back to soon, and he also <a
href="https://youtu.be/OqsAGFExFgQ?t=2532">said</a> the following:</p>
<blockquote>
<p>“If there’s one thing I’d say to the Erlang folks, it’s you got the
stuff right from a high-level, but you need to invest in your messaging
infrastructure so it’s super fast, super efficient and obeys all the
right properties to let this stuff work really well.”</p>
</blockquote>
<p>This quote together with Joe Armstrong’s <a
href="https://youtu.be/bo5WL5IQAd0?t=2494">anecdote</a> of an unmodified
Erlang program <em>only</em> running 33 times faster on a 64 core
machine, rather than 64 times faster as per the Ericsson higher-up’s
expectations, inspired me to think about how one can improve upon the
already excellent work that Erlang is doing in this space.</p>
<p>Longer term, I like to think of pipelines spanning computers as a
building block for what Barbara <a
href="https://www.youtube.com/watch?v=8M0wTX6EOVI">calls</a> a
“substrate for distributed systems”. Unlike Barbara I don’t think this
substrate should be based on shared memory, but overall I agree with her
goal of making it easier to program distributed systems by providing
generic building blocks.</p>
</section>
<section id="prior-work" class="level2">
<h2><a href="#prior-work" title="Prior work">Prior work</a></h2>
<p>Working with streams of data is common. The reason for this is that
it’s a nice abstraction when dealing with data that cannot fit in
memory. The alternative is to manually load chunks of data one wants to
process into memory, load the next chunk etc, when we processes streams
this is hidden away from us.</p>
<p>Parallelism is a related problem, in that when one has big volumes of
data it’s also common to care about performance and how we can utilise
multiple processors.</p>
<p>Since dealing with limited memory and multiprocessors is a problem
that as bothered programmers and computer scientists for a long time, at
least since the 1960s, there’s a lot of work that has been done in this
area. I’m at best familiar with a small fraction of this work, so please
bear with me but also do let me know if I missed any important
development.</p>
<p>In 1963 Melvin Conway proposed <a
href="https://dl.acm.org/doi/10.1145/366663.366704">coroutines</a>,
which allows the user to conveniently process very large, or even
infinite, lists of items without first loading the list into memory,
i.e. streaming.</p>
<p>Shortly after, in 1965, Peter Landin introduced <a
href="https://dl.acm.org/doi/10.1145/363744.363749">streams</a> as a
functional analogue of Melvin’s imperative coroutines.</p>
<p>A more radical departure from Von Neumann style sequential
programming can be seen in the work on <a
href="https://en.wikipedia.org/wiki/Dataflow_programming">dataflow
programming</a> in general and especially in Paul Morrison’s <a
href="https://jpaulm.github.io/fbp/index.html">flow-based
programming</a> (late 1960s). Paul uses the following picture to
illustrate the similarity between flow-based programming and an assembly
line in manufacturing:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/pipelining-with-disruptor/main/data/bottling_factory.png" /></p>
<p>Each stage is its own process running in parallel with the other
stages. In flow-based programming stages are computation and the
conveyor belts are queues. This gives us implicit parallelism and
determinate outcome.</p>
<p>Doug McIlroy, who was aware of some of the dataflow work<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>, wrote a <a
href="http://doc.cat-v.org/unix/pipes/">memo</a> in 1964 about the idea
of pipes, although it took until 1973 for them to get implemented in
Unix by Ken Thompson. Unix pipes have a strong feel of flow-based
programming, although all data is of type string. A pipeline of commands
will start a process per command, so there’s implicit parallelism as
well (assuming the operative system schedules different processes on
different CPUs/cores). Fanning out can be done with <code>tee</code> and
process substitution,
e.g. <code>echo foo | tee &gt;(cat) &gt;(cat) | cat</code>, and more
complicated non-linear flows can be achieved with
<code>mkfifo</code>.</p>
<p>With the release of GNU <a
href="https://en.wikipedia.org/wiki/GNU_parallel"><code>parallel</code></a>
in 2010 more explicit control over parallelism was introduced as well as
the ability to run jobs on remote computers.</p>
<p>Around the same time many (functional) programming languages started
getting streaming libraries. Haskell’s <a
href="https://hackage.haskell.org/package/conduit">conduit</a> library
had its first release in 2011 and Haskell’s <a
href="https://hackage.haskell.org/package/pipes">pipes</a> library came
shortly after (2012). Java version 8, which has streams, was released in
2014. Both <a
href="https://clojure.org/reference/transducers">Clojure</a> and <a
href="https://doc.akka.io/docs/akka/current/stream/index.html">Scala</a>,
which also use the JVM, got streams that same year (2014).</p>
<p>Among the more imperative programming languages, JavaScript and
Python both have generators (a simple form of coroutines) since around
2006. Go has “goroutines”, a clear nod to coroutines, since its first
version (2009). Coroutines are also part of the C++20 standard.</p>
<p>Almost all of the above mentioned streaming libraries are intended to
be run on a single computer. Often they even run in a single thread,
i.e. not exploiting parallelism at all. Sometimes concurrent/async
constructs are available which create a pool of worker threads that
process the items concurrently, but they often break determinism
(i.e. rerunning the same computation will yield different results,
because the workers do not preserve the order of the inputs).</p>
<p>If the data volumes are too big for a single computer then there’s a
different set of streaming tools, such as Apache Hadoop (2006), Apache
Spark (2009), Apache Kafka (2011), Apache Storm (2011), and Apache Flink
(2011). While the Apache tools can often be deployed locally for testing
purposes, they are intended for distributed computations and are
therefore perhaps a bit more cumbersome to deploy and use than the
streaming libraries we mentioned earlier.</p>
<p>Initially it might not seem like a big deal that streaming libraries
don’t “scale up” or distributed over multiple computers, and that
streaming tools like the Apache ones don’t gracefully “scale down” to a
single computer. Just pick the right tool for the right job, right?
Well, it turns out that <a
href="https://youtu.be/XPlXNUXmcgE?t=2783">40-80%</a> of jobs submitted
to MapReduce systems (such as Apache Hadoop) would run faster if they
were ran on a single computer instead of a distributed cluster of
computers, so picking the right tool is perhaps not as easy as it first
seems.</p>
<p>There are two exceptions, that I know of, of streaming libraries that
also work in a distributed setting. Scala’s Akka/Pekko <a
href="https://doc.akka.io/docs/akka/current/stream/stream-refs.html">streams</a>
(2014) when combined with Akka/Pekko <a
href="https://github.com/apache/incubator-pekko-management">clusters</a>
and <a href="https://aeron.io/">Aeron</a> (2014). Aeron is the spiritual
successor of the Disruptor also written by Martin Thompson et al. The
Disruptor’s main use case was as part of the LMAX exchange. From what I
understand exchanges close in the evening (or at least did back then in
the case of LMAX), which allows for updates etc. These requirements
changed for Aeron where 24/7 operation was necessary and so distributed
stream processing is necessary where upgrades can happen without
processing stopping (or even slowing down).</p>
<p>Finally, I’d also like to mention functional reactive programming, or
FRP, (1997). I like to think of it as a neat way of expressing stream
processing networks. Disruptor’s <a
href="https://github.com/LMAX-Exchange/disruptor/wiki/Disruptor-Wizard">“wizard”</a>
DSL and Akka’s <a
href="https://doc.akka.io/docs/akka/current/stream/stream-graphs.html">graph
DSL</a> try to add a high-level syntax for expressing networks, but they
both have a rather imperative rather than declarative feel. It’s however
not clear (to me) how effectively implement, parallelise<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, or
distribute FRP. Some interesting work has been done with hot code
swapping in the FRP <a
href="https://github.com/turion/essence-of-live-coding">setting</a>,
which is potentially useful for a telling a good upgrade story.</p>
<p>To summarise, while there are many streaming libraries there seem to
be few (at least that I know of) that tick all of the following
boxes:</p>
<ol type="1">
<li>Parallel processing:
<ul>
<li>in a determinate way;</li>
<li>fanning out and sharding without copying data (when run on a single
computer).</li>
</ul></li>
<li>Potentially distributed over multiple computers for fault tolerance
and upgrades, without the need to change the code of the pipeline;</li>
<li>Observable, to ease debugging and performance analysis;</li>
<li>Declarative high-level way of expressing stream processing networks
(i.e. the pipeline);</li>
<li>Good deploy, upgrade, rescale story for stateful systems;</li>
<li>Elastic, i.e. ability to rescale automatically to meet the
load.</li>
</ol>
<p>I think we need all of the above in order to build Barbara’s
“substrate for distributed systems”. We’ll not get all the way there in
this post, but at least this should give you a sense of the direction
I’d like to go.</p>
</section>
<section id="plan" class="level2">
<h2><a href="#plan" title="Plan">Plan</a></h2>
<p>The rest of this post is organised as follows.</p>
<p>First we’ll have a look at how to model pipelines as a transformation
of lists. The purpose of this is to give us an easy to understand
sequential specification of what we would like our pipelines to do.</p>
<p>We’ll then give our first parallel implementation of pipelines using
“normal” queues. The main point here is to recap of the problem with
copying data that arises from using “normal” queues, but we’ll also
sketch how one can test the parallel implementation using the model.</p>
<p>After that we’ll have a look at the Disruptor API, sketch its single
producer implementation and discuss how it helps solve the problems we
identified in the previous section.</p>
<p>Finally we’ll have enough background to be able to sketch the
Disruptor implementation of pipelines. We’ll also discuss how
monitoring/observability can be added.</p>
</section>
<section id="list-transformer-model" class="level2">
<h2><a href="#list-transformer-model"
title="List transformer model">List transformer model</a></h2>
<p>Let’s first introduce the type for our pipelines. We index our
pipeline datatype by two types, in order to be able to precisely specify
its input and output types. For example, the <code>Id</code>entity
pipeline has the same input as output type, while pipeline composition
(<code>:&gt;&gt;&gt;</code>) expects its first argument to be a pipeline
from <code>a</code> to <code>b</code>, and the second argument a
pipeline from <code>b</code> to <code>c</code> in order for the
resulting composed pipeline to be from <code>a</code> to <code>c</code>
(similar to functional composition).</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">P</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Id</span><span class="ot">      ::</span> <span class="dt">P</span> a a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&gt;&gt;&gt;)  ::</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">P</span> b c <span class="ot">-&gt;</span> <span class="dt">P</span> a c</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Map</span><span class="ot">     ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">P</span> a b</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:***)  ::</span> <span class="dt">P</span> a c <span class="ot">-&gt;</span> <span class="dt">P</span> b d <span class="ot">-&gt;</span> <span class="dt">P</span> (a, b) (c, d)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&amp;&amp;&amp;)  ::</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">P</span> a c <span class="ot">-&gt;</span> <span class="dt">P</span> a (b, c)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:+++)  ::</span> <span class="dt">P</span> a c <span class="ot">-&gt;</span> <span class="dt">P</span> b d <span class="ot">-&gt;</span> <span class="dt">P</span> (<span class="dt">Either</span> a b) (<span class="dt">Either</span> c d)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:|||)  ::</span> <span class="dt">P</span> a c <span class="ot">-&gt;</span> <span class="dt">P</span> b c <span class="ot">-&gt;</span> <span class="dt">P</span> (<span class="dt">Either</span> a b) c</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Shard</span><span class="ot">   ::</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">P</span> a b</span></code></pre></div>
<p>Here’s a pipeline that takes a stream of integers as input and
outputs a stream of pairs where the first component is the input integer
and the second component is a boolean indicating if the first component
was an even integer or not.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">examplePipeline ::</span> <span class="dt">P</span> <span class="dt">Int</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>examplePipeline <span class="ot">=</span> <span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Map</span> <span class="fu">even</span></span></code></pre></div>
<p>So far our pipelines are merely data which describes what we’d like
to do. In order to actually perform a stream transformation we’d need to
give semantics to our pipeline datatype<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<p>The simplest semantics we can give our pipelines is that in terms of
list transformations.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">model ::</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>model <span class="dt">Id</span>         xs  <span class="ot">=</span> xs</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>model (f <span class="op">:&gt;&gt;&gt;</span> g) xs  <span class="ot">=</span> model g (model f xs)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>model (<span class="dt">Map</span> f)    xs  <span class="ot">=</span> <span class="fu">map</span> f xs</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>model (f <span class="op">:***</span> g) xys <span class="ot">=</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    (xs, ys) <span class="ot">=</span> <span class="fu">unzip</span> xys</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">zip</span> (model f xs) (model g ys)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>model (f <span class="op">:&amp;&amp;&amp;</span> g) xs <span class="ot">=</span> <span class="fu">zip</span> (model f xs) (model g xs)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>model (f <span class="op">:+++</span> g) es <span class="ot">=</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    (xs, ys) <span class="ot">=</span> partitionEithers es</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Note that we pass in the input list, in order to perserve the order.</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    merge es (model f xs) (model g ys)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    merge []             []       []       <span class="ot">=</span> []</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    merge (<span class="dt">Left</span>  _ <span class="op">:</span> es) (l <span class="op">:</span> ls) rs       <span class="ot">=</span> <span class="dt">Left</span>  l <span class="op">:</span> merge es ls rs</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    merge (<span class="dt">Right</span> _ <span class="op">:</span> es) ls       (r <span class="op">:</span> rs) <span class="ot">=</span> <span class="dt">Right</span> r <span class="op">:</span> merge es ls rs</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>model (f <span class="op">:|||</span> g) es <span class="ot">=</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    (xs, ys) <span class="ot">=</span> partitionEithers es</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    merge es (model f xs) (model g ys)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    merge []             []       []       <span class="ot">=</span> []</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    merge (<span class="dt">Left</span>  _ <span class="op">:</span> es) (l <span class="op">:</span> ls) rs       <span class="ot">=</span> l <span class="op">:</span> merge es ls rs</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    merge (<span class="dt">Right</span> _ <span class="op">:</span> es) ls       (r <span class="op">:</span> rs) <span class="ot">=</span> r <span class="op">:</span> merge es ls rs</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>model (<span class="dt">Shard</span> f) xs <span class="ot">=</span> model f xs</span></code></pre></div>
<p>Note that this semantics is completely sequential and preserves the
order of the inputs (determinism). Also note that since we don’t have
parallelism yet, <code>Shard</code>ing doesn’t do anything. We’ll
introduce parallelism without breaking determinism in the next
section.</p>
<p>We can now run our example pipeline in the REPL:</p>
<pre><code>&gt; model examplePipeline [1,2,3,4,5]
[(1,False),(2,True),(3,False),(4,True),(5,False)]</code></pre>
</section>
<section id="queue-pipeline-deployment" class="level2">
<h2><a href="#queue-pipeline-deployment"
title="Queue pipeline deployment">Queue pipeline deployment</a></h2>
<p>In the previous section we saw how to deploy pipelines in a purely
sequential way in order to process lists. The purpose of this is merely
to give ourselves an intuition of what pipelines should do as well as an
executable model which we can test our intuition against.</p>
<p>Next we shall have a look at our first parallel deployment. The idea
here is to show how we can involve multiple threads in the stream
processing, without making the output non-deterministic (same input
should always give the same output).</p>
<p>We can achieve this as follows:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">TQueue</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">TQueue</span> b)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>deploy <span class="dt">Id</span>         xs <span class="ot">=</span> <span class="fu">return</span> xs</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>deploy (f <span class="op">:&gt;&gt;&gt;</span> g) xs <span class="ot">=</span> deploy g <span class="op">=&lt;&lt;</span> deploy f xs</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>deploy (<span class="dt">Map</span> f)    xs <span class="ot">=</span> deploy (<span class="dt">MapM</span> (<span class="fu">return</span> <span class="op">.</span> f)) xs</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>deploy (<span class="dt">MapM</span> f)   xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (Where `MapM :: (a -&gt; IO b) -&gt; P a b` is the monadic generalisation of</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- `Map` from the list model that we saw earlier.)</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  ys <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> forever <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> atomically (readTQueue xs)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> f x</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    atomically (writeTQueue ys y)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ys</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>deploy (f <span class="op">:&amp;&amp;&amp;</span> g) xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  xs1 <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  xs2 <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> forever <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> atomically (readTQueue xs)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    atomically <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>      writeTQueue xs1 x</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>      writeTQueue xs2 x</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>  ys <span class="ot">&lt;-</span> deploy f xs1</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>  zs <span class="ot">&lt;-</span> deploy g xs2</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>  yzs <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> forever <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> atomically (readTQueue ys)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    z <span class="ot">&lt;-</span> atomically (readTQueue zs)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    atomically (writeTQueue yzs (y, z))</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> yzs</span></code></pre></div>
<p>(I’ve omitted the cases for <code>:|||</code> and <code>:+++</code>
to not take up too much space. We’ll come back and handle
<code>Shard</code> separately later.)</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> [(<span class="dt">Int</span>, <span class="dt">Bool</span>)]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>example&#39; xs0 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  xs <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (atomically <span class="op">.</span> writeTQueue xs) xs0</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  ys <span class="ot">&lt;-</span> deploy (<span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Map</span> <span class="fu">even</span>) xs</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  replicateM (<span class="fu">length</span> xs0) (atomically (readTQueue ys))</span></code></pre></div>
<p>Running <a
href="https://github.com/stevana/pipelining-with-disruptor/blob/main/src/QueueDeployment.hs">this</a>
in our REPL, gives the same result as in the model:</p>
<pre><code>&gt; example&#39; [1,2,3,4,5]
[(1,False),(2,True),(3,False),(4,True),(5,False)]</code></pre>
<p>In fact, we can use our model to define a property-based test which
asserts that our queue deployment is faithful to the model:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_commute ::</span> <span class="dt">Eq</span> b <span class="ot">=&gt;</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">PropertyM</span> <span class="dt">IO</span> ()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>prop_commute p xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  ys <span class="ot">&lt;-</span> run <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    qxs <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mapM_</span> (atomically <span class="op">.</span> writeTQueue qxs) xs</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    qys <span class="ot">&lt;-</span> deploy p qxs</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    replicateM (<span class="fu">length</span> xs) (atomically (readTQueue qys))</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  assert (model p xs <span class="op">==</span> ys)</span></code></pre></div>
<p>Actually running this property for arbitrary pipelines would require
us to first define a pipeline generator, which is a bit tricky given the
indexes of the datatype<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>. It can still me used as a helper
for testing specific pipelines though,
e.g. <code>prop_commute examplePipeline</code>.</p>
<p>A bigger problem is that we’ve spawned two threads, when deploying
<code>:&amp;&amp;&amp;</code>, whose mere job is to copy elements from
the input queue (<code>xs</code>) to the input queues of <code>f</code>
and <code>g</code> (<code>xs{1,2}</code>), and from the outputs of
<code>f</code> and <code>g</code> (<code>ys</code> and <code>zs</code>)
to the output of <code>f &amp;&amp;&amp; g</code> (<code>ysz</code>).
Copying data is expensive.</p>
<p>When we shard a pipeline we effectively clone it and send half of the
traffic to one clone and the other half to the other. One way to achieve
this is as follows, notice how in <code>shard</code> we swap
<code>qEven</code> and <code>qOdd</code> when we recurse:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>deploy (<span class="dt">Shard</span> f) xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  xsEven <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  xsOdd  <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  _pid   <span class="ot">&lt;-</span> forkIO (shard xs xsEven xsOdd)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  ysEven <span class="ot">&lt;-</span> deploy f xsEven</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  ysOdd  <span class="ot">&lt;-</span> deploy f xsOdd</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  ys     <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  _pid   <span class="ot">&lt;-</span> forkIO (merge ysEven ysOdd ys)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ys</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    shard ::</span> <span class="dt">TQueue</span> a <span class="ot">-&gt;</span> <span class="dt">TQueue</span> a <span class="ot">-&gt;</span> <span class="dt">TQueue</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    shard  qIn qEven qOdd <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>      atomically (readTQueue qIn <span class="op">&gt;&gt;=</span> writeTQueue qEven)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>      shard qIn qOdd qEven</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    merge ::</span> <span class="dt">TQueue</span> a <span class="ot">-&gt;</span> <span class="dt">TQueue</span> a <span class="ot">-&gt;</span> <span class="dt">TQueue</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    merge qEven qOdd qOut <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>      atomically (readTQueue qEven <span class="op">&gt;&gt;=</span> writeTQueue qOut)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>      merge qOdd qEven qOut</span></code></pre></div>
<p>This alteration will shard the input queue (<code>qIn</code>) on even
and odd indices, and we can <code>merge</code> it back without losing
determinism. Note that if we’d simply had a pool of worker threads
taking items from the input queue and putting them on the output queue
(<code>qOut</code>) after processing, then we wouldn’t have a
deterministic outcome. Also notice that in the <code>deploy</code>ment
of <code>Shard</code>ing we also end up copying data between the queues,
similar to the fan-out case (<code>:&amp;&amp;&amp;</code>)!</p>
<p>Before we move on to show how to avoid doing this copying, let’s have
a look at a couple of examples to get a better feel for pipelining and
sharding. If we generalise <code>Map</code> to <code>MapM</code> in our
<a
href="https://github.com/stevana/pipelining-with-disruptor/blob/main/src/ModelIO.hs">model</a>
we can write the following contrived program:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">modelSleep ::</span> <span class="dt">P</span> () ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>modelSleep <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MapM</span> (<span class="fu">const</span> (threadDelay <span class="dv">250000</span>)) <span class="op">:&amp;&amp;&amp;</span> <span class="dt">MapM</span> (<span class="fu">const</span> (threadDelay <span class="dv">250000</span>)) <span class="op">:&gt;&gt;&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MapM</span> (<span class="fu">const</span> (threadDelay <span class="dv">250000</span>)) <span class="op">:&gt;&gt;&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MapM</span> (<span class="fu">const</span> (threadDelay <span class="dv">250000</span>))</span></code></pre></div>
<p>The argument to <code>threadDelay</code> (or sleep) is microseconds,
so at each point in the pipeline we are sleeping 1/4 of a second.</p>
<p>If we feed this pipeline <code>5</code> items:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runModelSleep ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>runModelSleep <span class="ot">=</span> void (model modelSleep (<span class="fu">replicate</span> <span class="dv">5</span> ()))</span></code></pre></div>
<p>We see that it takes roughly 5 seconds:</p>
<pre><code>&gt; :set +s
&gt; runModelSleep
(5.02 secs, 905,480 bytes)</code></pre>
<p>This is expected, even though we pipeline and fan-out, as the model
is completely sequential.</p>
<p>If we instead run the same pipeline using the queue deployment, we
get:</p>
<pre><code>&gt; runQueueSleep
(1.76 secs, 907,160 bytes)</code></pre>
<p>The reason for this is that the two sleeps in the fan-out happen in
parallel now and when the first item is at the second stage the first
stage starts processing the second item, and so on, i.e. we get a
pipelining parallelism.</p>
<p>If we, for some reason, wanted to achieve a sequential running time
using the queue deployment, we’d have to write a one stage pipeline like
so:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">queueSleepSeq ::</span> <span class="dt">P</span> () ()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>queueSleepSeq <span class="ot">=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MapM</span> <span class="op">$</span> \() <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    ()       <span class="ot">&lt;-</span> threadDelay <span class="dv">250000</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    ((), ()) <span class="ot">&lt;-</span> (,) <span class="op">&lt;$&gt;</span> threadDelay <span class="dv">250000</span> <span class="op">&lt;*&gt;</span> threadDelay <span class="dv">250000</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    ()       <span class="ot">&lt;-</span> threadDelay <span class="dv">250000</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> ()</span></code></pre></div>
<pre><code>&gt; runQueueSleepSeq
(5.02 secs, 898,096 bytes)</code></pre>
<p>Using sharding we can get an even shorter running time:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">queueSleepSharded ::</span> <span class="dt">P</span> () ()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>queueSleepSharded <span class="ot">=</span> <span class="dt">Shard</span> queueSleep</span></code></pre></div>
<pre><code>&gt; runQueueSleepSharded
(1.26 secs, 920,888 bytes)</code></pre>
<p>This is pretty much where we left off in my previous post. If the
speed ups we are seeing from pipelining don’t make sense, it might help
to go back and reread the <a
href="https://stevana.github.io/pipelined_state_machines.html">old
post</a>, as I spent some more time constructing an intuitive example
there.</p>
</section>
<section id="disruptor" class="level2">
<h2><a href="#disruptor" title="Disruptor">Disruptor</a></h2>
<p>Before we can understand how the Disruptor can help us avoid the
problem copying between queues that we just saw, we need to first
understand a bit about how the Disruptor is implemented.</p>
<p>We will be looking at the implementation of the single-producer
Disruptor, because in our pipelines there will never be more than one
producer per queue (the stage before it)<a href="#fn5"
class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>.</p>
<p>Let’s first have a look at the datatype and then explain each
field:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RingBuffer</span> a <span class="ot">=</span> <span class="dt">RingBuffer</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> capacity             ::</span> <span class="dt">Int</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> elements             ::</span> <span class="dt">IOArray</span> <span class="dt">Int</span> a</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> cursor               ::</span> <span class="dt">IORef</span> <span class="dt">SequenceNumber</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> gatingSequences      ::</span> <span class="dt">IORef</span> (<span class="dt">IOArray</span> <span class="dt">Int</span> (<span class="dt">IORef</span> <span class="dt">SequenceNumber</span>))</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> cachedGatingSequence ::</span> <span class="dt">IORef</span> <span class="dt">SequenceNumber</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">SequenceNumber</span> <span class="ot">=</span> <span class="dt">SequenceNumber</span> <span class="dt">Int</span></span></code></pre></div>
<p>The Disruptor is a ring buffer queue with a fixed
<code>capacity</code>. It’s backed by an array whose length is equal to
the capacity, this is where the <code>elements</code> of the ring buffer
are stored. There’s a monotonically increasing counter called the
<code>cursor</code> which keeps track of how many elements we have
written. By taking the value of the <code>cursor</code> modulo the
<code>capacity</code> we get the index into the array where we are
supposed to write our next element (this is how we wrap around the
array, i.e. forming a ring). In order to avoid overwriting elements
which have not yet been consumed we also need to keep track of the
cursors of all consumers (<code>gatingSequences</code>). As an
optimisation we cache where the last consumer is
(<code>cachedGatingSequence</code>).</p>
<p>The API from the producing side looks as follows:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tryClaimBatch   ::</span> <span class="dt">RingBuffer</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">SequenceNumber</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">writeRingBuffer ::</span> <span class="dt">RingBuffer</span> a <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="ot">publish         ::</span> <span class="dt">RingBuffer</span> a <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>We first try to claim <code>n :: Int</code> slots in the ring buffer,
if that fails (returns <code>Nothing</code>) then we know that there
isn’t space in the ring buffer and we should apply backpressure upstream
(e.g. if the producer is a web server, we might want to temporarily
rejecting clients with status code 503). Once we successfully get a
sequence number, we can start writing our data. Finally we publish the
sequence number, this makes it available on the consumer side.</p>
<p>The consumer side of the API looks as follows:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addGatingSequence ::</span> <span class="dt">RingBuffer</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IORef</span> <span class="dt">SequenceNumber</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ot">waitFor           ::</span> <span class="dt">RingBuffer</span> a <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">SequenceNumber</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readRingBuffer    ::</span> <span class="dt">RingBuffer</span> a <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>First we need to add a consumer to the ring buffer (to avoid
overwriting on wrap around of the ring), this gives us a consumer
cursor. The consumer is responsible for updating this cursor, the ring
buffer will only read from it to avoid overwriting. After the consumer
reads the cursor, it calls <code>waitFor</code> on the read value, this
will block until an element has been <code>publish</code>ed on that slot
by the producer. In the case that the producer is ahead it will return
the current sequence number of the producer, hence allowing the consumer
to do a batch of reads (from where it currently is to where the producer
currently is). Once the consumer has caught up with the producer it
updates its cursor.</p>
<p>Here’s an example which hopefully makes things more concrete:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  rb <span class="ot">&lt;-</span> newRingBuffer_ <span class="dv">2</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> addGatingSequence rb</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> batchSize <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> hi <span class="ot">&lt;-</span> tryClaimBatch rb batchSize</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lo <span class="ot">=</span> hi <span class="op">-</span> (coerce batchSize <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  assertIO (lo <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  assertIO (hi <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Notice that these writes are batched:</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (\(i, c) <span class="ot">-&gt;</span> writeRingBuffer rb i c) (<span class="fu">zip</span> [lo<span class="op">..</span>hi] [<span class="ch">&#39;a&#39;</span><span class="op">..</span>])</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  publish rb hi</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Since the ring buffer size is only two and we&#39;ve written two</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- elements, it&#39;s full at this point:</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">&lt;-</span> tryClaimBatch rb <span class="dv">1</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  consumed <span class="ot">&lt;-</span> readIORef c</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  produced <span class="ot">&lt;-</span> waitFor rb consumed</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The consumer can do batched reads, and only do some expensive</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- operation once it reaches the end of the batch:</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>  xs <span class="ot">&lt;-</span> <span class="fu">mapM</span> (readRingBuffer rb) [consumed <span class="op">+</span> <span class="dv">1</span><span class="op">..</span>produced]</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>  assertIO (xs <span class="op">==</span> <span class="st">&quot;ab&quot;</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The consumer updates its cursor:</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  writeIORef c produced</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Now there&#39;s space again for the producer:</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> <span class="dv">2</span> <span class="ot">&lt;-</span> tryClaimBatch rb <span class="dv">1</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ()</span></code></pre></div>
<p>See the <code>Disruptor</code> <a href="src/Disruptor.hs">module</a>
in case you are interested in the implementation details.</p>
<p>Hopefully by now we’ve seen enough internals to be able to explain
why the Disruptor performs well. First of all, by using a ring buffer we
only allocate memory when creating the ring buffer, it’s then reused
when we wrap around the ring. The ring buffer is implemented using an
array, so the memory access patterns are predictable and the CPU can do
prefetching. The consumers don’t have a copy of the data, they merely
have a pointer (the sequence number) to how far in the producer’s ring
buffer they are, which allows for fanning out or sharding to multiple
consumers without copying data. The fact that we can batch on both the
write side (with <code>tryClaimBatch</code>) and on the reader side
(with <code>waitFor</code>) also helps. All this taken together
contributes to the Disruptor’s performance.</p>
</section>
<section id="disruptor-pipeline-deployment" class="level2">
<h2><a href="#disruptor-pipeline-deployment"
title="Disruptor pipeline deployment">Disruptor pipeline
deployment</a></h2>
<p>Recall that the reason we introduced the Disruptor was to avoid
copying elements of the queue when fanning out (using the
<code>:&amp;&amp;&amp;</code> combinator) and sharding.</p>
<p>The idea would be to have the workers we fan-out to both be consumers
of the same Disruptor, that way the inputs don’t need to be copied.
Avoiding to copy the individual outputs from the worker’s queues (of
<code>a</code>s and <code>b</code>s) into the combined output (of
<code>(a, b)</code>s) is a bit trickier.</p>
<p>One way, that I think works, is to do something reminiscent what <a
href="https://hackage.haskell.org/package/vector"><code>Data.Vector</code></a>
does for pairs. That’s a vector of pairs (<code>Vector (a, b)</code>) is
actually represented as a pair of vectors
(<code>(Vector a, Vector b)</code>)<a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>We can achieve this with <a
href="http://simonmar.github.io/bib/papers/assoc.pdf">associated
types</a> as follows:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasRB</span> a <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">RB</span><span class="ot"> a ::</span> <span class="dt">Type</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  newRB               ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RB</span> a)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  tryClaimBatchRB     ::</span> <span class="dt">RB</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">SequenceNumber</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  writeRingBufferRB   ::</span> <span class="dt">RB</span> a <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  publishRB           ::</span> <span class="dt">RB</span> a <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  addGatingSequenceRB ::</span> <span class="dt">RB</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Counter</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  waitForRB           ::</span> <span class="dt">RB</span> a <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">SequenceNumber</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  readRingBufferRB    ::</span> <span class="dt">RB</span> a <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>The instances for this class for types that are not pairs will just
use the Disruptor that we defined above.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasRB</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">RB</span> <span class="dt">String</span> <span class="ot">=</span> <span class="dt">RB</span> (<span class="dt">RingBuffer</span> <span class="dt">String</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  newRB n        <span class="ot">=</span> <span class="dt">RB</span> <span class="op">&lt;$&gt;</span> newRingBuffer_ n</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>While the instance for pairs will use a pair of Disruptors:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">HasRB</span> a, <span class="dt">HasRB</span> b) <span class="ot">=&gt;</span> <span class="dt">HasRB</span> (a, b) <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">RB</span> (a, b) <span class="ot">=</span> <span class="dt">RBPair</span> (<span class="dt">RB</span> a) (<span class="dt">RB</span> b)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  newRB n <span class="ot">=</span> <span class="dt">RBPair</span> <span class="op">&lt;$&gt;</span> newRB n <span class="op">&lt;*&gt;</span> newRB n</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>The <code>deploy</code> function for the fan-out combinator can now
avoid copying:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> (<span class="dt">HasRB</span> a, <span class="dt">HasRB</span> b) <span class="ot">=&gt;</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">RB</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RB</span> b)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>deploy (p <span class="op">:&amp;&amp;&amp;</span> q) xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  ys <span class="ot">&lt;-</span> deploy p xs</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  zs <span class="ot">&lt;-</span> deploy q xs</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">RBPair</span> ys zs)</span></code></pre></div>
<p>Sharding, or partition parallelism as Jim calls it, is a way to make
a copy of a pipeline and divert half of the events to the first copy and
the other half to the other copy. Assuming there are enough unused
CPUs/core, this could effectively double the throughput. It might be
helpful to think of the events at even positions in the stream going to
the first pipeline copy while the events in the odd positions in the
stream go to the second copy of the pipeline.</p>
<p>When we shard in the <code>TQueue</code> deployment of pipelines we
end up copying events from the original stream into the two pipeline
copies. This is similar to copying when fanning out, which we discussed
above, and the solution is similar.</p>
<p>First we need to change the pipeline type so that the shard
constructor has an output type that’s <code>Sharded</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>data P :: Type -&gt; Type -&gt; Type where</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  ...</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="st">- Shard :: P a b -&gt; P a b</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="va">+ Shard :: P a b -&gt; P a (Sharded b)</span></span></code></pre></div>
<p>This type is in fact merely the identity type:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Sharded</span> a <span class="ot">=</span> <span class="dt">Sharded</span> a</span></code></pre></div>
<p>But it allows us to define a <code>HasRB</code> instance which does
the sharding without copying as follows:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasRB</span> a <span class="ot">=&gt;</span> <span class="dt">HasRB</span> (<span class="dt">Sharded</span> a) <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">RB</span> (<span class="dt">Sharded</span> a) <span class="ot">=</span> <span class="dt">RBShard</span> <span class="dt">Partition</span> <span class="dt">Partition</span> (<span class="dt">RB</span> a) (<span class="dt">RB</span> a)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  readRingBufferRB (<span class="dt">RBShard</span> p1 p2 xs ys) i</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> partition i p1 <span class="ot">=</span> readRingBufferRB xs i</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> partition i p2 <span class="ot">=</span> readRingBufferRB ys i</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>The idea being that we split the ring buffer into two, like when
fanning out, and then we have a way of taking an index and figuring out
which of the two ring buffers it’s actually in.</p>
<p>This partitioning information, <code>p</code>, is threaded though
while deploying:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>deploy (<span class="dt">Shard</span> f) p xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (p1, p2) <span class="ot">=</span> addPartition p</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  ys1 <span class="ot">&lt;-</span> deploy f p1 xs</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  ys2 <span class="ot">&lt;-</span> deploy f p2 xs</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">RBShard</span> p1 p2 ys1 ys2)</span></code></pre></div>
<p>For the details of how this works see the following footnote<a
href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a> and the
<code>HasRB (Sharded a)</code> instance in the following <a
href="https://github.com/stevana/pipelining-with-disruptor/blob/main/src/RingBufferClass.hs">module</a>.</p>
<p>If we <a
href="https://github.com/stevana/pipelining-with-disruptor/blob/main/src/LibMain/Sleep.hs">run</a>
our sleep pipeline from before using the Disruptor <a
href="https://github.com/stevana/pipelining-with-disruptor/blob/main/src/Pipeline.hs">deployment</a>
we get similar timings as with the queue deployment:</p>
<pre><code>&gt; runDisruptorSleep False
(2.01 secs, 383,489,976 bytes)

&gt; runDisruptorSleepSharded False
(1.37 secs, 286,207,264 bytes)</code></pre>
<p>In order to get a better understanding of how not copying when
fanning out and sharding improves performance, let’s instead have a look
at this pipeline which fans out five times:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">copyP ::</span> <span class="dt">P</span> () ()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>copyP <span class="ot">=</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Id</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">:&gt;&gt;&gt;</span> <span class="dt">Map</span> (<span class="fu">const</span> ())</span></code></pre></div>
<p>If we deploy this pipeline using queues and feed it five million
items we get the following statistics from the profiler:</p>
<pre><code>11,457,369,968 bytes allocated in the heap
   198,233,200 bytes copied during GC
     5,210,024 bytes maximum residency (27 sample(s))
     4,841,208 bytes maximum slop
           216 MiB total memory in use (0 MB lost due to fragmentation)


real    0m8.368s
user    0m10.647s
sys     0m0.778s</code></pre>
<p>While the same setup but using the Disruptor deployment gives us:</p>
<pre><code>6,629,305,096 bytes allocated in the heap
  110,544,544 bytes copied during GC
    3,510,424 bytes maximum residency (17 sample(s))
    5,090,472 bytes maximum slop
          214 MiB total memory in use (0 MB lost due to fragmentation)

real    0m5.028s
user    0m7.000s
sys     0m0.626s</code></pre>
<p>So about an half the amount of bytes allocated in the heap using the
Disruptor.</p>
<p>If we double the fan-out factor from five to ten, we get the
following stats with the queue deployment:</p>
<pre><code>35,552,340,768 bytes allocated in the heap
 7,355,365,488 bytes copied during GC
    31,518,256 bytes maximum residency (295 sample(s))
       739,472 bytes maximum slop
           257 MiB total memory in use (0 MB lost due to fragmentation)

real    0m46.104s
user    3m35.192s
sys     0m1.387s</code></pre>
<p>and the following for the Disruptor deployment:</p>
<pre><code>11,457,369,968 bytes allocated in the heap
   198,233,200 bytes copied during GC
     5,210,024 bytes maximum residency (27 sample(s))
     4,841,208 bytes maximum slop
           216 MiB total memory in use (0 MB lost due to fragmentation)

real    0m8.368s
user    0m10.647s
sys     0m0.778s</code></pre>
<p>So it seems that the gap between the two deployments widens as we
introduce more fan-out, this expected as the queue implementation will
have more copying of data to do<a href="#fn8" class="footnote-ref"
id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
</section>
<section id="observability" class="level2">
<h2><a href="#observability"
title="Observability">Observability</a></h2>
<p>Given that pipelines are directed acyclic graphs and that we have a
concrete datatype constructor for each pipeline combinator, it’s
relatively straight forward to add a visualisation of a deployment.</p>
<p>Furthermore, since each Disruptor has a <code>cursor</code> keeping
that of how many elements it produced and all the consumers of a
Disruptor have one keeping track of how many elements they have
consumed, we can annotate our deployment visualisation with this data
and get a good idea of the progress the pipeline is making over time as
well as spot potential bottlenecks.</p>
<p>Here’s an example of such an visualisation, for a <a
href="https://github.com/stevana/pipelining-with-disruptor/blob/main/src/LibMain/WordCount.hs">word
count</a> pipeline, as an interactive SVG (you need to click on the
image):</p>
<p><a
href="https://stevana.github.io/svg-viewer-in-svg/wordcount-pipeline.svg"><img
src="https://stevana.github.io/svg-viewer-in-svg/wordcount-pipeline.svg"
alt="Demo" /></a></p>
<p>The way it’s implemented is that we spawn a separate thread that read
the producer’s cursors and consumer’s gating sequences
(<code>IORef SequenceNumber</code> in both cases) every millisecond and
saves the <code>SequenceNumber</code>s (integers). After collecting this
data we can create one dot diagram for every time the data changed. In
the demo above, we also collected all the elements of the Disruptor,
this is useful for debugging (the implementation of the pipeline
library), but it would probably be too expensive to enable this when
there’s a lot of items to be processed.</p>
<p>I have written a separate write up on how to make the SVG interactive
over <a
href="https://stevana.github.io/visualising_datastructures_over_time_using_svg.html">here</a>.</p>
</section>
<section id="running" class="level2">
<h2><a href="#running" title="Running">Running</a></h2>
<p>All of the above Haskell code is available on <a
href="https://github.com/stevana/pipelining-with-disruptor/">GitHub</a>.
The easiest way to install the right version of GHC and cabal is
probably via <a href="https://www.haskell.org/ghcup/">ghcup</a>. Once
installed the <a
href="https://github.com/stevana/pipelining-with-disruptor/tree/main/src/LibMain">examples</a>
can be run as follows:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> data/test.txt <span class="kw">|</span> <span class="ex">cabal</span> run uppercase</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> data/test.txt <span class="kw">|</span> <span class="ex">cabal</span> run wc <span class="co"># word count</span></span></code></pre></div>
<p>The <a
href="https://github.com/stevana/pipelining-with-disruptor/blob/main/src/LibMain/Sleep.hs">sleep
examples</a> are run like this:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> run sleep</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> run sleep <span class="at">--</span> <span class="at">--sharded</span></span></code></pre></div>
<p>The different <a
href="https://github.com/stevana/pipelining-with-disruptor/blob/main/src/LibMain/Copying.hs">copying
benchmarks</a> can be reproduced as follows:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> flag <span class="kw">in</span> <span class="st">&quot;--no-sharding&quot;</span> <span class="dt">\</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;--copy10&quot;</span> <span class="dt">\</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;--tbqueue-no-sharding&quot;</span> <span class="dt">\</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;--tbqueue-copy10&quot;</span><span class="kw">;</span> <span class="cf">do</span> <span class="dt">\</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  <span class="ex">cabal</span> build copying <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">time</span> cabal run copying <span class="at">--</span> <span class="st">&quot;</span><span class="va">$flag</span><span class="st">&quot;</span> <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="ex">eventlog2html</span> copying.eventlog <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ghc-prof-flamegraph</span> copying.prof <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">firefox</span> copying.eventlog.html <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">firefox</span> copying.svg</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a><span class="cf">done</span></span></code></pre></div>
</section>
<section id="further-work-and-contributing" class="level2">
<h2><a href="#further-work-and-contributing"
title="Further work and contributing">Further work and
contributing</a></h2>
<p>There’s still a lot to do, but I thought it would be a good place to
stop for now. Here are a bunch of improvements, in no particular
order:</p>
<ul class="task-list">
<li><input type="checkbox" />Implement the <code>Arrow</code> instance
for Disruptor <code>P</code>ipelines, this isn’t as straightforward as
in the model case, because the combinators are littered with
<code>HasRB</code> constraints, e.g.:
<code>(:&amp;&amp;&amp;) :: (HasRB b, HasRB c) =&gt; P a b -&gt;       P a c -&gt; P a (b, c)</code>.
Perhaps taking inspiration from constrained/restricted monads? In the
<code>r/haskell</code> discussion, the user <code>ryani</code> <a
href="https://old.reddit.com/r/haskell/comments/19ef2b6/parallel_stream_processing_with_zerocopy_fanout/kjhfyfk/">pointed
out</a> a promising solution involving adding <code>Constraint</code>s
to the <code>HasRB</code> class. This would allow us to specify
pipelines using the <a
href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/arrows.html">arrow
notation</a>.</li>
<li><input type="checkbox" />I believe the current pipeline combinator
allow for arbitrary directed acyclic graphs (DAGs), but what if feedback
cycles are needed? Does an <code>ArrowLoop</code> instance make sense in
that case?</li>
<li><input type="checkbox" />Can we avoid copying when using
<code>Either</code> via <code>(:|||)</code> or <code>(:+++)</code>, e.g.
can we store all <code>Left</code>s in one ring buffer and all
<code>Right</code>s in another?</li>
<li><input type="checkbox" />Use unboxed arrays for types that can be
unboxed in the <code>HasRB</code> instances?</li>
<li><input type="checkbox" />In the word count example we get an input
stream of lines, but we only want to produce a single line as output
when we reach the end of the input stream. In order to do this I added a
way for workers to say that <code>NoOutput</code> was produced in one
step. Currently that constructor still gets written to the output
Disruptor, would it be possible to not write it but still increment the
sequence number counter?</li>
<li><input type="checkbox" />Add more monitoring? Currently we only keep
track of the queue length, i.e. saturation. Adding service time,
i.e. how long it takes to process an item, per worker shouldn’t be hard.
Latency (how long an item has been waiting in the queue) would be more
tricky as we’d need to annotate and propagate a timestamp with the
item?</li>
<li><input type="checkbox" />Since monitoring adds a bit of overheard,
it would be neat to be able to turn monitoring on and off at
runtime;</li>
<li><input type="checkbox" />The <code>HasRB</code> instances are
incomplete, and it’s not clear if they need to be completed? More
testing and examples could help answer this question, or perhaps a
better visualisation?</li>
<li><input type="checkbox" />Actually test using
<code>prop_commute</code> partially applied to a concrete pipeline?</li>
<li><input type="checkbox" />Implement a property-based testing
generator for pipelines and test using <code>prop_commute</code> using
random pipelines?</li>
<li><input type="checkbox" />Add network/HTTP source and sink?</li>
<li><input type="checkbox" />Deploy across network of computers?</li>
<li><input type="checkbox" />Hot-code upgrades of workers/stages with
zero downtime, perhaps continuing on my earlier <a
href="https://stevana.github.io/hot-code_swapping_a_la_erlang_with_arrow-based_state_machines.html">attempt</a>?</li>
<li><input type="checkbox" />In addition to upgrading the
workers/stages, one might also want to rewire the pipeline itself. Doug
made me aware of an old <a
href="https://inria.hal.science/inria-00306565">paper</a> by Gilles Kahn
and David MacQueen (1976), where they reconfigure their network on the
fly. Perhaps some ideas can be stole from there?</li>
<li><input type="checkbox" />Related to reconfiguring is to be able
shard/scale/reroute pipelines and add more machines without downtime.
Can we do this automatically based on our monitoring? Perhaps building
upon my earlier <a
href="https://stevana.github.io/elastically_scalable_thread_pools.html">attempt</a>?</li>
<li><input type="checkbox" />More benchmarks, in particular trying to
confirm that we indeed don’t allocate when fanning out and sharding<a
href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>, as well as benchmarks against other
streaming libraries.</li>
</ul>
<p>If any of this seems interesting, feel free to get involved.</p>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li>Guy Steele’s talk <a
href="https://www.infoq.com/presentations/Thinking-Parallel-Programming/">How
to Think about Parallel Programming: Not!</a> (2011);</li>
<li><a href="https://youtube.com/watch?v=DCdGlxBbKU4">Understanding the
Disruptor, a Beginner’s Guide to Hardcore Concurrency</a> by Trisha Gee
and Mike Barker (2011);</li>
<li>Mike Barker’s <a
href="https://github.com/mikeb01/folklore/tree/master/src/main/java/performance">brute-force
solution to Guy’s problem and benchmarks</a>;</li>
<li><a
href="https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/">Streaming
101: The world beyond batch</a> (2015);</li>
<li><a
href="https://www.oreilly.com/radar/the-world-beyond-batch-streaming-102/">Streaming
102: The world beyond batch</a> (2016);</li>
<li><a
href="https://people.eecs.berkeley.edu/~brewer/papers/SEDA-sosp.pdf"><em>SEDA:
An Architecture for Well-Conditioned Scalable Internet Services</em></a>
(2001);</li>
<li><a
href="https://www.microsoft.com/en-us/research/publication/naiad-a-timely-dataflow-system-2/">Microsoft
Naiad</a>: a timely dataflow system (with stage notifications)
(2013);</li>
<li>Elixir’s ALF flow-based programming <a
href="https://www.youtube.com/watch?v=2XrYd1W5GLo">library</a>
(2021);</li>
<li><a href="https://mazzo.li/posts/fast-pipes.html">How fast are Linux
pipes anyway?</a> (2022);</li>
<li><a
href="https://man.freebsd.org/cgi/man.cgi?query=netmap&amp;sektion=4">netmap</a>:
a framework for fast packet I/O;</li>
<li><a
href="https://www.gibney.org/the_output_of_linux_pipes_can_be_indeter">The
output of Linux pipes can be indeterministic</a> (2019);</li>
<li><a href="https://www.youtube.com/watch?v=Mc3tTRkjCvE">Programming
Distributed Systems</a> by Mae Milano (Strange Loop, 2023);</li>
<li><a
href="https://www.youtube.com/watch?v=ipceTuJlw-M">Pipeline-oriented
programming</a> by Scott Wlaschin (NDC Porto, 2023).</li>
</ul>
</section>
<section id="discussion" class="level2">
<h2><a href="#discussion" title="Discussion">Discussion</a></h2>
<ul>
<li><a
href="https://discourse.haskell.org/t/parallel-stream-processing-with-zero-copy-fan-out-and-sharding/8632">discourse.haskell.org</a>;</li>
<li><a
href="https://old.reddit.com/r/haskell/comments/19ef2b6/parallel_stream_processing_with_zerocopy_fanout/">r/haskell</a>;</li>
<li><a
href="https://lobste.rs/s/mvgdev/parallel_stream_processing_with_zero">lobste.rs</a>.</li>
</ul>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>I noticed that the Wikipedia page for <a
href="https://en.wikipedia.org/wiki/Dataflow_programming">dataflow
programming</a> mentions that Jack Dennis and his graduate students
pioneered that style of programming while he was at MIT in the 60s. I
knew Doug was at MIT around that time as well, and so I sent an email to
Doug asking if he knew of Jack’s work. Doug replied saying he had left
MIT by the 60s, but was still collaborating with people at MIT and was
aware of Jack’s work and also the work by Kelly, Lochbaum and Vyssotsky
on <a href="https://archive.org/details/bstj40-3-669">BLODI</a> (1961)
was on his mind when he wrote the garden hose memo (1964).<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>There’s a paper called <a
href="http://flint.cs.yale.edu/trifonov/papers/pfrp.pdf">Parallel
Functional Reactive Programming</a> by Peterson et al. (2000), but as
Conal Elliott <a
href="http://conal.net/papers/push-pull-frp/push-pull-frp.pdf">points</a>
out:</p>
<blockquote>
<p>“Peterson et al. (2000) explored opportunities for parallelism in
implementing a variation of FRP. While the underlying semantic model was
not spelled out, it seems that semantic determinacy was not preserved,
in contrast to the semantically determinate concurrency used in this
paper (Section 11).”</p>
</blockquote>
<p>Conal’s approach (his Section 11) seems to build upon very fine
grained parallelism provided by an “unambiguous choice” operator which
is implemented by spawning two threads. I don’t understand where exactly
this operator is used in the implementation, but if it’s used every time
an element is processed (in parallel) then the overheard of spawning the
threads could be significant?<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The design space of what pipeline combinators to include
in the pipeline datatype is very big. I’ve chosen the ones I’ve done
because they are instances of already well established type classes:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">P</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span>    <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  g <span class="op">.</span> f <span class="ot">=</span> f <span class="op">:&gt;&gt;&gt;</span> g</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">P</span> <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  arr     <span class="ot">=</span> <span class="dt">Map</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  f <span class="op">***</span> g <span class="ot">=</span> f <span class="op">:***</span> g</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  f <span class="op">&amp;&amp;&amp;</span> g <span class="ot">=</span> f <span class="op">:&amp;&amp;&amp;</span> g</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowChoice</span> <span class="dt">P</span> <span class="kw">where</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  f <span class="op">+++</span> g <span class="ot">=</span> f <span class="op">:+++</span> g</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  f <span class="op">|||</span> g <span class="ot">=</span> f <span class="op">:|||</span> g</span></code></pre></div>
<p>Ideally we’d also like to be able to use <code>Arrow</code>
notation/syntax to describe our pipelines. Even better would be if arrow
notation worked for Cartesian categories. See Conal Elliott’s work on <a
href="http://conal.net/papers/compiling-to-categories/">compiling to
categories</a>, as well as Oleg Grenrus’ GHC <a
href="https://github.com/phadej/overloaded/blob/master/src/Overloaded/Categories.hs">plugin</a>
that does the right thing and translates arrow syntax into Cartesian
categories.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Search for “QuickCheck GADTs” if you are interested in
finding out more about this topic.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The Disruptor also comes in a multi-producer variant,
see the following <a
href="https://github.com/stevana/pipelined-state-machines/tree/main/src/Disruptor/MP">repository</a>
for a Haskell version or the <a
href="https://github.com/LMAX-Exchange/disruptor">LMAX</a> repository
for the original Java implementation.<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>See also <a
href="https://en.wikipedia.org/wiki/AoS_and_SoA">array of structures vs
structure of arrays</a> in other programming languages.<a href="#fnref6"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>The partitioning information consists of the total
number of partitions and the index of the current partition.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Partition</span> <span class="ot">=</span> <span class="dt">Partition</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> pIndex ::</span> <span class="dt">Int</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> pTotal ::</span> <span class="dt">Int</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>No partitioning is represented as follows:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">noPartition ::</span> <span class="dt">Partition</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>noPartition <span class="ot">=</span> <span class="dt">Partition</span> <span class="dv">0</span> <span class="dv">1</span></span></code></pre></div>
<p>While creating a new partition is done as follows:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addPartition ::</span> <span class="dt">Partition</span> <span class="ot">-&gt;</span> (<span class="dt">Partition</span>, <span class="dt">Partition</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>addPartition (<span class="dt">Partition</span> i total) <span class="ot">=</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">Partition</span> i (total <span class="op">*</span> <span class="dv">2</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Partition</span> (i <span class="op">+</span> total) (total <span class="op">*</span> <span class="dv">2</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div>
<p>So, for example, if we partition twice we get:</p>
<pre><code>&gt; let (p1, p2) = addPartition noPartition in (addPartition p1, addPartition p2)
((Partition 0 4, Partition 2 4), (Partition 1 4, Partition 3 4))</code></pre>
<p>From this information we can compute if an index is in an partition
or not as follows:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">partition ::</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> <span class="dt">Partition</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>partition i (<span class="dt">Partition</span> n total) <span class="ot">=</span> i <span class="ot">`mod`</span> total <span class="op">==</span> <span class="dv">0</span> <span class="op">+</span> n</span></code></pre></div>
<p>To understand why this works, it might be helpful to consider the
case where we only have two partitions. We can partition on even or odd
indices as follows: <code>even i = i `mod` 2 == 0 + 0</code> and
<code>odd i = i `mod` 2 == 0 + 1</code>. Written this way we can easier
see how to generalise to <code>total</code> partitions:
<code>partition i (Partition n total) = i `mod` total == 0 + n</code>.
So for <code>total = 2</code> then
<code>partition i (Partition 0 2) == even</code> while
<code>partition i (Partition 1 2) == odd</code>.</p>
<p>Since partitioning and partitioning a partition, etc, always
introduce a power of two we can further optimise to use bitwise or as
follows:
<code>partition i (Partition n total) = i .|. (total - 1) == 0 + n</code>
thereby avoiding the expensive modulus computation. This is a trick used
in Disruptor as well, and the reason why the capacity of a Disruptor
always needs to be a power of two.<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>I’m not sure why “bytes allocated in the heap” gets
doubled in the Disruptor case and tripled in the queue cases though?<a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>I’m not sure why “bytes allocated in the heap” gets
doubled in the Disruptor case and tripled in the queue cases though?<a
href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></description>
      <category>Development</category>
    </item>

    <item>
      <title>Visualising datastructures over time using SVG</title>
      <link>https://stevana.github.io/visualising_datastructures_over_time_using_svg.html</link>
      <guid>https://stevana.github.io/visualising_datastructures_over_time_using_svg.html</guid>
      <pubDate>Sat, 9 Sep 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>SVG viewer written in SVG</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#demo" id="toc-demo">Demo</a></li>
<li><a href="#the-code" id="toc-the-code">The code</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
</ul>
</nav>
<div class="date">Posted on Sep  9, 2023</div>
<p>This post is about how to write an <a
href="https://en.wikipedia.org/wiki/SVG">SVG</a> viewer / browser /
“slideshow” which is itself a self-contained SVG.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>I’ve been working on a parallel processing pipeline. Each stage of
the pipeline is running on a separate thread, and it takes some work
items from a queue in front of it, processes them and then puts them in
the queue in front of the next stage in the pipeline.</p>
<p>In order to better understand what exactly is going on I thought I’d
visualise the pipeline including the length and contents of all queues
as well as the position each worker/stage is at in the queue it’s
processing.</p>
<p>For now lets just imagine that an SVG image is created every time
interval. So after a run of the pipeline we’ll have a bunch of SVGs
showing us how it evolved over time.</p>
<p>Initially I was using the <a
href="https://feh.finalrewind.org/"><code>feh</code></a> image viewer,
which if you pass it several images lets you navigate through them using
the arrow keys.</p>
<p>But then I wondered: how can I show these SVGs to somebody else over
the web?</p>
</section>
<section id="demo" class="level2">
<h2><a href="#demo" title="Demo">Demo</a></h2>
<p>Before I show you how I did it, let’s have a look at the resulting
pipeline visualisation (you need to click on the image):</p>
<p><a
href="https://stevana.github.io/svg-viewer-in-svg/wordcount-pipeline.svg"><img
src="https://stevana.github.io/svg-viewer-in-svg/wordcount-pipeline.svg"
alt="Demo" /></a></p>
<p>The arrows in the top left corner are clickable and will take you to
the first, next, previous and last SVG respectively.</p>
<p>What you are seeing is a run of a parallel word count pipeline, where
lines are coming in from stdin and the counts are being written to
stdout at the end.</p>
</section>
<section id="the-code" class="level2">
<h2><a href="#the-code" title="The code">The code</a></h2>
<p>Let’s start by having a look at the SVG itself.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode xml"><code class="sourceCode xml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">svg</span><span class="ot"> version=</span><span class="st">&quot;1.1&quot;</span><span class="ot"> xmlns=</span><span class="st">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  // The navigation menu for going to the first, previous, next and last</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  // slide/image. There&#39;s also a progress bar here which shows which slide</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  // we are currently on and how many there are in total.</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">g</span><span class="ot"> font-family=</span><span class="st">&quot;Times,serif&quot;</span><span class="ot"> font-size=</span><span class="st">&quot;14.00&quot;</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">text</span><span class="ot"> id=</span><span class="st">&quot;first&quot;</span><span class="ot">    x=</span><span class="st">&quot;20&quot;</span><span class="ot">  y=</span><span class="st">&quot;30&quot;</span>&gt;⇤&lt;/<span class="kw">text</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">text</span><span class="ot"> id=</span><span class="st">&quot;previous&quot;</span><span class="ot"> x=</span><span class="st">&quot;50&quot;</span><span class="ot">  y=</span><span class="st">&quot;30&quot;</span>&gt;←&lt;/<span class="kw">text</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">text</span><span class="ot"> id=</span><span class="st">&quot;progress&quot;</span><span class="ot"> x=</span><span class="st">&quot;80&quot;</span><span class="ot">  y=</span><span class="st">&quot;30&quot;</span>&gt;&lt;/<span class="kw">text</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">text</span><span class="ot"> id=</span><span class="st">&quot;next&quot;</span><span class="ot">     x=</span><span class="st">&quot;120&quot;</span><span class="ot"> y=</span><span class="st">&quot;30&quot;</span>&gt;→&lt;/<span class="kw">text</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">text</span><span class="ot"> id=</span><span class="st">&quot;last&quot;</span><span class="ot">     x=</span><span class="st">&quot;150&quot;</span><span class="ot"> y=</span><span class="st">&quot;30&quot;</span>&gt;⇥&lt;/<span class="kw">text</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  &lt;/<span class="kw">g</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  // Placeholder for the image.</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">g</span><span class="ot"> id=</span><span class="st">&quot;image&quot;</span>&gt;&lt;/<span class="kw">g</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  // The index of the currently viewed image.</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">desc</span><span class="ot"> id=</span><span class="st">&quot;0&quot;</span>&gt;&lt;/<span class="kw">desc</span>&gt;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  // The fact that we can embedd JavaScript into SVGs is what makes this</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  // whole thing work.</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">script</span>&gt;</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  // <span class="bn">&lt;![CDATA[</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    // Let me move this out to its own code block, so we get syntax</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    // highlighting.</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>  // <span class="bn">]]&gt;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  &lt;/<span class="kw">script</span>&gt;</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">svg</span>&gt;</span></code></pre></div>
<p>The following goes into the script tag above:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Array holding the SVG images.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> imgs <span class="op">=</span> <span class="kw">new</span> <span class="bu">Array</span>(</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;&lt;svg&gt;...&lt;/svg&gt;&quot;</span><span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;&lt;svg&gt;...&lt;/svg&gt;&quot;</span><span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;&lt;svg&gt;...&lt;/svg&gt;&quot;</span><span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>      )<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Helper for registering onclick handlers.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">registerClick</span>(selector<span class="op">,</span> f) {</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(selector)<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> (e) <span class="kw">=&gt;</span> {</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="fu">f</span>(e)<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        })<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set and return the value of our counter, this is abusing the id</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// of the desc tag...</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">setCounter</span>(f) {</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> counter <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;desc&quot;</span>)<span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        counter<span class="op">.</span><span class="at">id</span> <span class="op">=</span> <span class="fu">f</span>(<span class="pp">parseInt</span>(counter<span class="op">.</span><span class="at">id</span>))<span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> counter<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Updates our image placeholder by injecting the SVG into the</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// image tag. Also updates the progress bar.</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">setImage</span>(i) {</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> img <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;#image&quot;</span>)<span class="op">;</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        img<span class="op">.</span><span class="fu">setAttribute</span>(<span class="st">&quot;href&quot;</span><span class="op">,</span> imgs[i])<span class="op">;</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="fu">updateProgress</span>()<span class="op">;</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Update the progress bar in the menu.</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">updateProgress</span>() {</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;#progress&quot;</span>)<span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>            <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;desc&quot;</span>)<span class="op">.</span><span class="at">id</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> (imgs<span class="op">.</span><span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We can now define our navigation functions in terms of setting</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the counter and the image.</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">first</span>() {</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        <span class="fu">setImage</span>(<span class="fu">setCounter</span>((_) <span class="kw">=&gt;</span> <span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">previous</span>() {</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="fu">setImage</span>(<span class="fu">setCounter</span>((i) <span class="kw">=&gt;</span> i <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="op">--</span>i))<span class="op">;</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">next</span>() {</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        <span class="fu">setImage</span>(<span class="fu">setCounter</span>((i) <span class="kw">=&gt;</span> i <span class="op">&gt;=</span> imgs<span class="op">.</span><span class="at">length</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">?</span> imgs<span class="op">.</span><span class="at">length</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">++</span>i))<span class="op">;</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">last</span>() {</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        <span class="fu">setImage</span>(<span class="fu">setCounter</span>((_) <span class="kw">=&gt;</span> imgs<span class="op">.</span><span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Finally, to kick things off: register onclick handlers for the</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// navigation buttons and set the image to the first image in the array.</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    <span class="fu">registerClick</span>(<span class="st">&quot;#first&quot;</span><span class="op">,</span>    (_) <span class="kw">=&gt;</span> <span class="fu">first</span>())<span class="op">;</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    <span class="fu">registerClick</span>(<span class="st">&quot;#next&quot;</span><span class="op">,</span>     (_) <span class="kw">=&gt;</span> <span class="fu">next</span>())<span class="op">;</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    <span class="fu">registerClick</span>(<span class="st">&quot;#previous&quot;</span><span class="op">,</span> (_) <span class="kw">=&gt;</span> <span class="fu">previous</span>())<span class="op">;</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="fu">registerClick</span>(<span class="st">&quot;#last&quot;</span><span class="op">,</span>     (_) <span class="kw">=&gt;</span> <span class="fu">last</span>())<span class="op">;</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    <span class="fu">setImage</span>(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We could even add keyboard support...</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">window</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;keydown&quot;</span><span class="op">,</span> (e) <span class="kw">=&gt;</span> {</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Left arrow or k.</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (e<span class="op">.</span><span class="at">keyCode</span> <span class="op">===</span> <span class="dv">37</span> <span class="op">||</span> e<span class="op">.</span><span class="at">keyCode</span> <span class="op">===</span> <span class="dv">75</span>) {</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>            <span class="fu">previous</span>()<span class="op">;</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Right arrow or j.</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> (e<span class="op">.</span><span class="at">keyCode</span> <span class="op">===</span> <span class="dv">39</span> <span class="op">||</span> e<span class="op">.</span><span class="at">keyCode</span> <span class="op">===</span> <span class="dv">74</span>) {</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>            <span class="fu">next</span>()<span class="op">;</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span></code></pre></div>
<p>Another thing worth mentioning is that in my application the thread
that collects the metrics runs about 1000 times per second. If there’s
no change in the metrics then we probably don’t want to display an image
that’s the same as the previous one. So I keep a CRC32 checksum of the
metrics that the last image is generated from and if the next metrics
data has the same checksum, I skip generating that image (as it will be
the same as the previous one).</p>
<p>The (inner) SVGs themselves are generated with graphviz via the <a
href="https://graphviz.org/doc/info/lang.html">dot</a> language, the <a
href="https://graphviz.org/doc/info/shapes.html#record">record-based</a>
node shapes turned out to be useful for visualing data structures.</p>
<p>It’s quite annoying to populate the <code>imgs</code> array by hand,
so I wrote a small bash <a href="src/svg-viewer-in-svg">script</a> which
takes a bunch of SVGs and outputs a single SVG which can be used to view
the original images.</p>
</section>
<section id="usage" class="level2">
<h2><a href="#usage" title="Usage">Usage</a></h2>
<p>The easiest way to get started is probably to clone the
repository.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/stevana/svg-viewer-in-svg</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> svg-viewer-in-svg</span></code></pre></div>
<p>In the <code>img/</code> directory there are three simple SVGs:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span> img/</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">circle.svg</span>  ellipse.svg  rectangle.svg</span></code></pre></div>
<p>We can combine them all into one a single SVG that is a “slideshow”
of the shapes as follows:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./src/svg-viewer-in-svg</span> img/<span class="pp">*</span>.svg <span class="op">&gt;</span> /tmp/combined-shapes.svg</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">firefox</span> /tmp/combined-shapes.svg</span></code></pre></div>
<p>If you want to “install” the script, simply copy it to any directory
that is in your <code>$PATH</code>.</p>
<p>One last thing worth noting is that hosting these combined SVGs on
GitHub is a bit of a pain. Merely checking them into a repository and
trying to include them in markdown won’t work, because GitHub appears to
be doing some SVG script tag sanitising for security reasons. Uploading
them to gh-pages and linking to those seems to work though<a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>I hope I’ve managed to inspire you to think about how to visualise
the execution of your own programs! Feel free to copy and adapt the code
as you see fit. If you come up with some interesting modifications or
better ways of doing things, then please do share!</p>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<p>Brendan Gregg’s <a
href="https://www.brendangregg.com/flamegraphs.html">flamegraphs</a>
also generates a clickable SVG. I got the idea of adding keyboard
support from looking at his SVG, there’s probably more interesting stuff
to steal there.</p>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The following <a
href="https://gist.github.com/ramnathv/2227408">gist</a> shows how to
create gh-pages branch that doesn’t have any history. Also see the
GitHub pages documentation for how to enable gh-pages for a
respository.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></description>
      <category>Observability</category>
    </item>

    <item>
      <title>Elastically scalable thread pools</title>
      <link>https://stevana.github.io/elastically_scalable_thread_pools.html</link>
      <guid>https://stevana.github.io/elastically_scalable_thread_pools.html</guid>
      <pubDate>Tue, 14 Mar 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>Elastically scalable thread pools</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#plan" id="toc-plan">Plan</a></li>
<li><a href="#pseudo-code" id="toc-pseudo-code">Pseudo-code</a>
<ul>
<li><a href="#main" id="toc-main">Main</a></li>
<li><a href="#worker-pool" id="toc-worker-pool">Worker pool</a></li>
<li><a href="#load-generator" id="toc-load-generator">Load
generator</a></li>
<li><a href="#pid-controller" id="toc-pid-controller">PID
controller</a></li>
</ul></li>
<li><a href="#how-it-works" id="toc-how-it-works">How it works</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
<li><a href="#discussion" id="toc-discussion">Discussion</a></li>
</ul>
</nav>
<div class="date">Posted on Mar 14, 2023</div>
<p>An experiment in controlling the size of a thread pool using a PID
controller.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>A tried and tested way to achieve parallelism is to use pipelining.
It’s used extensively in manufacturing and in computer hardware.</p>
<p>For example, Airbus <a
href="https://youtu.be/oxjT7veKi9c?t=2682">apparently</a> outputs two
airplanes per day on average, even though it takes two months to build a
single airplane from start to finish. It’s also used inside CPUs to <a
href="https://en.wikipedia.org/wiki/Instruction_pipelining">pipeline
instructions</a>.</p>
<p>Let’s imagine we want to take advantage of pipelining in some
software system. To make things more concrete, let’s say we have a
system where some kind of requests come on over the network and we want
to process them in some way. The first stage of the pipeline is to parse
the incoming requests from raw bytestrings into some more structured
data, the second stage is to apply some validation logic to the parsed
data and the third stage is to process the valid data and produce some
outputs that are then sent back to the client or stored somewhere.</p>
<p><img
src="https://raw.githubusercontent.com/stevana/elastically-scalable-thread-pools/main/img/pipeline.svg" /></p>
<p>The service time of an item can differ from stage to stage, for
example parsing might be slower than validation, which can create
bottlenecks. Luckily it’s quite easy to spot bottlenecks by merely
observing the queue lengths and once a slow stage is found we can often
fix it by merely adding an additional parallel processor to that stage.
For example we could spin up two or more threads that take bytestrings
from the first queue and turn them into structured data and thereby
compensate for parsing being slow.</p>
<p>By spinning up more threads we can decrease latency (waiting time in
the queue) and increase throughput (process more items), but we are also
on the other hand using more energy and potentially hogging CPU
resources that might be better used elsewhere in the pipeline or system
at large.</p>
<p>So here’s the question that the rest of this post is concerned about:
can we dynamically spin up and spin down threads at a stage in response
to the input queue length for that stage?</p>
</section>
<section id="plan" class="level2">
<h2><a href="#plan" title="Plan">Plan</a></h2>
<p>Let’s focus on a single stage of the pipeline to make things easier
for ourselves.</p>
<p><img
src="https://raw.githubusercontent.com/stevana/elastically-scalable-thread-pools/main/img/stage.svg" /></p>
<p>We’d like to increase the parallelism of the processors if the input
queue grows, and decrease it when the queue shrinks. One simple strategy
might be to establish thresholds, i.e. if there’s over <span
class="math inline">100</span> items in the input queue then allocate
more processors and if there’s no items in the queue then deallocate
them.</p>
<p>Since allocating and deallocating processors can be an expense in
itself, we’d like to avoid changing them processor count
unnecessarily.</p>
<p>The threshold based approach is sensitive to unnecessarily changing
the count if the arrival rate of work fluctuates. The reason for this is
because it only takes the <em>present</em> queue length into
account.</p>
<p>We can do better by also incorporating the <em>past</em> and trying
to predict the <em>future</em>, this is the basic idea of <a
href="https://en.wikipedia.org/wiki/PID_controller">PID controllers</a>
from <a href="https://en.wikipedia.org/wiki/Control_theory">control
theory</a>.</p>
<p>Here’s what the picture looks like with a PID controller in the
loop:</p>
<pre><code>                                            +----------------------------------+
                                            |                                  |
    -------------------------------------------&gt;[Input queue]--&gt;[Worker pool]-----&gt;[Output queue]--&gt;
                                            |                                  |
     r(t)   e(t)                    u(t)    |                                  |
    -----&gt;+------&gt;[PID controller]--------&gt; |                                  |
          ^                                 |                                  |
          |                                 +----------------------------------+
          |                                                 | y(t)
          +-------------------------------------------------+
</code></pre>
<p>The PID controller monitors the queue length <span
class="math inline"><em>y</em>(<em>t</em>)</span>, compares it to some
desired queue length <span
class="math inline"><em>r</em>(<em>t</em>)</span> (also known as the
setpoint) and calculates the error <span
class="math inline"><em>e</em>(<em>t</em>)</span>. The error determines
the control variable <span
class="math inline"><em>u</em>(<em>t</em>)</span> which is used to grow
or shrink the processor pool.</p>
</section>
<section id="pseudo-code" class="level2">
<h2><a href="#pseudo-code" title="Pseudo-code">Pseudo-code</a></h2>
<p>Let’s start top-down with the <code>main</code> function which drives
our whole experiment.</p>
<section id="main" class="level3">
<h3><a href="#main" title="Main">Main</a></h3>
<pre><code>main =

  // Create the in- and out-queues.
  inQueue  := newQueue()
  outQueue := newQueue()


  // The workers don&#39;t do anything interesting, they merely sleep for a bit to
  // pretend to be doing some work.
  worker := sleep 0.025s

  // Create an empty worker pool.
  pool := newPool(worker, inQueue, outQueue)

  // Start the PID controller in a background thread. The parameters provided
  // here allow us to tune the PID controller, we&#39;ll come back to them later.
  kp := 1
  ki := 0.05
  kd := 0.05
  dt := 0.01s
  fork(pidController(kp, ki, kd, dt, pool))


  // Create a workload for our workers. We use the sine function to create
  // between 0 and 40 work items every 0.1s for 60s. The idea being that because
  // the workload varies over time the PID controller will have some work to do
  // figuring out how many workers are needed.
  sineLoadGenerator(inQueue, 40, 0.1s, 60s)</code></pre>
</section>
<section id="worker-pool" class="level3">
<h3><a href="#worker-pool" title="Worker pool">Worker pool</a></h3>
<p>The worker pool itself is merely a struct which packs up the
necessary data we need to be able to scale it up and down.</p>
<pre><code>struct Pool =
  { inQueue:  Queue&lt;Input&gt;
  , outQueue: Queue&lt;Output&gt;
  , worker:   Function&lt;Input, Output&gt;
  , pids:     List&lt;ProcessId&gt;
  }</code></pre>
<p>Creating a <code>newPool</code> creates the struct with an empty list
of process ids.</p>
<pre><code>newPool worker inQueue outQueue = Pool { ..., pids: emptyList }</code></pre>
<p>Scaling up and down are functions that take and return a
<code>Pool</code>.</p>
<pre><code>scaleUp pool =
  work := forever
            x := readQueue(pool.inQueue)
            y := pool.worker(x)
            writeQueue(pool.outQueue, y)
  pid   := fork(work)
  pool&#39; := pool.pids = append(pid, pool.pids)
  return pool&#39;</code></pre>
<p>The function <code>scaleDown</code> does the inverse, i.e. kills and
removes the last process id from <code>pool.pids</code>.</p>
</section>
<section id="load-generator" class="level3">
<h3><a href="#load-generator" title="Load generator">Load
generator</a></h3>
<p>In order to create work load that varies over time we use the sine
function. The sine function oscillates between <span
class="math inline"> − 1</span> and <span
class="math inline">1</span>:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/elastically-scalable-thread-pools/main/img/sine.svg" /></p>
<p>We would like to have it oscillate between <span
class="math inline">0</span> and some max value <span
class="math inline"><em>m</em></span>. By multiplying the output of the
sine function by <span class="math inline"><em>m</em>/2</span> we get an
oscillation between <span class="math inline"> − <em>m</em>/2</span> and
<span class="math inline"><em>m</em>/2</span>, we can then add <span
class="math inline"><em>m</em>/2</span> to make it oscillate between
<span class="math inline">0</span> and <span
class="math inline"><em>m</em></span>.</p>
<p>We’ll sample the resulting function once every <code>timesStep</code>
seconds, this gives us the amount of work items (<code>n</code>) to
create we then spread those out evenly in time, rinse and repeat until
we reach some <code>endTime</code>.</p>
<pre><code>sineLoadGenerator inQueue workItem maxItems timeStep endTime =
  for t := 0; t &lt; endtime; t += timeStep
    n := sin(t) * maxItems / 2 + maxItems / 2
    for i := 0; i &lt; n; i++
      writeQueue(inQueue, workItem)
      sleep(timeStep / n)</code></pre>
</section>
<section id="pid-controller" class="level3">
<h3><a href="#pid-controller" title="PID controller">PID
controller</a></h3>
<p>The PID controller implementation follows the pseudo-code given at <a
href="https://en.wikipedia.org/wiki/PID_controller#Pseudocode">Wikipedia</a>:</p>
<pre><code>previous_error := 0
integral := 0
loop:
   error := setpoint − measured_value
   proportional := error;
   integral := integral + error × dt
   derivative := (error − previous_error) / dt
   output := Kp × proportional + Ki × integral + Kd × derivative
   previous_error := error
   wait(dt)
   goto loop</code></pre>
<p>Where <code>Kp</code>, <code>Ki</code> and <code>Kd</code> is
respectively the proportional, integral and derivative gain and
<code>dt</code> is the loop interval time. The proportional part acts on
the <em>present</em> error value, the integral acts on the <em>past</em>
and the derivative tries to predict the <em>future</em>. The measured
value is the input queue length and the setpoint, i.e. desired queue
length, is set to zero. If the <code>output</code> of the PID controller
is less than <span class="math inline"> − 100</span> (i.e. the queue
length is over <span class="math inline">100</span> taking the present,
past and possible future into account) then we scale up and if it’s more
than <span class="math inline"> − 20</span> (i.e. the queue length is
less than <span class="math inline">20</span>) then we scale down the
worker pool.</p>
</section>
</section>
<section id="how-it-works" class="level2">
<h2><a href="#how-it-works" title="How it works">How it works</a></h2>
<p>We start off by only setting the proportional part and keeping the
integral and derivative part zero, this is called a P-controller. We see
below that it will scale the worker count up and down proportionally to
the sine wave shaped load:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/elastically-scalable-thread-pools/main/img/elastically-scalable-thread-pools-1.0-0.0-0.0.svg" /></p>
<p>A P-controller only focuses on the <em>present</em>, and we see that
it allocates and deallocates workers unnecessarily. In order to smooth
things out we introduce the integral part, i.e. a PI-controller. The
integral part takes the <em>past</em> into account. We see now that the
worker count stabilises at <span class="math inline">28</span>:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/elastically-scalable-thread-pools/main/img/elastically-scalable-thread-pools-1.0-5.0e-2-0.0.svg" /></p>
<p>We can improve on this by adding the derivative part which takes the
<em>future</em> into account. We then see that it stabilises at <span
class="math inline">26</span> workers:</p>
<p><img
src="https://raw.githubusercontent.com/stevana/elastically-scalable-thread-pools/main/img/elastically-scalable-thread-pools-1.0-5.0e-2-5.0e-2.svg" /></p>
<p>With the full PID controller, which stabilises using less workers
than the PI-controller, we see that the queue length spikes up to <span
class="math inline">20</span> or so each time the work load generator
hits one of the sine function’s peaks. Recall that we started scaling
down once the queue length was less than <span
class="math inline">20</span>.</p>
</section>
<section id="usage" class="level2">
<h2><a href="#usage" title="Usage">Usage</a></h2>
<p>The above graphs were generated by running:
<code>cabal run app -- kp ki kd</code>, where the <span
class="math inline"><em>K</em><sub><em>p</em></sub></span>, <span
class="math inline"><em>K</em><sub><em>i</em></sub></span>, and <span
class="math inline"><em>K</em><sub><em>d</em></sub></span> parameters
are the tuning parameters for the PID controller.</p>
<p>If you don’t have the GHC Haskell compiler and the <code>cabal</code>
build tool already installed, then the easiest way to get it is via <a
href="https://www.haskell.org/ghcup/"><code>ghcup</code></a>.
Alternatively if you got <code>nix</code> then <code>nix-shell</code>
should give give you access to all the dependencies you need.</p>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>There are many ways we can build upon this experiment, here are a few
ideas:</p>
<ul class="task-list">
<li><input type="checkbox" />We probably want to limit the max number of
threads in a pool;</li>
<li><input type="checkbox" /><a
href="https://github.com/m-lundberg/simple-pid/blob/master/simple_pid/pid.py#L128">Clamp</a>
integral part to avoid integral windup;</li>
<li><input type="checkbox" />If two or more threads take items from some
input queue and put them on some output queue then there’s no guarantee
that the order of the output items will be the same as the input items.
We could solve this, and regain determinism, by using array based queues
and shard on the index, i.e. even indices goes to one processor and odd
to an other or more generally modulus N can be used to shard between N
processors. This is essentially what the <a
href="https://en.wikipedia.org/wiki/Disruptor_(software)">LMAX
Disruptor</a> does;</li>
<li><input type="checkbox" />We’ve only looked at one stage in a
pipeline, what happens if we have multiple stages? is it enough to
control each individual stage separately or do we need more global
control?</li>
<li><input type="checkbox" />Can we come up with other things to
control? E.g. batch sizes?</li>
<li><input type="checkbox" />We’ve only monitored the current queue
length, could we combine this with other data? E.g. time series of the
queue length from the previous day?</li>
<li><input type="checkbox" />Is it robust to wildly changing usage
patterns? E.g. bursty traffic or the <a
href="https://en.wikipedia.org/wiki/Slashdot_effect">Slashdot
effect</a>?</li>
<li><input type="checkbox" />We’ve looked at scaling up and down on a
single machine (vertical scaling), what about scaling out and in across
multiple machines (horizontal scaling)?</li>
<li><input type="checkbox" />We generated and processed real work items
(by sleeping), could we do a discrete-event simulation instead to avoid
having to wait for the sleeps?</li>
<li><input type="checkbox" />I just picked random values for the PID
controller parameters, there are more principled <a
href="https://en.wikipedia.org/wiki/PID_controller#Overview_of_tuning_methods">ways</a>
of tuning the PID controller;</li>
<li><input type="checkbox" />The PID controller we implemented merely
followed the pseudo-code from Wikipedia, there’s probably better ways of
implementing it?</li>
</ul>
<p>If any of this sounds interesting, feel free to get in touch!</p>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li><p><a
href="https://www.researchgate.net/publication/265611546_A_Review_of_Auto-scaling_Techniques_for_Elastic_Applications_in_Cloud_Environments"><em>A
Review of Auto-scaling Techniques for Elastic Applications in Cloud
Environments</em></a></p>
<ol start="2014" type="1">
<li>is a survey paper which talks about both threshold and PID
controllers;</li>
</ol></li>
<li><p><a
href="https://people.eecs.berkeley.edu/~brewer/papers/SEDA-sosp.pdf"><em>SEDA:
An Architecture for Well-Conditioned Scalable Internet Services</em></a>
(2001), this is paper that I got the idea for elastic scalable thread
pools. They use a threshold approach rather than a PID controller,
saying:</p>
<blockquote>
<p>The controller periodically samples the input queue (once per second
by default) and adds a thread when the queue length exceeds some
threshold (100 events by default). Threads are removed from a stage when
they are idle for a specified period of time (5 seconds by default).</p>
</blockquote>
<p>But also:</p>
<blockquote>
<p>Under SEDA, the body of work on control systems can be brought to
bear on service resource management, and we have only scratched the
surface of the potential for this technique.</p>
</blockquote>
<p>A bit more explanation is provided by Matt Welsh, who is one of the
author, in his PhD <a
href="https://cs.uwaterloo.ca/~brecht/servers/readings-new/mdw-phdthesis.pdf">thesis</a>
(2002):</p>
<blockquote>
<p>A benefit to ad hoc controller design is that it does not rely on
complex models and parameters that a system designer may be unable to
understand or to tune. A common complaint of classic PID controller
design is that it is often difficult to understand the effect of gain
settings.</p>
</blockquote></li>
<li><p>There are many introductory text books on control theory, but
there’s a lot less resources on how to apply control theory to software
systems. Here are a few resources:</p>
<ul>
<li><p><a
href="https://janert.org/books/feedback-control-for-computer-systems/"><em>Feedback
Control for Computer Systems</em></a> book by Philipp K. Janert
(2013);</p></li>
<li><p><a
href="https://www.cse.wustl.edu/~lu/control-tutorials/im09/"><em>Tutorial:
Recent Advances in the Application of Control Theory to Network and
Service Management</em></a>.</p></li>
</ul></li>
<li><p>It could very well be that the way we’ve applied classic PID
controllers isn’t suitable for unpredictable internet traffic loads.
There are branches of control theory might be better suited for this,
see, for example, <a
href="https://en.wikipedia.org/wiki/Robust_control">robust</a> and <a
href="https://en.wikipedia.org/wiki/Adaptive_control">adaptive</a>
control theory;</p></li>
<li><p>The .NET thread pool apparently uses the <a
href="https://en.wikipedia.org/wiki/Hill_climbing">hill climbing</a>
optimisation technique to <a
href="https://mattwarren.org/2017/04/13/The-CLR-Thread-Pool-Thread-Injection-Algorithm/">elastically
scale</a>;</p></li>
<li><p>My previous post: <a
href="https://github.com/stevana/pipelined-state-machines#pipelined-state-machines"><em>An
experiment in declaratively programming parallel pipelines of state
machines</em></a>.</p></li>
</ul>
</section>
<section id="discussion" class="level2">
<h2><a href="#discussion" title="Discussion">Discussion</a></h2>
<ul>
<li><a href="https://news.ycombinator.com/item?id=35148068">Hacker
News</a>;</li>
<li><a
href="https://lobste.rs/s/ybtxic/experiment_elastically_scaling_thread">lobste.rs</a>;</li>
<li><a
href="https://old.reddit.com/r/haskell/comments/11qyfw7/an_experiment_in_elastically_scaling_a_thread/">r/haskell</a>;</li>
<li>Also see Glyn Normington’s <a
href="https://github.com/stevana/elastically-scalable-thread-pools/issues/1">comment</a>
in the issue tracker.</li>
</ul>
</section>
]]></description>
      <category>Deployment</category>
    </item>

    <item>
      <title>Pipelined state machines</title>
      <link>https://stevana.github.io/pipelined_state_machines.html</link>
      <guid>https://stevana.github.io/pipelined_state_machines.html</guid>
      <pubDate>Wed, 1 Mar 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>pipelined-state-machines</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#disruptor" id="toc-disruptor">Disruptor</a>
<ul>
<li><a href="#example" id="toc-example">Example</a></li>
<li><a href="#how-it-works" id="toc-how-it-works">How it works</a></li>
<li><a href="#performance" id="toc-performance">Performance</a></li>
</ul></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a>
<ul>
<li><a href="#presentations"
id="toc-presentations">Presentations</a></li>
<li><a href="#writings" id="toc-writings">Writings</a></li>
</ul></li>
</ul>
</nav>
<div class="date">Posted on Mar  1, 2023</div>
<p>An experiment in declaratively programming parallel pipelines of
state machines.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>Imagine a flat complex in Sweden. Being the socialist utopia Sweden
is there’s a shared laundry room which the people in the flat complex
can book. In the laundry room there’s everything one needs to wash, dry
and iron your clothes. You don’t even need to bring your own laundry
detergent!</p>
<p>Lets call three people living there Ann, Bo and Cecilia, and lets
assume they all want to use the laundry room. Depending on how the
booking system is implemented the total time it would take for all three
people to do their laundry varies.</p>
<p>For example if the booking system allocates a big time slot per
person in which that person can do the whole cycle of <em>W</em>ashing,
<em>D</em>rying and <em>I</em>roning then, assuming each step takes one
time unit, we get a situation like this:</p>
<pre><code>      Person
        ^
    Ann | W D I                             W = Washing
     Bo |       W D I                       D = Drying
Cecilia |             W D I                 I = Ironing
        +-------------------&gt; Time
        0 1 2 3 4 5 6 7 8 9</code></pre>
<p>Bo cannot start washing until Ann is done ironing, because Ann has
booked the room for the whole cycle, and so on.</p>
<p>If the booking system is more granular and allows booking a time slot
per step then we can get a situation that looks like this:</p>
<pre><code>      Person
        ^
    Ann | W D I
     Bo |   W D I
Cecilia |     W D I
        +-------------------&gt; Time
        0 1 2 3 4 5 6 7 8 9</code></pre>
<p>It should be clear that the total time is shorter in this case,
because the machines are utilised better (Bo can start using the washing
machine right after Ann is done with it). Also note that if each person
would start a new washing after they finish ironing the first one and so
on then the time savings would be even greater.</p>
<p>This optimisation is called pipelining. It’s used a lot in
manufacturing, for example Airbus <a
href="https://youtu.be/oxjT7veKi9c?t=2682">builds</a> two airplanes per
day. If you were to order a plane today you’d get it delivered in two
months time. How is that they deliver two per day if it takes two months
to build them? Pipelining! It’s also used inside CPUs to <a
href="https://en.wikipedia.org/wiki/Instruction_pipelining">pipeline
instructions</a>.</p>
<p>The rest of this document is an experiment in how we can construct
such pipelining in software in a declarative way.</p>
</section>
<section id="usage" class="level2">
<h2><a href="#usage" title="Usage">Usage</a></h2>
<p>The workers or stages in our pipeline will be state machines of the
following type.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SM</span> s a b <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Id</span><span class="ot">      ::</span> <span class="dt">SM</span> s a a</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Compose</span><span class="ot"> ::</span> <span class="dt">SM</span> s b c <span class="ot">-&gt;</span> <span class="dt">SM</span> s a b <span class="ot">-&gt;</span> <span class="dt">SM</span> s a c</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Fst</span><span class="ot">     ::</span> <span class="dt">SM</span> s (a, b) a</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Snd</span><span class="ot">     ::</span> <span class="dt">SM</span> s (a, b) b</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&amp;&amp;&amp;)  ::</span> <span class="dt">SM</span> s a c <span class="ot">-&gt;</span> <span class="dt">SM</span> s a d <span class="ot">-&gt;</span> <span class="dt">SM</span> s a (c, d)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:***)  ::</span> <span class="dt">SM</span> s a c <span class="ot">-&gt;</span> <span class="dt">SM</span> s b d <span class="ot">-&gt;</span> <span class="dt">SM</span> s (a, b) (c, d)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SlowIO</span><span class="ot">  ::</span> <span class="dt">SM</span> s a a <span class="co">-- Simulate a slow I/O computation.</span></span></code></pre></div>
<p>Here’s an example of a stage which takes an ordered pair as input and
swaps the elements of the pair. Note the use of <code>SlowIO</code> to
simulate that some slow I/O computation happens.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swap ::</span> <span class="dt">SM</span> () (a, b) (b, a)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>swap <span class="ot">=</span> <span class="dt">Snd</span> <span class="op">:***</span> <span class="dt">Fst</span> <span class="ot">`Compose`</span> copy <span class="ot">`Compose`</span> <span class="dt">SlowIO</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    copy <span class="ot">=</span> <span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Id</span></span></code></pre></div>
<p>We can <code>interpret</code> such state machines into plain
functions as follows.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interpret ::</span> <span class="dt">SM</span> s a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> (s, b))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>interpret <span class="dt">Id</span>            x s <span class="ot">=</span> <span class="fu">return</span> (s, x)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>interpret (<span class="dt">Compose</span> g f) x s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  (s&#39;, y) <span class="ot">&lt;-</span> interpret f x s</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  interpret g y s&#39;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>interpret <span class="dt">Fst</span>           x s <span class="ot">=</span> <span class="fu">return</span> (s, <span class="fu">fst</span> x)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>interpret <span class="dt">Snd</span>           x s <span class="ot">=</span> <span class="fu">return</span> (s, <span class="fu">snd</span> x)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>interpret (f <span class="op">:&amp;&amp;&amp;</span> g)    x s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  (s&#39;, y)  <span class="ot">&lt;-</span> interpret f x s</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  (s&#39;&#39;, z) <span class="ot">&lt;-</span> interpret g x s&#39;</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (s&#39;&#39;, (y, z))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>interpret (f <span class="op">:***</span> g)    x s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  (s&#39;, y)  <span class="ot">&lt;-</span> interpret f (<span class="fu">fst</span> x) s</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  (s&#39;&#39;, z) <span class="ot">&lt;-</span> interpret g (<span class="fu">snd</span> x) s&#39;</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (s&#39;&#39;, (y, z))</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>interpret <span class="dt">SlowIO</span> x s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  threadDelay <span class="dv">200000</span> <span class="co">-- 0.2s</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (s, x)</span></code></pre></div>
<p>Next lets have a look at how we can construct pipelines of such state
machines.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">P</span> a b <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SM</span><span class="ot">     ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SM</span> s a b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">P</span> a b</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&gt;&gt;&gt;) ::</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">P</span> b c <span class="ot">-&gt;</span> <span class="dt">P</span> a c</span></code></pre></div>
<p>The following is an example pipeline where there’s only one stage in
which we do our pair swapping three times.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swapsSequential ::</span> <span class="dt">P</span> (a, b) (b, a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>swapsSequential <span class="ot">=</span> <span class="dt">SM</span> <span class="st">&quot;three swaps&quot;</span> (swap <span class="ot">`Compose`</span> swap <span class="ot">`Compose`</span> swap) ()</span></code></pre></div>
<p>The above corresponds to our coarse grained booking system where the
laundry was booked for the whole cycle. Whereas the following
corresponds to the more fine grained approach where we get
pipelining.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swapsPipelined ::</span> <span class="dt">P</span> (a, b) (b, a)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>swapsPipelined <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SM</span> <span class="st">&quot;first swap&quot;</span>  swap () <span class="op">:&gt;&gt;&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SM</span> <span class="st">&quot;second swap&quot;</span> swap () <span class="op">:&gt;&gt;&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SM</span> <span class="st">&quot;third swap&quot;</span>  swap ()</span></code></pre></div>
<p>A pipeline can be deployed, we’ll use the following type to keep
track of the queue associated with the pipeline as well as the name and
pids of the state machines involved in the pipeline.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Deployment</span> a <span class="ot">=</span> <span class="dt">Deployment</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> queue ::</span> <span class="dt">TQueue</span> a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> pids  ::</span> [(<span class="dt">String</span>, <span class="dt">Async</span> ())]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">names ::</span> <span class="dt">Deployment</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>names <span class="ot">=</span> bracket <span class="op">.</span> intercalate <span class="st">&quot;,&quot;</span> <span class="op">.</span> <span class="fu">reverse</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">fst</span> <span class="op">.</span> pids</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    bracket s <span class="ot">=</span> <span class="st">&quot;[&quot;</span> <span class="op">++</span> s <span class="op">++</span> <span class="st">&quot;]&quot;</span></span></code></pre></div>
<p>Here’s the actual <code>deploy</code>ment function which takes a
pipeline and gives back an input-queue and a <code>Deployment</code>
which holds the output-queue and the names and pids of the state
machines.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">TQueue</span> a, <span class="dt">Deployment</span> b)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>deploy p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  q <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  d <span class="ot">&lt;-</span> deploy&#39; p (<span class="dt">Deployment</span> q [])</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (q, d)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy&#39; ::</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">Deployment</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Deployment</span> b)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>deploy&#39; (<span class="dt">SM</span> name sm s0) d <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  q&#39; <span class="ot">&lt;-</span> newTQueueIO</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  pid <span class="ot">&lt;-</span> async (go s0 q&#39;)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dt">Deployment</span> { queue <span class="ot">=</span> q&#39;, pids <span class="ot">=</span> (name, pid) <span class="op">:</span> pids d }</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    f <span class="ot">=</span> interpret sm</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    go s q&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      x <span class="ot">&lt;-</span> atomically <span class="op">$</span> readTQueue (queue d)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      (s&#39;, o) <span class="ot">&lt;-</span> f x s</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>      atomically <span class="op">$</span> writeTQueue q&#39; o</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>      go s&#39; q&#39;</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>deploy&#39; (sm <span class="op">:&gt;&gt;&gt;</span> sm&#39;) d <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  d&#39; <span class="ot">&lt;-</span> deploy&#39; sm d</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  deploy&#39; sm&#39; d&#39;</span></code></pre></div>
<p>We now have everything we need to run a simple benchmark comparing
the sequential version of three swaps versus the pipelined version.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PipelineKind</span> <span class="ot">=</span> <span class="dt">Sequential</span> <span class="op">|</span> <span class="dt">Pipelined</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> libMain [<span class="dt">Sequential</span>, <span class="dt">Pipelined</span>]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="ot">libMain ::</span> <span class="dt">PipelineKind</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>libMain k <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  (q, d) <span class="ot">&lt;-</span> deploy <span class="op">$</span> <span class="kw">case</span> k <span class="kw">of</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Sequential</span> <span class="ot">-&gt;</span> swapsSequential</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">Pipelined</span>  <span class="ot">-&gt;</span> swapsPipelined</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> k</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Pids: &quot;</span> <span class="op">++</span> names d</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  start <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  forM_ [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">5</span>), (<span class="dv">5</span>, <span class="dv">6</span>), (<span class="dv">6</span>, <span class="dv">7</span>)] <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    atomically <span class="op">$</span> writeTQueue q x</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  resps <span class="ot">&lt;-</span> replicateM <span class="dv">6</span> <span class="op">$</span> atomically <span class="op">$</span> readTQueue (queue d)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  end <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Responses: &quot;</span> <span class="op">++</span> <span class="fu">show</span> resps</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Time: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (diffUTCTime end start)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></span></code></pre></div>
<p>We can run the above with
<code>cabal run readme-pipeline-example</code>, which results in
something like the following being printed to the screen.</p>
<pre><code>Sequential
Pids: [three swaps]
Responses: [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6)]
Time: 3.611045787s

Pipelined
Pids: [first swap,second swap,third swap]
Responses: [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6)]
Time: 1.604990775s</code></pre>
<p>Cool, we managed to reduce the total running time by more than half!
We can do even better though! In addition to pipelining we can also
shard the queues by letting two state machines work on the same queue,
the first processing the elements in the even positions of the queue and
the second processing the elements in the odd positions.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>data P a b where</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  SM     :: String -&gt; SM s a b -&gt; s -&gt; P a b</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  (:&gt;&gt;&gt;) :: P a b -&gt; P b c -&gt; P a c</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="va">+ Shard  :: P a b -&gt; P a b</span></span></code></pre></div>
<p>Here’s an example of a sharded pipeline, where each shard will spawn
two state machines (one working on the even indexes of the queue and the
other on the odd).</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swapsSharded ::</span> <span class="dt">P</span> (a, b) (b, a)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>swapsSharded <span class="ot">=</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Shard</span> (<span class="dt">SM</span> <span class="st">&quot;first swap&quot;</span>  swap ()) <span class="op">:&gt;&gt;&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Shard</span> (<span class="dt">SM</span> <span class="st">&quot;second swap&quot;</span> swap ()) <span class="op">:&gt;&gt;&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Shard</span> (<span class="dt">SM</span> <span class="st">&quot;third swap&quot;</span>  swap ())</span></code></pre></div>
<p>In the deployment of shards, we achieve the even-odd split by reading
from the input queue, <code>qIn</code>, and first writing to the even
queue, <code>qEven</code>, and then switching over to the odd queue,
<code>qOdd</code>, when making the recursive call in
<code>shardQIn</code>. Whereas <code>shardQOut</code> does the inverse
and merges the two queues back into the output queue:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="va">+ deploy&#39; (Shard p) d = do</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="va">+   let qIn = queue d</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="va">+   qEven  &lt;- newTQueueIO</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="va">+   qOdd   &lt;- newTQueueIO</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="va">+   pidIn  &lt;- async $ shardQIn qIn qEven qOdd</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="va">+   dEven  &lt;- deploy&#39; p (Deployment qEven [])</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="va">+   dOdd   &lt;- deploy&#39; p (Deployment qOdd [])</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="va">+   qOut   &lt;- newTQueueIO</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="va">+   pidOut &lt;- async $ shardQOut (queue dEven) (queue dOdd) qOut</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="va">+   return (Deployment qOut ((&quot;shardIn:  &quot; ++ names dEven ++ &quot; &amp; &quot; ++ names dOdd, pidIn) :</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="va">+                            (&quot;shardOut: &quot; ++ names dEven ++ &quot; &amp; &quot; ++ names dOdd, pidOut) :</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="va">+                            pids dEven ++ pids dOdd ++ pids d))</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="va">+   where</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="va">+     shardQIn :: TQueue a -&gt; TQueue a -&gt; TQueue a -&gt; IO ()</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="va">+     shardQIn  qIn qEven qOdd = do</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="va">+       atomically (readTQueue qIn &gt;&gt;= writeTQueue qEven)</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="va">+       shardQIn qIn qOdd qEven</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="va">+</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="va">+     shardQOut :: TQueue a -&gt; TQueue a -&gt; TQueue a -&gt; IO ()</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="va">+     shardQOut qEven qOdd qOut = do</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="va">+       atomically (readTQueue qEven &gt;&gt;= writeTQueue qOut)</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a><span class="va">+       shardQOut qOdd qEven qOut</span></span></code></pre></div>
<p>Running this version we see more than 3.5x speed-up compared to the
sequential pipeline.</p>
<pre><code>Sharded
Pids: [first swap,first swap,shardOut: [first swap] &amp; [first swap],shardIn:  [first swap] &amp; [first swap],second swap,second swap,shardOut: [second swap] &amp; [second swap],shardIn:  [second swap] &amp; [second swap],third swap,third swap,shardOut: [third swap] &amp; [third swap],shardIn:  [third swap] &amp; [third swap]]
Responses: [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6)]
Time: 1.00241912s</code></pre>
<p>There are still many more improvements to be made here:</p>
<ul>
<li>Avoid spawning threads for merely shuffling elements between queues,
e.g. <code>shardQ{In, Out}</code> above;</li>
<li>Avoid copying elements between queues;</li>
<li>Back-pressure;</li>
<li>Batching.</li>
</ul>
<p>I believe all these problems can be solved by choosing a better
concurrent queue data structure than <code>TQueue</code>, so that’s what
we’ll have a look at next.</p>
</section>
<section id="disruptor" class="level2">
<h2><a href="#disruptor" title="Disruptor">Disruptor</a></h2>
<p>The <code>Disruptor*</code> modules are a Haskell port of the <a
href="https://github.com/LMAX-Exchange/disruptor">LMAX Disruptor</a>,
which is a high performance inter-thread messaging library. The
developers at LMAX, which operates a financial exchange, <a
href="https://www.infoq.com/presentations/LMAX/">reported</a> in 2010
that they could process more than 100,000 transactions per second at
less than 1 millisecond latency.</p>
<p>At its core it’s just a lock-free concurrent queue, but it also
provides building blocks for achieving several useful concurrent
programming tasks that typical queues don’t (or at least don’t make
obvious how to do). The extra features include:</p>
<ul>
<li>Multi-cast (many consumers can in parallel process the same
event);</li>
<li>Batching (both on producer and consumer side);</li>
<li>Back-pressure;</li>
<li>Sharding for scalability;</li>
<li>Dependencies between consumers.</li>
</ul>
<p>It’s also performs better than most queues, as we shall see further
down.</p>
<section id="example" class="level3">
<h3><a href="#example" title="Example">Example</a></h3>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.Async</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Disruptor.SP</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Create the shared ring buffer.</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bufferCapacity <span class="ot">=</span> <span class="dv">128</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  rb <span class="ot">&lt;-</span> newRingBuffer bufferCapacity</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The producer keeps a counter and produces events that are merely the pretty</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- printed value as a string of that counter.</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> produce ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>      produce n <span class="ot">=</span> <span class="fu">return</span> (<span class="fu">show</span> n, n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- The counter starts at zero.</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>      initialProducerState <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- No back-pressure is applied in this example.</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span class="ot">      backPressure ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>      backPressure _ <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>  producer <span class="ot">&lt;-</span> newEventProducer rb produce backPressure initialProducerState</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- The consumer merely prints the string event to the terminal.</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> consume ::</span> () <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SequenceNumber</span> <span class="ot">-&gt;</span> <span class="dt">EndOfBatch</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>      consume () event snr endOfBatch <span class="ot">=</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>        <span class="fu">putStrLn</span> (event <span class="op">++</span> <span class="kw">if</span> endOfBatch <span class="kw">then</span> <span class="st">&quot; (end of batch)&quot;</span> <span class="kw">else</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- The consumer doesn&#39;t need any state in this example.</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>      initialConsumerState <span class="ot">=</span> ()</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Which other consumers do we need to wait for before consuming an event?</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>      dependencies <span class="ot">=</span> []</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- What to do in case there are no events to consume?</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>      waitStrategy <span class="ot">=</span> <span class="dt">Sleep</span> <span class="dv">1</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>  consumer <span class="ot">&lt;-</span> newEventConsumer rb consume initialConsumerState dependencies waitStrategy</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Tell the ring buffer which the last consumer is, to avoid overwriting</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- events that haven&#39;t been consumed yet.</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>  setGatingSequences rb [ecSequenceNumber consumer]</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>  withEventProducer producer <span class="op">$</span> \ap <span class="ot">-&gt;</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>    withEventConsumer consumer <span class="op">$</span> \ac <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>      threadDelay (<span class="dv">3</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>) <span class="co">-- 3 sec</span></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>      cancel ap</span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>      cancel ac</span></code></pre></div>
<p>You can run the above example with
<code>cabal run readme-disruptor-example</code>.</p>
<p>A couple of things we could change to highlight the features we
mentioned in the above section:</p>
<ol type="1">
<li><p>Add a second consumer that saves the event to disk, this consumer
would be slower than the current one which logs to the terminal, but we
could use buffer up events in memory and only actually write when the
end of batch flag is set to speed things up;</p></li>
<li><p>We could also shard depending on the sequence number, e.g. have
two slower consumers that write to disk and have one of them handle even
sequence numbers while the other handles odd ones;</p></li>
<li><p>The above producer writes one event at the time to the ring
buffer, but since we know at which sequence number the last consumer is
at we can easily make writes in batches as well;</p></li>
<li><p>Currently the producer doesn’t apply any back-pressure when the
ring buffer is full, in a more realistic example where the producer
would, for example, create events from requests made to a http server we
could use back-pressure to tell the http server to return status code
429 (too many requests);</p></li>
<li><p>If we have one consumer that writes to the terminal and another
one that concurrently writes to disk, we could add a third consumer that
does something with the event only if it has both been logged and stored
to disk (i.e. the third consumer depends on both the first and the
second).</p></li>
</ol>
</section>
<section id="how-it-works" class="level3">
<h3><a href="#how-it-works" title="How it works">How it works</a></h3>
<p>The ring buffer is implemented using a bounded array, it keeps track
of a monotonically increasing sequence number and it knows its the
capacity of the array, so to find out where to write the next value by
simply taking the modulus of the sequence number and the capacity. This
has several advantages over traditional queues:</p>
<ol type="1">
<li><p>We never remove elements when dequeing, merely overwrite them
once we gone all way around the ring. This removes write <a
href="https://en.wikipedia.org/wiki/Resource_contention">contention</a>
between the producer and the consumer, one could also imagine avoiding
garbage collection by only allocating memory the first time around the
ring (but we don’t do this in Haskell);</p></li>
<li><p>Using an array rather than linked list increasing <a
href="https://en.wikipedia.org/wiki/Stride_of_an_array">striding</a> due
to <a
href="https://en.wikipedia.org/wiki/Locality_of_reference#Spatial_and_temporal_locality_usage">spatial
locality</a>.</p></li>
</ol>
<p>The ring buffer also keeps track of up to which sequence number its
last consumer has consumed, in order to not overwrite events that
haven’t been handled yet.</p>
<p>This also means that producers can ask how much capacity left a ring
buffer has, and do batched writes. If there’s no capacity left the
producer can apply back-pressure upstream as appropriate.</p>
<p>Consumers need keep track of which sequence number they have
processed, in order to avoid having the ring buffer overwrite
unprocessed events as already mentioned, but this also allows consumers
to depend on each other.</p>
<p>When a consumer is done processing an event, it asks the ring buffer
for the event at its next sequence number, the ring buffer then replies
that either there are no new events, in which case the consumer applies
it wait strategy, or the ring buffer can reply that there are new
events, the consumer the handles each one in turn and the last one will
be have the end of batch flag set, so that the consumer can effectively
batch the processing.</p>
</section>
<section id="performance" class="level3">
<h3><a href="#performance" title="Performance">Performance</a></h3>
<p>Our Disruptor implementation, which hasn’t been optimised much yet,
is about 2x slower than LMAX’s Java version on their single-producer
single-consumer <a
href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedThroughputTest.java">benchmark</a>
(1P1C) (basically the above example) on a couple of years old Linux
laptop.</p>
<p>The same benchmark compared to other Haskell libraries:</p>
<ul>
<li><p>10.3x faster than <a
href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Concurrent-Chan.html"><code>Control.Concurrent.Chan</code></a>;</p></li>
<li><p>8.3x faster than <a
href="https://hackage.haskell.org/package/stm/docs/Control-Concurrent-STM-TBQueue.html"><code>Control.Concurrent.STM.TBQueue</code></a>;</p></li>
<li><p>1.7x faster than <a
href="https://hackage.haskell.org/package/unagi-chan"><code>unagi-chan</code></a>;</p></li>
<li><p>25.5x faster than <a
href="https://hackage.haskell.org/package/chaselev-deque"><code>chaselev-deque</code></a>;</p></li>
<li><p>700x faster than <a
href="https://hackage.haskell.org/package/ring-buffer"><code>ring-buffer</code></a>;</p></li>
<li><p>1.3x slower than <a
href="https://hackage.haskell.org/package/lockfree-queue"><code>lockfree-queue</code></a>;</p></li>
<li><p>TODO: Compare with <a
href="https://github.com/kim/data-ringbuffer/tree/master/src/Data/RingBuffer"><code>data-ringbuffer</code></a>.</p></li>
</ul>
<p>In the triple-producer single-consumer (3P1C) <a
href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedThroughputTest.java">benchmark</a>,
the Java version is 5x slower than the Java 1P1C case. And our 3P1C is
4.6x slower than our 1P1C version and our 3P1C version is 2.7x slower
than the Java version.</p>
<p>The same benchmark compared to other Haskell libraries:</p>
<ul>
<li><p>73x faster than <a
href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Concurrent-Chan.html"><code>Control.Concurrent.Chan</code></a>;</p></li>
<li><p>3.5x faster than <a
href="https://hackage.haskell.org/package/stm/docs/Control-Concurrent-STM-TBQueue.html"><code>Control.Concurrent.STM.TBQueue</code></a>;</p></li>
<li><p>1.3x faster than <a
href="https://hackage.haskell.org/package/unagi-chan"><code>unagi-chan</code></a>;</p></li>
<li><p>1.9x faster than <a
href="https://hackage.haskell.org/package/lockfree-queue"><code>lockfree-queue</code></a>.</p></li>
</ul>
<p>For a slightly more “real world” example, we modified the 3P1C test
to have three producers that log messages while the consumer writes them
to a log file and compared it to <a
href="https://hackage.haskell.org/package/fast-logger"><code>fast-logger</code></a>.
The <code>pipelined-state-machines</code> benchmark has a throughput of
3:4 that of <code>fast-logger</code>. When we bump it to ten
concurrently logging threads the <code>pipelined-state-machines</code>
benchmark has a throughput of 10:7 that of <code>fast-logger</code>.</p>
<p>See the file <a href="benchmark.sh"><code>benchmark.sh</code></a> for
full details about how the benchmarks are run.</p>
<p>As always take benchmarks with a grain of salt, we’ve tried to make
them as fair with respect to each other and as true to the original Java
versions as possible. If you see anything that seems unfair, or if you
get very different results when trying to reproduce the numbers, then
please file an issue.</p>
</section>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>There’s a lot of possible paths to explore from here, including:</p>
<ul class="task-list">
<li><input type="checkbox" />Can we swap out our use of
<code>TQueue</code> for <code>Disruptor</code> in our
<code>deploy</code> of <code>P</code>ipelines?</li>
<li><input type="checkbox" />Can we add something like a
<code>FanOut :: P a b -&gt; P a c -&gt; P a (b, c)</code> and a
<code>Par :: P a c -&gt; P b d -&gt; P (a, b) (c, d)</code> combinator
to allow two parallel queues?</li>
<li><input type="checkbox" />What about sum-types and error
handling?</li>
<li><input type="checkbox" />Our current, and the above just mentioned,
pipeline combinators are all binary to can we generalise this to
N-ary?</li>
<li><input type="checkbox" />Can we visualise pipelines using
<code>dot</code> or similar?</li>
<li><input type="checkbox" />Can we build a performance/cost simulator
of pipelines?</li>
<li><input type="checkbox" />Arrow syntax or monadic DSL for
pipelines?</li>
<li><input type="checkbox" />We’ve seen <a
href="https://github.com/stevana/hot-swapping-state-machines">previously</a>
how we can hot-code upgrade state machines, what about hot-code
upgrading pipelines?</li>
<li><input type="checkbox" />Can we implement the Erlang
<code>gen_event</code> behaviour using Disruptor?</li>
<li><input type="checkbox" />Would it make sense to use the spiritual
successor of the Disruptor instead, i.e. the different array queues from
<code>aeron</code> and <code>agrona</code>:
<ul>
<li><a
href="https://github.com/real-logic/agrona/blob/master/agrona/src/main/java/org/agrona/concurrent/OneToOneConcurrentArrayQueue.java">Single-producer
single-consumer</a>;</li>
<li><a
href="https://github.com/real-logic/agrona/blob/master/agrona/src/main/java/org/agrona/concurrent/ManyToOneConcurrentArrayQueue.java">Multiple-producers
single-consumer</a>;</li>
<li><a
href="https://github.com/real-logic/agrona/blob/master/agrona/src/main/java/org/agrona/concurrent/ManyToManyConcurrentArrayQueue.java">Multiple-producers
multiple-consumers</a>.</li>
</ul></li>
<li><input type="checkbox" />How exactly do these pipelines relate to
the libraries <a
href="https://hackage.haskell.org/package/pipes"><code>pipes</code></a>,
<a
href="https://hackage.haskell.org/package/conduit"><code>conduit</code></a>
and <a
href="https://hackage.haskell.org/package/streamly"><code>streamly</code></a>?</li>
<li><input type="checkbox" />How does it relate to synchronous
programming languages such as <a
href="https://en.wikipedia.org/wiki/Esterel">Esterel</a>, <a
href="https://en.wikipedia.org/wiki/Lustre_(programming_language)">Lustre</a>,
<a href="https://rml.lri.fr">ReactiveML</a>, etc? It seems to me that
their main motivation is to be concurrent or parallel while still
determinstic, which is what we’d like as well. Looking at ReactiveML’s
documentation for <a
href="https://rml.lri.fr/documentation.html#compositions">compositions</a>
we see the same constructs as we’ve discussed: their <code>;</code> is
our <code>Compose</code> (with its arguments flipped), their
<code>||</code> is our <code>FanOut</code>, their <code>|&gt;</code> is
our <code>:&gt;&gt;&gt;</code> and their <code>let-and</code> construct
could be achived by adding projection functions to our
<code>P</code>ipelines similar to <code>Fst</code> and <code>Snd</code>
for <code>SM</code>. Interestingly they don’t have any sum-types-like
construct here, i.e. something like
<code>(:|||) :: P a c -&gt; P b c -&gt; P (Either a b) c</code>;</li>
<li><input type="checkbox" />I like to think of how one constructs a
pipeline, i.e. the choice of which tasks should happen in parallel or
should be sharded etc, as a choice of how to best make use of the
CPUs/cores of a single computer. If seen this way then that begs the
question: what about a network of multiple computers? Perhaps there
should be something like a <code>Topology</code> data type which
describes how multiple pipelines interact and a topology is deployed by
deploying multiple pipelines over multiple machines?</li>
</ul>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<section id="presentations" class="level3">
<h3><a href="#presentations"
title="Presentations">Presentations</a></h3>
<ul>
<li><p><a href="https://www.infoq.com/presentations/LMAX/">LMAX - How to
Do 100K TPS at Less than 1ms Latency</a> by Martin Thompson (QCon
2010);</p></li>
<li><p><a href="https://youtube.com/watch?v=Qho1QNbXBso">LMAX Disruptor
and the Concepts of Mechanical Sympathy</a> by Jamie Allen
(2011);</p></li>
<li><p><a
href="https://www.infoq.com/presentations/Concurrent-Programming-Using-The-Disruptor/">Concurrent
Programming with the Disruptor</a> by Trisha Gee (2012);</p></li>
<li><p><a href="https://youtube.com/watch?v=2Be_Lqa35Y0">Disruptor 3.0:
Details and Advanced Patterns</a> by Mike Barker (YOW! 2013);</p></li>
<li><p><a href="https://youtube.com/watch?v=fDGWWpHlzvw">Designing for
Performance</a> by Martin Thompson (GOTO 2015);</p></li>
<li><p><a href="https://vimeo.com/181814364">A quest for predictable
latency with Java concurrency</a> Martin Thompson (JavaZone
2016);</p></li>
<li><p><a href="https://www.youtube.com/watch?v=qDhTjE0XmkE">Evolution
of Financial Exchange Architectures</a> by Martin Thompson (QCon
2020)</p>
<ul>
<li>1,000,000 tx/s and less than 100 microseconds latency, he is no
longer at LMAX though so we don’t know if these exchanges are using the
disruptor pattern.</li>
</ul></li>
<li><p><a href="https://youtube.com/watch?v=tM4YskS94b0"><em>Aeron:
Open-source high-performance messaging</em></a> talk by Martin Thompson
(Strange Loop, 2014);</p></li>
<li><p><em>Aeron: What, Why and What Next?</em> <a
href="https://youtube.com/watch?v=p1bsloPeBzE">talk</a> by Todd
Montgomery (GOTO, 2015);</p></li>
<li><p><em>Cluster Consensus: when Aeron met Raft</em> <a
href="https://youtube.com/watch?v=GFfLCGW_5-w">talk</a> by Martin
Thompson (GOTO, 2018);</p></li>
<li><p><em>Fault Tolerant 24/7 Operations with Aeron Cluster</em> <a
href="https://youtube.com/watch?v=H9yqzfNiEb4">talk</a> by Todd
Montgomery (2022).</p></li>
</ul>
</section>
<section id="writings" class="level3">
<h3><a href="#writings" title="Writings">Writings</a></h3>
<ul>
<li>Martin Thompson’s <a
href="https://mechanical-sympathy.blogspot.com/">blog</a>;</li>
<li>The Disruptor <a
href="https://groups.google.com/g/lmax-disruptor">mailing list</a>;</li>
<li>The Mechanical Sympathy <a
href="https://groups.google.com/g/mechanical-sympathy">mailing
list</a>;</li>
<li><a href="https://martinfowler.com/articles/lmax.html">The LMAX
Architecture</a> by Martin Fowler (2011);</li>
<li><a
href="https://en.wikipedia.org/wiki/Staged_event-driven_architecture">Staged
event-driven architecture</a>;</li>
<li><a href="https://www.reactivemanifesto.org/">The Reactive
Manifesto</a>;</li>
<li><a
href="https://en.wikipedia.org/wiki/Flow-based_programming">Flow-based
programming</a>.</li>
</ul>
</section>
</section>
]]></description>
      <category>Development</category>
    </item>

    <item>
      <title>Hot-code swapping à la Erlang with Arrow-based state machines</title>
      <link>https://stevana.github.io/hot-code_swapping_a_la_erlang_with_arrow-based_state_machines.html</link>
      <guid>https://stevana.github.io/hot-code_swapping_a_la_erlang_with_arrow-based_state_machines.html</guid>
      <pubDate>Tue, 21 Feb 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>hot-swapping-state-machines</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#background" id="toc-background">Background</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#how-it-works" id="toc-how-it-works">How it works</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
<li><a href="#acknowledgments"
id="toc-acknowledgments">Acknowledgments</a></li>
</ul>
</nav>
<div class="date">Posted on Feb 21, 2023</div>
<p>An experiment in implementing remote hot code swapping, or dynamic
code upgrade, for state machines.</p>
<section id="background" class="level2">
<h2><a href="#background" title="Background">Background</a></h2>
<p>In Erlang it’s possible to seamlessly hot swap the code on a running
process.</p>
<p>Consider the following <code>gen_server</code> implementation of a
counter which can be <code>incr</code>emented and have its current
<code>count</code> value retrieved:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">-module</span><span class="fu">(</span><span class="ch">counter</span><span class="fu">).</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fu">version(</span><span class="st">&quot;1&quot;</span><span class="fu">).</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">-export</span><span class="fu">([</span><span class="ch">start_link</span><span class="op">/</span><span class="dv">0</span><span class="fu">,</span> <span class="ch">incr</span><span class="op">/</span><span class="dv">0</span><span class="fu">,</span> <span class="ch">count</span><span class="op">/</span><span class="dv">0</span><span class="fu">]).</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fu">behavior(</span><span class="ch">gen_server</span><span class="fu">).</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">-export</span><span class="fu">([</span><span class="ch">init</span><span class="op">/</span><span class="dv">1</span><span class="fu">,</span> <span class="ch">handle_call</span><span class="op">/</span><span class="dv">3</span><span class="fu">,</span> <span class="ch">handle_cast</span><span class="op">/</span><span class="dv">2</span><span class="fu">,</span> <span class="ch">handle_info</span><span class="op">/</span><span class="dv">2</span><span class="fu">,</span> <span class="ch">terminate</span><span class="op">/</span><span class="dv">2</span><span class="fu">,</span> <span class="ch">code_change</span><span class="op">/</span><span class="dv">3</span><span class="fu">]).</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="fu">start_link()</span> <span class="op">-&gt;</span> <span class="fu">gen_server:start_link({</span><span class="ch">local</span><span class="fu">,</span> <span class="fu">?</span><span class="va">MODULE</span><span class="fu">},</span> <span class="fu">?</span><span class="va">MODULE</span><span class="fu">,</span> <span class="fu">[],</span> <span class="fu">[{</span><span class="ch">debug</span><span class="fu">,</span> <span class="fu">[</span><span class="ch">trace</span><span class="fu">]}]).</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="fu">incr()</span>  <span class="op">-&gt;</span> <span class="fu">gen_server:call(?</span><span class="va">MODULE</span><span class="fu">,</span> <span class="ch">incr</span><span class="fu">).</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="fu">count()</span> <span class="op">-&gt;</span> <span class="fu">gen_server:call(?</span><span class="va">MODULE</span><span class="fu">,</span> <span class="ch">count</span><span class="fu">).</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="fu">init([])</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span> <span class="dv">0</span><span class="fu">}.</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_call(</span><span class="ch">incr</span><span class="fu">,</span> <span class="va">_From</span><span class="fu">,</span> <span class="va">State</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">reply</span><span class="fu">,</span> <span class="ch">ok</span><span class="fu">,</span> <span class="va">State</span><span class="op">+</span><span class="dv">1</span><span class="fu">};</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_call(</span><span class="ch">count</span><span class="fu">,</span> <span class="va">_From</span><span class="fu">,</span> <span class="va">State</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">reply</span><span class="fu">,</span> <span class="va">State</span><span class="fu">,</span> <span class="va">State</span><span class="fu">};</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_call(</span><span class="va">_Call</span><span class="fu">,</span> <span class="va">_From</span><span class="fu">,</span> <span class="va">State</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">noreply</span><span class="fu">,</span> <span class="va">State</span><span class="fu">}.</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_cast(</span><span class="va">_Cast</span><span class="fu">,</span> <span class="va">State</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">noreply</span><span class="fu">,</span> <span class="va">State</span><span class="fu">}.</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_info(</span><span class="va">_Info</span><span class="fu">,</span> <span class="va">State</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">noreply</span><span class="fu">,</span> <span class="va">State</span><span class="fu">}.</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="fu">terminate(</span><span class="va">_Reason</span><span class="fu">,</span> <span class="va">_State</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="ch">ok</span><span class="fu">.</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="fu">code_change(</span><span class="va">_OldVsn</span><span class="fu">,</span> <span class="va">State</span><span class="fu">,</span> <span class="va">_Extra</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span> <span class="va">State</span><span class="fu">}.</span></span></code></pre></div>
<p>Here’s a small REPL session which shows how it works:</p>
<pre><code>1&gt; c(counter).
{ok,counter}
2&gt; counter:start_link().
{ok,&lt;0.87.0&gt;}
3&gt; counter:incr().
*DBG* counter got call incr from &lt;0.80.0&gt;
*DBG* counter sent ok to &lt;0.80.0&gt;, new state 1
ok
4&gt; counter:incr().
*DBG* counter got call incr from &lt;0.80.0&gt;
*DBG* counter sent ok to &lt;0.80.0&gt;, new state 2
ok
5&gt; counter:count().
*DBG* counter got call count from &lt;0.80.0&gt;
*DBG* counter sent 2 to &lt;0.80.0&gt;, new state 2
2</code></pre>
<p>Now lets introduce a contrived change to the counter where we change
the state to contain an additional counter, which starts at the value of
the old one (see <code>code_change</code>). The two operations
<code>incr</code> and <code>count</code> are changed to operate on the
new counter leaving the old one alone.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode diff"><code class="sourceCode diff"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -1,5 +1,5 @@</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a> -module(counter).</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="st">--version(&quot;1&quot;).</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="va">+-version(&quot;2&quot;).</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a> -export([start_link/0, incr/0, count/0]).</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dt">@@ -13,14 +13,13 @@</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a> init([]) -&gt; {ok, 0}.</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="st">-handle_call(incr, _From, State) -&gt; {reply, ok, State+1};</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="st">-handle_call(count, _From, State) -&gt; {reply, State, State};</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="va">+handle_call(incr, _From, {OldState, State}) -&gt; {reply, ok, {OldState, State+1}};</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="va">+handle_call(count, _From, {OldState, State}) -&gt; {reply, State, {OldState, State}};</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a> handle_call(_Call, _From, State) -&gt; {noreply, State}.</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a> handle_cast(_Cast, State) -&gt; {noreply, State}.</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a> handle_info(_Info, State) -&gt; {noreply, State}.</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a> terminate(_Reason, _State) -&gt; ok.</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="st">-code_change(_OldVsn, State, _Extra) -&gt; {ok, State}.</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="va">+code_change(&quot;1&quot;, State, _Extra) -&gt; {ok, {State, State}}.</span></span></code></pre></div>
<p>We can now upgrade the running process as follows:</p>
<pre><code>6&gt; compile:file(counter).
{ok,counter}
7&gt; sys:suspend(counter).
ok
8&gt; code:purge(counter).
false
9&gt; code:load_file(counter).
{module,counter}
10&gt; sys:change_code(counter, counter, &quot;1&quot;, []).
ok
11&gt; sys:resume(counter).
ok
12&gt; counter:incr().
*DBG* counter got call incr from &lt;0.80.0&gt;
*DBG* counter sent ok to &lt;0.80.0&gt;, new state {2,3}
ok
13&gt; counter:incr().
*DBG* counter got call incr from &lt;0.80.0&gt;
*DBG* counter sent ok to &lt;0.80.0&gt;, new state {2,4}
ok
14&gt; counter:count().
*DBG* counter got call count from &lt;0.80.0&gt;
*DBG* counter sent 4 to &lt;0.80.0&gt;, new state {2,4}
4</code></pre>
<p>This repository is an experiment which tries to do something similar
in Haskell for state machines of type
<code>input -&gt; state -&gt; (state, output)</code>.</p>
</section>
<section id="usage" class="level2">
<h2><a href="#usage" title="Usage">Usage</a></h2>
<p>Before we go into the details of how this is implemented in Haskell,
lets have a look at how it looks from the user’s perspective.</p>
<p>In one terminal run <code>cabal run exe</code> and in another
terminal run <code>cabal repl</code> and type:</p>
<pre><code>&gt; import LibMain
&gt; incr
&gt; count</code></pre>
<p>This should show the following in the first terminal:</p>
<pre><code>Output:    L Unit
New state: Int 1

Output:    R (Int 1)
New state: Int 1</code></pre>
<p>Where <code>L Unit</code> is the output from <code>incr</code> and
<code>R (Int 1)</code> the output from <code>count</code>.</p>
<p>Next we will upgrade the state machine from the REPL:</p>
<pre><code>&gt; import Example.Counter
&gt; upgrade (Upgrade counterSM counterSM2 upgradeState)
&gt; incr
&gt; incr
&gt; count</code></pre>
<p>Which will result in the following being printed in the first
terminal:</p>
<pre><code>Upgrade successful!

Output:    L Unit
New state: Pair (Int 1) (Int 1)

Output:    L Unit
New state: Pair (Int 1) (Int 2)

Output:    R (Int 2)
New state: Pair (Int 1) (Int 2)</code></pre>
<p>If we try to upgrade again, we get an error:</p>
<pre><code>The version running isn&#39;t the one the upgrade expects. Aborting upgrade.</code></pre>
</section>
<section id="how-it-works" class="level2">
<h2><a href="#how-it-works" title="How it works">How it works</a></h2>
<p>The basic idea is that we want our state machines to be seralisable
so that we can send them over the network in order to perform remote
upgrades.</p>
<p>The key observation is that a state machine of type:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">SM</span> state input output <span class="ot">=</span> input <span class="ot">-&gt;</span> state <span class="ot">-&gt;</span> (state, output)</span></code></pre></div>
<p>is an instance of <code>Arrow</code> and <code>Arrow</code>s allow us
to express functions in a first-order way, as long as
<code>arr :: Arrow a =&gt; (b -&gt; c) -&gt; a b c</code> is
<em>not</em> used.</p>
<p>The <code>Arrow</code> type class modulo <code>arr</code> is the
<code>CartesianCategory</code> type class from Conal Elliott’s work on
<a href="http://conal.net/papers/compiling-to-categories/">compiling to
categories</a>.</p>
<p>The <code>CartesianCategory</code> type class is defined as
follows:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> k <span class="ot">=&gt;</span> <span class="dt">Cartesian</span> k <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&amp;&amp;&amp;) ::</span> k a c <span class="ot">-&gt;</span> k a d <span class="ot">-&gt;</span> k a (c, d)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (***) ::</span> k b c <span class="ot">-&gt;</span> k b&#39; c&#39; <span class="ot">-&gt;</span> k (b, b&#39;) (c, c&#39;)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  fst   ::</span> k (a, b) a</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  snd   ::</span> k (a, b) b</span></code></pre></div>
<p>The initial (or free) <code>CartesianCategory</code> is given by the
following data type:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FreeCC</span> a b <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Id</span><span class="ot">      ::</span> <span class="dt">FreeCC</span> a a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Compose</span><span class="ot"> ::</span> <span class="dt">FreeCC</span> b c <span class="ot">-&gt;</span> <span class="dt">FreeCC</span> a b <span class="ot">-&gt;</span> <span class="dt">FreeCC</span> a c</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&amp;&amp;&amp;)  ::</span> <span class="dt">FreeCC</span> a c <span class="ot">-&gt;</span> <span class="dt">FreeCC</span> a d <span class="ot">-&gt;</span> <span class="dt">FreeCC</span> a (c, d)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:***)  ::</span> <span class="dt">FreeCC</span> b c <span class="ot">-&gt;</span> <span class="dt">FreeCC</span> b&#39; c&#39; <span class="ot">-&gt;</span> <span class="dt">FreeCC</span> (b, b&#39;) (c, c&#39;)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Fst</span><span class="ot">     ::</span> <span class="dt">FreeCC</span> (a, b) a</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Snd</span><span class="ot">     ::</span> <span class="dt">FreeCC</span> (a, b) b</span></code></pre></div>
<p>with the, hopefully, obvious <code>Cartesian</code> instance.</p>
<p>So the idea is that we write our program using the
<code>Cartesian</code>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swap ::</span> <span class="dt">Cartesian</span> k <span class="ot">=&gt;</span> k (a, b) (b, a)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>swap <span class="ot">=</span> copy <span class="op">&gt;&gt;&gt;</span> <span class="fu">snd</span> <span class="op">***</span> <span class="fu">fst</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    copy ::</span> <span class="dt">Cartesian</span> k <span class="ot">=&gt;</span> k a (a, a)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    copy <span class="ot">=</span> <span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> <span class="fu">id</span></span></code></pre></div>
<p>And then we can instantiate <code>k</code> to be <code>FreeCC</code>
and get ahold of the serialisable syntax.</p>
<p>Ideally, since writing larger programs in this point-free style is
tricky, we’d like to use Haskell’s arrow syntax:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swap&#39; ::</span> <span class="dt">Cartesian</span> k <span class="ot">=&gt;</span> k (a, b) (b, a)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>swap&#39; <span class="ot">=</span> proc (x, y) <span class="ot">-&gt;</span> returnA <span class="op">-&lt;</span> (y, x)</span></code></pre></div>
<p>After all <code>Cartesian</code> is merely <code>Arrow</code> without
<code>arr</code> and we’ve shown how <code>swap</code> can be
implemented without <code>arr</code>, but alas GHC nevertheless tries to
translate <code>swap'</code> into something that uses <code>arr</code>
which ruins our plan.</p>
<p>Conal developed the <code>concat</code> GHC plugin to avoid this
problem. It translates any monomorphic Haskell function into an
<code>Arrow</code> of any user-defined Haskell Cartesian closed category
(CCC)<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<p>Oleg Grenrus also developed another GHC <a
href="https://github.com/phadej/overloaded/blob/master/src/Overloaded/Categories.hs">plugin</a>
that does the right thing and translates arrow syntax into
<code>CartesianCategory</code> rather than <code>Arrow</code> which also
solves the problem.</p>
<p>Since both of these approaches rely on the GHC plugin machinery they
are quite heavyweight. Conal’s translation works for any monomorphic
function, so in a sense it solves a more general problem than we need.
Oleg’s library is also solving a bunch of other problems that we don’t
care about, it implements OverloadedStrings, OverloadedLists,
OverloadedLabels using the plugin, and more importantly it doesn’t
compile with GHC 9.2 or above.</p>
<p>More recently Lucas Escot <a
href="https://acatalepsie.fr/posts/overloading-lambda">showed</a> how to
use ideas from Jean-Philippe Bernardy and Arnaud Spiwack’s <a
href="https://arxiv.org/abs/2103.06195">paper</a> <em>Evaluating Linear
Functions to Symmetric Monoidal Categories</em> (2021) to provide a
small DSL which gives us something close to the arrow syntax. It’s also
not quite perfect, in particular higher-order combinators cannot be
expressed, but Lucas tells me that he’s working on a follow up post
which tackles this problem. As we’ve seen in the above example, we also
need to encode the state machine’s inputs and outputs as explicit
<code>Either</code>s, it might be possible to get around this with some
generically derived isomorphism though.</p>
<p>Anyway, we use the <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/main/src/Syntax.hs">trick</a>
that Lucas described to express our <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/3e0a0cf8f605cfd8edd60aef1ebe6fb002bbea3e/src/Example/Counter.hs#L6">state
machines</a> and from that we get something <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/main/src/StateMachine.hs">similar</a>
to the free Cartesian category (<code>FreeCC</code> above), which we
then compile to the <a
href="https://en.wikipedia.org/wiki/Categorical_abstract_machine">Categorical
abstract machine</a> (CAM). This <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/main/src/Compiler.hs">compilation</a>
process is rather straight-forward as <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/main/src/AbstractMachine.hs">CAM</a>
is similar to <code>FreeCC</code>. The CAM <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/main/src/Code.hs">“bytecode”</a>
is our serialised state machine and this is what gets sent over the
network when doing upgrades.</p>
<p>The idea is that each deployed node runs a CAM (or some other
abstract machine), when we <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/3f7c4081d84a6ca3eeafbe892ca0798b96f61645/src/LibMain.hs#L25">deploy</a>
the node we specify a initial state machine (SM) to run there. We then
remotely upgrade the state machine on a node by sending it CAM bytecode
of the old SM (this is used to verify that we are not updating the wrong
SM), the bytecode for the new SM and the bytecode for a state migration
(old state to new state). The state migration is <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/3f7c4081d84a6ca3eeafbe892ca0798b96f61645/src/LibMain.hs#L65">type-safe</a>.</p>
<p>We could also serialise the free Cartesian category and send that
over the network, but the bytecode is “flatter” (i.e. can more easily be
turned into a list of bytecodes) and hopefully a more stable API. I can
imagine situations where the syntax for writing state machines changes
or gets more expressive, but the bytecode stays the same. Which is a
good thing, since upgrading the abstract machine on a node can probably
not be done as easily without any downtime.</p>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>I believe this is a good starting point for further experiments, here
are a few ideas:</p>
<ul class="task-list">
<li><input type="checkbox" />Generate <code>FreeFunc s a b</code> so
that the <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/main/src/Correctness.hs">correctness</a>
can be tested using property-based testing;</li>
<li><input type="checkbox" />Backwards compatibility, i.e. allow old
inputs after an upgrade, perhaps similar to how state migrations are
handled by providing a <code>FreeFunc ()       oldInput newInput</code>
as part of <a
href="https://github.com/stevana/hot-swapping-state-machines/blob/02b84cf590addcb35d9ac524070ac93859e1b035/src/LibMain.hs#L62"><code>Upgrade</code></a>;</li>
<li><input type="checkbox" />Automatic state migration? C.f. <a
href="https://github.com/turion/essence-of-live-coding#migration">essence-of-live-coding</a>;</li>
<li><input type="checkbox" />Downgrades and rollback in case upgrades
fail;</li>
<li><input type="checkbox" />Improve the DSL for writing state machines:
<ul>
<li>Either building upon the current approach described in <a
href="https://acatalepsie.fr/posts/overloading-lambda"><em>Overloading
the lambda abstraction in Haskell</em></a> by Lucas;</li>
<li>Or perhaps using a custom preprocessor and quasiquoter for Cartesian
(closed) categories, see Pepe Iborra’s <a
href="https://hackage.haskell.org/package/arrowp-qq">arrowp-qq</a> for
inspiration;</li>
<li>Or porting the <a
href="https://hackage.haskell.org/package/overloaded-0.3.1/docs/Overloaded-Categories.html">Overloaded.Categories</a>
bits from Oleg’s plugin to newer GHC versions;</li>
<li>Or actually fixing GHC, I’m not sure if there’s a proposal for this
already, I think the closest thing I could find is <a
href="https://github.com/ghc-proposals/ghc-proposals/pull/303">this</a>
(stale) one by Alexis King.</li>
</ul></li>
<li><input type="checkbox" />In Erlang upgrades are usually not done
directly on <code>gen_server</code> but rather via the
<code>application</code> and <code>release</code>s behaviours. In short
one <code>application</code> is a supervisor tree and a
<code>release</code> is one or more <code>application</code>s. For more
see <a
href="https://kennyballou.com/blog/2016/12/elixir-hot-swapping/index.html">appup
and relups</a>, as well as how this can be automated using rebar3 over
<a
href="https://lrascao.github.io/automatic-release-upgrades-in-erlang/">here</a>.
What would porting that over to our setting look like?</li>
<li><input type="checkbox" />How does Erlang handle upgrades of the VM
without downtime?</li>
<li><input type="checkbox" />Would anything need to be changed if we
tried to combine the arrow-based state machines with <a
href="https://github.com/stevana/supervised-state-machines">supervisors</a>
or <a href="https://github.com/stevana/coroutine-state-machines">async
I/O</a>?</li>
<li><input type="checkbox" />Can we implement the abstract machine and
event loop using <a
href="https://github.com/jart/cosmopolitan">Cosmopolitan</a> or
WebAssembly for portability?</li>
<li><input type="checkbox" />Imagine if we wanted to develop state
machines in an other programming language but still target the CAM. Most
programming languages don’t have GADTs so type-safe the free Cartesian
category will not be possible to implement, furthermore even if we could
there’s the problem of working with combinators vs arrow syntax… Is
there a more low-tech solution that would be easier to port to less
featureful languages?</li>
</ul>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li><a
href="https://github.com/turion/essence-of-live-coding"><code>essence-of-live-coding</code></a>:
FRP library with hot code swapping support.</li>
<li>Dan Piponi’s <code>circuit</code>s are similar to our state
machines:
<ul>
<li><a
href="http://blog.sigfpe.com/2017/01/addressing-pieces-of-state-with.html"
class="uri">http://blog.sigfpe.com/2017/01/addressing-pieces-of-state-with.html</a>;</li>
<li><a
href="http://blog.sigfpe.com/2017/01/building-free-arrows-from-components.html"
class="uri">http://blog.sigfpe.com/2017/01/building-free-arrows-from-components.html</a>.</li>
</ul></li>
<li>Chris Penner’s <em>Deconstructing Lambdas</em> <a
href="https://youtube.com/watch?v=xZmPuz9m2t0">talk</a> (2021);</li>
<li>The <em>Dynamic code change</em> chapter (p. 72) in Joe Armstrong’s
PhD <a
href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=2250">thesis</a>
(2003).</li>
</ul>
</section>
<section id="acknowledgments" class="level2">
<h2><a href="#acknowledgments"
title="Acknowledgments">Acknowledgments</a></h2>
<p>Thanks to Daniel Gustafsson for helping me understand
<code>Port</code> from the <em>Overloading the lambda abstraction in
Haskell</em> blog post!</p>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The closed part of Cartesian <em>closed</em> category
means that we also add exponents (not just finite products),
i.e. analogous to <a
href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Control-Arrow.html#t:ArrowApply"><code>ArrowApply</code></a>.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></description>
      <category>Upgrading</category>
    </item>

    <item>
      <title>Deploying and restarting state machines using supervisor trees</title>
      <link>https://stevana.github.io/deploying_and_restarting_state_machines_using_supervisor_trees.html</link>
      <guid>https://stevana.github.io/deploying_and_restarting_state_machines_using_supervisor_trees.html</guid>
      <pubDate>Mon, 13 Feb 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>supervised-state-machines</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#how-it-works" id="toc-how-it-works">How it works</a>
<ul>
<li><a href="#generic-server" id="toc-generic-server">Generic
server</a></li>
<li><a href="#supervisor" id="toc-supervisor">Supervisor</a></li>
<li><a href="#event-loop" id="toc-event-loop">Event loop</a></li>
<li><a href="#example" id="toc-example">Example</a></li>
</ul></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
</ul>
</nav>
<div class="date">Posted on Feb 13, 2023</div>
<p>An experimental implementation of Erlang/OTP’s
<code>gen_server</code> and <code>supervisor</code> behaviours that
doesn’t use lightweight threads and message passing.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>What exactly is it that makes Erlang suitable for writing reliable
distributed systems?</p>
<p>I’ve previously <a
href="https://github.com/stevana/armstrong-distributed-systems/blob/main/docs/erlang-is-not-about.md#erlangs-not-about-lightweight-processes-and-message-passing">argued</a>
that it’s Erlang’s <em>behaviours</em> rather than its lightweight
processes and message passing.</p>
<p>Behaviours can be thought of as generic building blocks for building
reliable distributed systems. Erlang/OTP exposes six behaviours and
encourages its users to compose them into bigger systems. The behaviours
are generic in that they are parametrised by interfaces, the idea being
that the user implements the interface in a problem specific way and
then the user gets the generic component from Erlang/OTP. Typically the
interface requires a sequential implementation while the generic
component exposes a concurrent (or thread-safe) API, i.e. behaviours
abstract away the low-level and difficult concurrent code which is
difficult to get right. Joe Armstrong <a
href="https://dl.acm.org/doi/10.1145/1238844.1238850">describes</a> them
as follows:</p>
<blockquote>
<p>Behaviors in Erlang can be thought of as parameterizable higher-order
parallel processes. They represent an extension of conventional
higher-order functions (like map, fold etc) into a concurrent
domain.</p>
</blockquote>
<p>Which I think is a good analogy, as e.g. <code>map</code> and
<code>fold</code> hide the low-level details of <code>for</code>-loops,
although the concurrent details of behaviours are typically more
complicated than manually dealing with index variables.</p>
<p>This repo is an experiment in trying to implement two of these
behaviours, namely <code>gen_server</code> and <code>supervisor</code>,
without using lightweight processes/threads and message passing. I
believe the last part about not using lightweight threads is a design
space that hasn’t been explored much yet. Most programming languages or
libraries seem to start with the assumption that what makes Erlang great
for writing reliable distributed systems is its lightweight threads and
message passing, and they never even get to the point where they steal
the structure of behaviours!</p>
</section>
<section id="how-it-works" class="level2">
<h2><a href="#how-it-works" title="How it works">How it works</a></h2>
<section id="generic-server" class="level3">
<h3><a href="#generic-server" title="Generic server">Generic
server</a></h3>
<p>The sequential semantics (or “business logic”) of a generic server
(<code>gen_server</code>) should take some input and the current state
and produce some output and a new updated state, i.e.:</p>
<pre><code>  input -&gt; state -&gt; (state, output)</code></pre>
<p>Client requests to the server will come in via the network, so we
also need a <code>Codec</code> to be able to decode
<code>ByteString</code>s into <code>input</code>s and encode
<code>output</code>s into <code>ByteString</code>s to be able to reply
to the client. We might also want to deserialise the initial state
<code>state</code> from disk on startup and serialise it to disk on
termination. See the <code>StateMachine</code> <a
href="src/StateMachine.hs">module</a> for the details of the above.</p>
</section>
<section id="supervisor" class="level3">
<h3><a href="#supervisor" title="Supervisor">Supervisor</a></h3>
<p>The job of a supervisor is to monitor its children for failures and
do restarts according to some predetermined restart strategy in case a
failure happens.</p>
<p>Supervisors are organised in trees where generic servers (or more
generally any other worker behaviours) are at the leaves and other
supervisors are at the nodes. Since supervisors trees determine an order
(depth-first) they can be used to deploy a system of generic
servers.</p>
<p>See the <code>Supervisor</code> <a
href="src/Supervisor.hs">module</a> for details.</p>
</section>
<section id="event-loop" class="level3">
<h3><a href="#event-loop" title="Event loop">Event loop</a></h3>
<p>The concurrent part of the generic servers is implemented in the
<code>EventLoop</code> <a href="src/EventLoop.hs">module</a>. The basic
idea is that we concurrently write client request
<code>ByteString</code>s to a concurrent queue and the event loop will
decode the input and <code>step</code> the right server with said input
and respond to the client with the output produce by the server.</p>
<p>The behavior of supervisors is also implemented in the event loop.
Basically we wrap the <code>step</code> function in a <code>try</code>
and <code>catch</code> and in case of failure we do the appropriate
restarts.</p>
</section>
<section id="example" class="level3">
<h3><a href="#example" title="Example">Example</a></h3>
<p>As an example of generic server I’ve implemented a simple key value
store in the <code>Example.KeyValueStore</code> <a
href="src/Example/KeyValueStore.hs">module</a>. In <a
href="app/Main.hs"><code>app/Main.hs</code></a> we start an event loop
with a simple supervisor tree containing the key value store:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">    main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> sup <span class="ot">=</span> <span class="dt">Supervisor</span> <span class="dt">OneForOne</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                  [ <span class="dt">Worker</span> (<span class="st">&quot;kv1&quot;</span>, kvStore)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                  , <span class="dt">Supervisor</span> <span class="dt">RestForOne</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                      [ <span class="dt">Worker</span> (<span class="st">&quot;kv2&quot;</span>, kvStore), <span class="dt">Worker</span> (<span class="st">&quot;kv3&quot;</span>, kvStore) ]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                  ]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>      queue <span class="ot">&lt;-</span> newTBQueueIO <span class="dv">128</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      withEventLoop sup queue <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        call_ <span class="st">&quot;kv2&quot;</span> (<span class="dt">Store</span> <span class="st">&quot;x&quot;</span> <span class="dv">1</span>) queue</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        r0 <span class="ot">&lt;-</span> call <span class="st">&quot;kv2&quot;</span> (<span class="dt">Lookup</span> <span class="st">&quot;x&quot;</span>) queue</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span> r0</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        call_ <span class="st">&quot;kv2&quot;</span> (<span class="dt">Lookup</span> <span class="st">&quot;crash&quot;</span>) queue <span class="co">-- Deliberate bug which causes a crash.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        r1 <span class="ot">&lt;-</span> call <span class="st">&quot;kv2&quot;</span> (<span class="dt">Lookup</span> <span class="st">&quot;x&quot;</span>) queue</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span> r1</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        r2 <span class="ot">&lt;-</span> call <span class="st">&quot;kv2&quot;</span> (<span class="dt">Lookup</span> <span class="st">&quot;y&quot;</span>) queue</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span> r2</span></code></pre></div>
<p>When run with <code>cabal run kv</code> it produces the following
output:</p>
<pre><code>    Calling kv2: Store &quot;x&quot; 1
    KV store starting: kv1
    KV store starting: kv2
    KV store starting: kv3
    Calling kv2: Lookup &quot;x&quot;
    Right &quot;Result (Just 1)&quot;
    Calling kv2: Lookup &quot;crash&quot;
    kv2 threw: divide by zero
    KV store terminating: kv2
    KV store terminating: kv3
    KV store starting: kv2
    KV store starting: kv3
    Calling kv2: Lookup &quot;x&quot;
    Right &quot;Result Nothing&quot;
    Calling kv2: Lookup &quot;y&quot;
    Right &quot;Result Nothing&quot;</code></pre>
</section>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>There are many ways in which this repo can be extended, here are some
ideas:</p>
<ul class="task-list">
<li><input type="checkbox" />Add HTTP endpoint for writing to the event
loop queue. (Hint: see the <code>HttpServer</code> and
<code>EventLoop</code> modules of this <a
href="https://github.com/stevana/coroutine-state-machines">repo</a>));</li>
<li><input type="checkbox" />Save and restore the state of the example
to disk in <code>terminate</code> and <code>init</code>;</li>
<li><input type="checkbox" />Customisable shutdown grace time;</li>
<li><input type="checkbox" />The supervisors itself should fail if its
children have failed too many times within some time interval;</li>
<li><input type="checkbox" />Supervisors should be able to supervise
supervisor trees that are deployed on other computers.</li>
</ul>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li>There are a handful of supervisor implementations in Haskell <a
href="https://hackage.haskell.org/packages/search?terms=supervisor">already</a>,
but I think all of them assume that the children are running on their
own threads.</li>
</ul>
</section>
]]></description>
      <category>Deployment</category>
    </item>

    <item>
      <title>Simulation testing using state machines</title>
      <link>https://stevana.github.io/simulation_testing_using_state_machines.html</link>
      <guid>https://stevana.github.io/simulation_testing_using_state_machines.html</guid>
      <pubDate>Tue, 7 Feb 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>Property-based testing stateful systems: a tutorial</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#structure" id="toc-structure">Structure</a></li>
<li><a href="#table-of-contents" id="toc-table-of-contents">Table of
contents</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#license" id="toc-license">License</a></li>
</ul>
</nav>
<div class="date">Posted on Feb  7, 2023</div>
<p><a
href="https://github.com/stevana/property-based-testing-stateful-systems-tutorial/actions"><img
src="https://github.com/stevana/property-based-testing-stateful-systems-tutorial/workflows/CI/badge.svg"
alt="GitHub CI" /></a> <a
href="https://hackage.haskell.org/package/property-based-testing-stateful-systems-tutorial"><img
src="https://img.shields.io/hackage/v/property-based-testing-stateful-systems-tutorial.svg"
alt="Hackage" /></a></p>
<p>Property-based testing (PBT), i.e. generating random inputs and
checking some property of the output, of pure programs is an established
practice by now. It’s taught in introductory university classes and it’s
part of test suites in industry.</p>
<p>Most real world programs are not pure though, they are stateful.
While it’s often possible to structure your program in such a way that
the impure stuff is done in <code>main</code>, e.g. read the contents of
a file, and then passed on to a pure function, e.g. a parser, it’s not
always possible. Consider a long-running program that interacts with the
filesystem and with other programs over the network, e.g. some kind of
web service or a distributed database. It’s difficult to split such a
program up into doing a little bit of impure stuff at the start, then
hand it over to a pure function (which we can apply PBT on).</p>
<p>Given this it’s perhaps a bit surprising that there are relatively
few resources about applying PBT to stateful systems. This repository is
an attempt to close that gap and try to make PBT stateful systems more
common.</p>
<p>The goals we’d like to achieve are:</p>
<ul>
<li><p>Show how to test stateful (i.e. impure/monadic) programs using
property-based testing;</p></li>
<li><p>Show how we can do concurrent testing to help uncover problems
such as race conditions;</p></li>
<li><p>Show how we can build bigger systems in a modular way by applying
the property-based testing equivalent of integration and contract
tests;</p></li>
<li><p>Show how to use fault injection and so called simulation testing
to “end-to-end” test distributed systems;</p></li>
<li><p>Introduce the reader to related work and open problems in the
area along the way.</p></li>
</ul>
<p>In the interest of brevity, we assume that the reader already
has:</p>
<ul>
<li><p>Enough familiarity with Haskell to be able to read simple
programs, for example if you can follow along in the <em>Learn You a
Haskell for Great Good!</em> <a
href="http://learnyouahaskell.com/chapters">tutorial</a>, then you
should be fine;</p></li>
<li><p>Some experience with property-based testing of non-stateful
(i.e. pure) programs. For example as explained in the official
QuickCheck <a
href="http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html">manual</a>
or in the following <a
href="https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html">tutorial</a>;</p></li>
<li><p>Basic knowledge of state machines (i.e. <a
href="https://en.wikipedia.org/wiki/Mealy_machine">Mealy</a> / <a
href="https://en.wikipedia.org/wiki/Moore_machine">Moore machines</a>
and <a
href="https://en.wikipedia.org/wiki/Finite-state_transducer">transducers</a>).</p></li>
</ul>
<p>Other than that this tutorial is striving to be as self-contained as
possibly as well as accessible to non-Haskell programmers.</p>
<section id="structure" class="level2">
<h2><a href="#structure" title="Structure">Structure</a></h2>
<p>The tutorial is split up into five parts (so far), and each part has
the following structure:</p>
<ul>
<li>Motivation: explains why we are doing what we are about to do;</li>
<li>Plan: how we will do it;</li>
<li>Code: a concrete implementation of the idea (in case you get stuck
when trying to implement it yourself);</li>
<li>Discussion: common questions or objections;</li>
<li>Exercises: things the authors were to lazy to do, but they know how
to;</li>
<li>Problems: things the authors don’t know how to do (yet);</li>
<li>See also: links to further reading about the topic or related
topics;</li>
<li>Summary: the most important take away.</li>
</ul>
<p>The parts build upon each other. We start by modelling and testing a
simple counter using a state machine in part 1, we then reuse the same
state machine model to test the counter for thread-safety using
linearisability in part 2. In part 3 we will implement a queue and a web
service that uses said queue, the state machine model for the queue and
the real implementation of the queue will be contract tested to ensure
that the model is faithful to the implementation, subsequently while
testing the web service we will use the model in place of the real
queue. In part 4 we introduce fault injection to the queue allowing us
to test how the web service performs when its dependency fails. Finally,
in part 5, we combine all the above ideas in what, sometimes is called
simulation testing, to test a distributed system that uses replicated
state machines.</p>
</section>
<section id="table-of-contents" class="level2">
<h2><a href="#table-of-contents" title="Table of contents">Table of
contents</a></h2>
<ol type="1">
<li><a href="./docs/Part01SMTesting.md#readme">State machine
testing</a></li>
<li><a href="./docs/Part02ConcurrentSMTesting.md#readme">Concurrent
state machine testing with linearisability</a></li>
<li><a href="./docs/Part03SMContractTesting.md#readme">Integration tests
against state machine fakes and consumer-driven contract tests for the
fakes</a></li>
<li><a
href="./docs/Part04FaultInjection.md#readme">Fault-injection</a></li>
<li>Simulation testing</li>
</ol>
</section>
<section id="usage" class="level2">
<h2><a href="#usage" title="Usage">Usage</a></h2>
<p>This repository contains literate Haskell code in <code>src</code>.
If you want to interact with it, install <a
href="https://www.haskell.org/ghcup/install/"><code>ghcup</code></a> and
then type <code>cabal repl</code>. Alternatively, if you are using the
<a href="https://nixos.org/download.html"><code>nix</code></a> package
manager, then running <code>nix-shell</code> in the root directory
should give you the right <code>ghc</code> version and all other
dependencies you might need.</p>
<p>The literate code is transformed into markdown using <a
href="https://pandoc.org/"><code>pandoc</code></a> in <a
href="./tools/generate_markdown.sh"><code>tools/generate_markdown.sh</code></a>
and the markdown is put inside the <a
href="./docs"><code>docs</code></a> directory for easier browsing.</p>
<p>The following is a link to the <a
href="./docs/Part01SMTesting.md#readme">first part</a> of the generate
markdown, at the end it will link to the second part and so on. Or you
can use the table of contents above or the <code>docs</code> directory
to jump to desired part straight away.</p>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>Any feedback, suggestions for improvement or questions are most
welcome via the issue tracker!</p>
<p>See the <a
href="./.github/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a> file
for more detailed guidelines regarding contributing.</p>
</section>
<section id="license" class="level2">
<h2><a href="#license" title="License">License</a></h2>
<p>See the <a href="./LICENSE"><code>LICENSE</code></a> file.</p>
</section>
]]></description>
      <category>Testing</category>
    </item>

    <item>
      <title>Erlang's not about lightweight processes and message passing...</title>
      <link>https://stevana.github.io/erlangs_not_about_lightweight_processes_and_message_passing.html</link>
      <guid>https://stevana.github.io/erlangs_not_about_lightweight_processes_and_message_passing.html</guid>
      <pubDate>Wed, 18 Jan 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>Erlang’s not about lightweight processes and message passing…</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#background" id="toc-background">Background</a></li>
<li><a href="#behaviours" id="toc-behaviours">Behaviours</a>
<ul>
<li><a href="#generic-server-behaviour"
id="toc-generic-server-behaviour">Generic server behaviour</a></li>
<li><a href="#event-manager-behaviour"
id="toc-event-manager-behaviour">Event manager behaviour</a></li>
<li><a href="#state-machine-behaviour"
id="toc-state-machine-behaviour">State machine behaviour</a></li>
<li><a href="#supervisor-behaviour"
id="toc-supervisor-behaviour">Supervisor behaviour</a></li>
<li><a href="#application-and-release-behaviours"
id="toc-application-and-release-behaviours">Application and release
behaviours</a></li>
</ul></li>
<li><a href="#how-behaviours-can-be-implemented"
id="toc-how-behaviours-can-be-implemented">How behaviours can be
implemented</a></li>
<li><a href="#correctness-of-behaviours"
id="toc-correctness-of-behaviours">Correctness of behaviours</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
<li><a href="#discussion" id="toc-discussion">Discussion</a></li>
</ul>
</nav>
<div class="date">Posted on Jan 18, 2023</div>
<p>I used to think that the big idea of Erlang is its lightweight
processes and message passing. Over the last couple of years I’ve
realised that there’s a bigger insight to be had, and in this post I’d
like to share it with you.</p>
<section id="background" class="level2">
<h2><a href="#background" title="Background">Background</a></h2>
<p>Erlang has an interesting history. If I understand things correctly,
it started off as a Prolog library for building reliable distributed
systems, morphed into a Prolog dialect, before finally becoming a
language in its own right.</p>
<p>The goal seemed to have always been to solve the problem of building
reliable distributed systems. It was developed at Ericsson and used to
program their telephone switches. This was sometime in the 80s and 90s,
before internet use become widespread. I suppose they were already
dealing with “internet scale” traffic, i.e. hundreds of millions of
users, with stricter SLAs than most internet services provide today. So
in a sense they were ahead of their time.</p>
<p>In 1998 Ericsson decided to ban all use of Erlang<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.
The people responsible for developing it argued that if they were going
to ban it, then they might as well open source it. Which Ericsson did
and shortly after most of the team that created Erlang quit and started
their own company.</p>
<p>One of these people was Joe Armstrong, which also was one of the main
people behind the design and implementation of Erlang. The company was
called Bluetail and they got bought up a couple of times but in the end
Joe got fired in 2002.</p>
<p>Shortly after, still in 2002, Joe starts writing his PhD thesis at
the Swedish Institute of Computer Science (SICS). Joe was born 1950, so
he was probably 52 years old at this point. The topic of the thesis is
<em>Making reliable distributed systems in the presence of software
errors</em> and it was finished the year after in 2003.</p>
<p>It’s quite an unusual thesis in many ways. For starters, most theses
are written by people in their twenties with zero experience of
practical applications. Whereas in Joe’s case he has been working
professionally on this topic since the 80s, i.e. about twenty years. The
thesis contains no math nor theory, it’s merely a presentation of the
ideas that underpin Erlang and how they used Erlang to achieve the
original goal of building reliable distributed systems.</p>
<p>I highly commend reading his <a
href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-1166">thesis</a>
and forming your own opinion, but to me it’s clear that the big idea
there isn’t lightweight processes<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> and message passing, but
rather the generic components which in Erlang are called
<em>behaviours</em>.</p>
</section>
<section id="behaviours" class="level2">
<h2><a href="#behaviours" title="Behaviours">Behaviours</a></h2>
<p>I’ll first explain in more detail what behaviours are, and then I’ll
come back to the point that they are more important than the idea of
lightweight processes.</p>
<p>Erlang behaviours are like interfaces in, say, Java or Go. It’s a
collection of type signatures which can have multiple implementations,
and once the programmer provides such an implementation they get access
to functions written against that interface. To make it more concrete
here’s a contrived example in Go:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The interface.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> HasName <span class="kw">interface</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        Name<span class="op">()</span> <span class="dt">string</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">// A generic function written against the interface.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> Greet<span class="op">(</span>n HasName<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Printf<span class="op">(</span><span class="st">&quot;Hello %s!</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">.</span>Name<span class="op">())</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">// First implementation of the interface.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Joe <span class="kw">struct</span> <span class="op">{}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>_ <span class="op">*</span>Joe<span class="op">)</span> Name<span class="op">()</span> <span class="dt">string</span> <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;Joe&quot;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">// Second implementation of the interface.</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Mike <span class="kw">struct</span> <span class="op">{}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>_ <span class="op">*</span>Mike<span class="op">)</span> Name<span class="op">()</span> <span class="dt">string</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;Mike&quot;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        joe <span class="op">:=</span> <span class="op">&amp;</span>Joe<span class="op">{}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        mike <span class="op">:=</span> <span class="op">&amp;</span>Mike<span class="op">{}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        Greet<span class="op">(</span>mike<span class="op">)</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        Greet<span class="op">(</span>joe<span class="op">)</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Running the above program will display:</p>
<pre><code>Hello Mike!
Hello Joe!</code></pre>
<p>This hopefully illustrates how <code>Greet</code> is generic in, or
parametrised by, the interface <code>HasName</code>.</p>
<section id="generic-server-behaviour" class="level3">
<h3><a href="#generic-server-behaviour"
title="Generic server behaviour">Generic server behaviour</a></h3>
<p>Next lets have a look at a more complicated example in Erlang taken
from Joe’s thesis (p. 136). It’s a key-value store where we can
<code>store</code> a key value pair or <code>lookup</code> the value of
a key, the <code>handle_call</code> part is the most interesting:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">-module</span><span class="fu">(</span><span class="ch">kv</span><span class="fu">).</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fu">behaviour(</span><span class="ch">gen_server</span><span class="fu">).</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">-export</span><span class="fu">([</span><span class="ch">start</span><span class="op">/</span><span class="dv">0</span><span class="fu">,</span> <span class="ch">stop</span><span class="op">/</span><span class="dv">0</span><span class="fu">,</span> <span class="ch">lookup</span><span class="op">/</span><span class="dv">1</span><span class="fu">,</span> <span class="ch">store</span><span class="op">/</span><span class="dv">2</span><span class="fu">]).</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">-export</span><span class="fu">([</span><span class="ch">init</span><span class="op">/</span><span class="dv">1</span><span class="fu">,</span> <span class="ch">handle_call</span><span class="op">/</span><span class="dv">3</span><span class="fu">,</span> <span class="ch">handle_cast</span><span class="op">/</span><span class="dv">2</span><span class="fu">,</span> <span class="ch">terminate</span><span class="op">/</span><span class="dv">2</span><span class="fu">]).</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="fu">start()</span> <span class="op">-&gt;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gen_server:start_link({</span><span class="ch">local</span><span class="fu">,</span><span class="ch">kv</span><span class="fu">},</span><span class="ch">kv</span><span class="fu">,</span><span class="ch">arg1</span><span class="fu">,[]).</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="fu">stop()</span> <span class="op">-&gt;</span> <span class="fu">gen_server:cast(</span><span class="ch">kv</span><span class="fu">,</span> <span class="ch">stop</span><span class="fu">).</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="fu">init(</span><span class="ch">arg1</span><span class="fu">)</span> <span class="op">-&gt;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">io:format(</span><span class="st">&quot;Key-Value server starting~n&quot;</span><span class="fu">),</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span> <span class="fu">dict:new()}.</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="fu">store(</span><span class="va">Key</span><span class="fu">,</span> <span class="va">Val</span><span class="fu">)</span> <span class="op">-&gt;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gen_server:call(</span><span class="ch">kv</span><span class="fu">,</span> <span class="fu">{</span><span class="ch">store</span><span class="fu">,</span> <span class="va">Key</span><span class="fu">,</span> <span class="va">Val</span><span class="fu">}).</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup(</span><span class="va">Key</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">gen_server:call(</span><span class="ch">kv</span><span class="fu">,</span> <span class="fu">{</span><span class="ch">lookup</span><span class="fu">,</span> <span class="va">Key</span><span class="fu">}).</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_call({</span><span class="ch">store</span><span class="fu">,</span> <span class="va">Key</span><span class="fu">,</span> <span class="va">Val</span><span class="fu">},</span> <span class="va">From</span><span class="fu">,</span> <span class="va">Dict</span><span class="fu">)</span> <span class="op">-&gt;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  <span class="va">Dict1</span> <span class="op">=</span> <span class="fu">dict:store(</span><span class="va">Key</span><span class="fu">,</span> <span class="va">Val</span><span class="fu">,</span> <span class="va">Dict</span><span class="fu">),</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span><span class="ch">reply</span><span class="fu">,</span> <span class="ch">ack</span><span class="fu">,</span> <span class="va">Dict1</span><span class="fu">};</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_call({</span><span class="ch">lookup</span><span class="fu">,</span> <span class="ch">crash</span><span class="fu">},</span> <span class="va">From</span><span class="fu">,</span> <span class="va">Dict</span><span class="fu">)</span> <span class="op">-&gt;</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span><span class="op">/</span><span class="dv">0</span><span class="fu">;</span> <span class="co">%% &lt;- deliberate error :-)</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_call({</span><span class="ch">lookup</span><span class="fu">,</span> <span class="va">Key</span><span class="fu">},</span> <span class="va">From</span><span class="fu">,</span> <span class="va">Dict</span><span class="fu">)</span> <span class="op">-&gt;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span><span class="ch">reply</span><span class="fu">,</span> <span class="fu">dict:find(</span><span class="va">Key</span><span class="fu">,</span> <span class="va">Dict</span><span class="fu">),</span> <span class="va">Dict</span><span class="fu">}.</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_cast(</span><span class="ch">stop</span><span class="fu">,</span> <span class="va">Dict</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">stop</span><span class="fu">,</span> <span class="ch">normal</span><span class="fu">,</span> <span class="va">Dict</span><span class="fu">}.</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="fu">terminate(</span><span class="va">Reason</span><span class="fu">,</span> <span class="va">Dict</span><span class="fu">)</span> <span class="op">-&gt;</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">io:format(</span><span class="st">&quot;K-V server terminating~n&quot;</span><span class="fu">).</span></span></code></pre></div>
<p>This is an implementation of the <code>gen_server</code>
behaviour/interface. Notice how <code>handle_call</code> updates the
state (<code>Dict</code>) in case of a <code>store</code> and
<code>lookup</code>s the key in the state. Once <code>gen_server</code>
is given this implementation it will provide a server which can handle
concurrent <code>store</code> and <code>lookup</code> requests,
similarly to how <code>Greet</code> provided the displaying
functionality.</p>
<p>At this point you might be thinking “OK, so what? Lots of programming
languages have interfaces…”. That’s true, but notice how
<code>handle_call</code> is completely sequential, i.e. all concurrency
is hidden away in the generic <code>gen_server</code> component. “Yeah,
but that’s just good engineering practice which can be done in any
language” you say. That’s true as well, but the thesis pushes this idea
quite far. It identifies six behaviours: <code>gen_server</code>,
<code>gen_event</code>, <code>gen_fsm</code>, <code>supervisor</code>,
<code>application</code>, and <code>release</code> and then says these
are enough to build reliable distributed systems. As a case study Joe
uses one of Ericsson’s telephone switches (p. 157):</p>
<blockquote>
<p>When we look at the AXD301 project in chapter 8, we will see that
there were 122 instances of gen_server, 36 instances of gen_event and 10
instances of gen_fsm. There were 20 supervisors and 6 applications. All
this is packaged into one release.</p>
</blockquote>
<p>Joe gives several arguments for why behaviour should be used
(pp. 157-158):</p>
<ol type="1">
<li><p>The application programmer only has to provide the part of the
code which defines the <em>semantics</em> (or “business logic”) of their
problem, while the <em>infrastructure</em> code is provided
automatically by the behaviour;</p></li>
<li><p>The application programmer writes sequential code, all
concurrency is hidden away in the behaviour;</p></li>
<li><p>Behaviours are written by experts, and based on years of
experience and represent “best practices”;</p></li>
<li><p>Easier for new team members to get started: business logic is
sequential, similar structure that they might have seen before
elsewhere;</p></li>
<li><p>If whole systems are implemented reusing a small set of
behaviours: as behaviour implementations improve the whole systems will
improve without requiring any code changes;</p></li>
<li><p>Sticking to only using behaviours enforces structure, which in
turn makes testing and formal verification much easier.</p></li>
</ol>
<p>We’ll come back to this last point about testing later.</p>
</section>
<section id="event-manager-behaviour" class="level3">
<h3><a href="#event-manager-behaviour"
title="Event manager behaviour">Event manager behaviour</a></h3>
<p>Lets come back to the behaviours we listed above first. We looked at
<code>gen_server</code>, but what are the others for? There’s
<code>gen_event</code> which is a generic event manager, which lets you
register event handlers that are then run when the event manager gets
messages associated with the handlers. Joe says this is useful for,
e.g., error logging and gives the following example of an simple logger
(p. 142):</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">-module</span><span class="fu">(</span><span class="ch">simple_logger</span><span class="fu">).</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fu">behaviour(</span><span class="ch">gen_event</span><span class="fu">).</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">-export</span><span class="fu">([</span><span class="ch">start</span><span class="op">/</span><span class="dv">0</span><span class="fu">,</span> <span class="ch">stop</span><span class="op">/</span><span class="dv">0</span><span class="fu">,</span> <span class="ch">log</span><span class="op">/</span><span class="dv">1</span><span class="fu">,</span> <span class="ch">report</span><span class="op">/</span><span class="dv">0</span><span class="fu">]).</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">-export</span><span class="fu">([</span><span class="ch">init</span><span class="op">/</span><span class="dv">1</span><span class="fu">,</span> <span class="ch">terminate</span><span class="op">/</span><span class="dv">2</span><span class="fu">,</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>         <span class="ch">handle_event</span><span class="op">/</span><span class="dv">2</span><span class="fu">,</span> <span class="ch">handle_call</span><span class="op">/</span><span class="dv">2</span><span class="fu">]).</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">-define</span><span class="fu">(</span><span class="va">NAME</span><span class="fu">,</span> <span class="ch">my_simple_event_logger</span><span class="fu">).</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="fu">start()</span> <span class="op">-&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> <span class="fu">gen_event:start_link({</span><span class="ch">local</span><span class="fu">,</span> <span class="fu">?</span><span class="va">NAME</span><span class="fu">})</span> <span class="kw">of</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="va">Ret</span> <span class="op">=</span> <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span> <span class="va">Pid</span><span class="fu">}</span> <span class="op">-&gt;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">gen_event:add_handler(?</span><span class="va">NAME</span><span class="fu">,?</span><span class="va">MODULE</span><span class="fu">,</span><span class="ch">arg1</span><span class="fu">),</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>      <span class="va">Ret</span><span class="fu">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="va">Other</span> <span class="op">-&gt;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">Other</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span><span class="fu">.</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="fu">stop()</span> <span class="op">-&gt;</span> <span class="fu">gen_event:stop(?</span><span class="va">NAME</span><span class="fu">).</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="fu">log(</span><span class="va">E</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">gen_event:notify(?</span><span class="va">NAME</span><span class="fu">,</span> <span class="fu">{</span><span class="ch">log</span><span class="fu">,</span> <span class="va">E</span><span class="fu">}).</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="fu">report()</span> <span class="op">-&gt;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gen_event:call(?</span><span class="va">NAME</span><span class="fu">,</span> <span class="fu">?</span><span class="va">MODULE</span><span class="fu">,</span> <span class="ch">report</span><span class="fu">).</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="fu">init(</span><span class="ch">arg1</span><span class="fu">)</span> <span class="op">-&gt;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">io:format(</span><span class="st">&quot;Logger starting~n&quot;</span><span class="fu">),</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span> <span class="fu">[]}.</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_event({</span><span class="ch">log</span><span class="fu">,</span> <span class="va">E</span><span class="fu">},</span> <span class="va">S</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span> <span class="fu">trim([</span><span class="va">E</span><span class="fu">|</span><span class="va">S</span><span class="fu">])}.</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="fu">handle_call(</span><span class="ch">report</span><span class="fu">,</span> <span class="va">S</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span> <span class="va">S</span><span class="fu">,</span> <span class="va">S</span><span class="fu">}.</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="fu">terminate(</span><span class="ch">stop</span><span class="fu">,</span> <span class="va">_</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="ch">true</span><span class="fu">.</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="fu">trim([</span><span class="va">X1</span><span class="fu">,</span><span class="va">X2</span><span class="fu">,</span><span class="va">X3</span><span class="fu">,</span><span class="va">X4</span><span class="fu">,</span><span class="va">X5</span><span class="fu">|</span><span class="va">_</span><span class="fu">])</span> <span class="op">-&gt;</span> <span class="fu">[</span><span class="va">X1</span><span class="fu">,</span><span class="va">X2</span><span class="fu">,</span><span class="va">X3</span><span class="fu">,</span><span class="va">X4</span><span class="fu">,</span><span class="va">X5</span><span class="fu">];</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="fu">trim(</span><span class="va">L</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="va">L</span><span class="fu">.</span></span></code></pre></div>
<p>The interesting part is <code>handle_event</code>, <code>trim</code>
and <code>report</code>. Together they let the user log, keep track and
display the last five error messages.</p>
</section>
<section id="state-machine-behaviour" class="level3">
<h3><a href="#state-machine-behaviour"
title="State machine behaviour">State machine behaviour</a></h3>
<p>The <code>gen_fsm</code> behavior has been renamed to
<code>gen_statem</code> (for state machine) since thesis was written.
It’s very similar to <code>gen_server</code>, but more geared towards
implementing protocols, which often are specified as state machines. I
believe any <code>gen_server</code> can be implemented as a
<code>gen_statem</code> and vice versa so we won’t go into the details
of <code>gen_statem</code>.</p>
</section>
<section id="supervisor-behaviour" class="level3">
<h3><a href="#supervisor-behaviour"
title="Supervisor behaviour">Supervisor behaviour</a></h3>
<p>The next interesting behavior is <code>supervisor</code>. Supervisors
are processes which sole job is to make sure that other processes are
healthy and doing their job. If a supervised process fails then the
supervisor can restart it according to some predefined strategy. Here’s
an example due to Joe (p. 148):</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">-module</span><span class="fu">(</span><span class="ch">simple_sup</span><span class="fu">).</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fu">behaviour(</span><span class="ch">supervisor</span><span class="fu">).</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">-export</span><span class="fu">([</span><span class="ch">start</span><span class="op">/</span><span class="dv">0</span><span class="fu">,</span> <span class="ch">init</span><span class="op">/</span><span class="dv">1</span><span class="fu">]).</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">start()</span> <span class="op">-&gt;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">supervisor:start_link({</span><span class="ch">local</span><span class="fu">,</span> <span class="ch">simple_supervisor</span><span class="fu">},</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">?</span><span class="va">MODULE</span><span class="fu">,</span> <span class="ch">nil</span><span class="fu">).</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="fu">init(</span><span class="va">_</span><span class="fu">)</span> <span class="op">-&gt;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{</span><span class="ch">ok</span><span class="fu">,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">{{</span><span class="ch">one_for_one</span><span class="fu">,</span> <span class="dv">5</span><span class="fu">,</span> <span class="dv">1000</span><span class="fu">},</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">[</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>   <span class="fu">{</span><span class="ch">packet</span><span class="fu">,</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>     <span class="fu">{</span><span class="ch">packet_assembler</span><span class="fu">,</span> <span class="ch">start</span><span class="fu">,</span> <span class="fu">[]},</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>     <span class="ch">permanent</span><span class="fu">,</span> <span class="dv">500</span><span class="fu">,</span> <span class="ch">worker</span><span class="fu">,</span> <span class="fu">[</span><span class="ch">packet_assembler</span><span class="fu">]},</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>   <span class="fu">{</span><span class="ch">server</span><span class="fu">,</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>     <span class="fu">{</span><span class="ch">kv</span><span class="fu">,</span> <span class="ch">start</span><span class="fu">,</span> <span class="fu">[]},</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>     <span class="ch">permanent</span><span class="fu">,</span> <span class="dv">500</span><span class="fu">,</span> <span class="ch">worker</span><span class="fu">,</span> <span class="fu">[</span><span class="ch">kv</span><span class="fu">]},</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>   <span class="fu">{</span><span class="ch">logger</span><span class="fu">,</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>     <span class="fu">{</span><span class="ch">simple_logger</span><span class="fu">,</span> <span class="ch">start</span><span class="fu">,</span> <span class="fu">[]},</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>     <span class="ch">permanent</span><span class="fu">,</span> <span class="dv">500</span><span class="fu">,</span> <span class="ch">worker</span><span class="fu">,</span> <span class="fu">[</span><span class="ch">simple_logger</span><span class="fu">]}]}}.</span></span></code></pre></div>
<p>The <code>{one_for_one, 5, 1000}</code> is the restart strategy. It
says that if one of the supervised processes
(<code>packet_assembler</code>, <code>kv</code>, and
<code>simple_logger</code>) fail then only restart the failing process
(<code>one_for_one</code>). If the supervisor needs to restart more than
<code>5</code> times in <code>1000</code> seconds then the supervisor
itself should fail.</p>
<p>The <code>permanent, 500, worker</code> part means that this is a
worker process which should be permanently kept alive and its given 500
milliseconds to gracefully stop what it’s doing in case the supervisor
wants to restart it.</p>
<p>“Why would the supervisor want to restart it if it’s not dead
already?”, one might wonder. Well, there are other restart strategies
than <code>one_for_one</code>. For example, <code>one_for_all</code>
where if one process fails then the supervisor restarts all of its
children.</p>
<p>If we also consider that supervisors can supervise supervisors, which
are not necessarily running on the same computer, then I hope that you
get an idea of how powerful this behaviour can be. And, no, this isn’t
“just Kubernetes”, because it’s at the thread/lightweight process level
rather than docker container level.</p>
<p>The idea for supervisors and their restart strategies comes from the
observation that often a restart appears to fix the problem, as captured
in the <em>Have You Tried Turning It Off And On Again?</em> sketches
from IT Crowd.</p>
<p>Knowing that failing processes will get restarted coupled with Jim
Gray’s idea of failing fast, that’s either produce the output according
to the specification or signal failure and stop operating, leads to
Joe’s slogan: “Let it crash!” (p. 107). Another way to think of it is
that a program should only express its “happy path”, should anything go
wrong on its happy way it should crash, rather than trying to be clever
about it and try to fix the problem (potentially making it worse), and
another program higher up the supervisor tree will handle it.</p>
<p>Supervisors and the “let it crash” philosophy, appear to produce
reliable systems. Joe uses the Ericsson AXD301 telephone switch example
again (p. 191):</p>
<blockquote>
<p>Evidence for the long-term operational stability of the system had
also not been collected in any systematic way. For the Ericsson AXD301
the only information on the long-term stability of the system came from
a power-point presentation showing some figures claiming that a major
customer had run an 11 node system with a 99.9999999% reliability,
though how these figure had been obtained was not documented.</p>
</blockquote>
<p>To put this in perspective, five nines (99.999%) reliability is
considered good (5.26 minutes of downtime per year). “59% of Fortune 500
companies experience a minimum of 1.6 hours of downtime per week”,
according to some <a
href="https://courseware.cutm.ac.in/wp-content/uploads/2020/06/Assessing-the-Financial-Impact-of-Downtime-UK.pdf">report</a>
from a biased company. Notice per <em>year</em> vs per <em>week</em>,
but as we don’t know how either reliability numbers are obtained its
probably safe to assume that the truth is somewhere in the middle –
still a big difference, but not 31.56 milliseconds (nine nines) of
downtime per year vs 1.6 hours of downtime per week.</p>
</section>
<section id="application-and-release-behaviours" class="level3">
<h3><a href="#application-and-release-behaviours"
title="Application and release behaviours">Application and release
behaviours</a></h3>
<p>I’m not sure if <code>application</code> and <code>release</code>
technically are behaviours, i.e. interfaces. They are part of the same
chapter as the other behaviours in the thesis and they do provide a
clear structure which is a trait of the other behaviours though, so
we’ll include them in the discussion.</p>
<p>So far we’ve presented behaviours from the bottom up. We started with
“worker” behaviours <code>gen_server</code>, <code>gen_statem</code> and
<code>gen_event</code> which together capture the semantics of our
problem. We then saw how we can define <code>supervisor</code> trees
whose children are other supervisor trees or workers, to deal with
failures and restarts.</p>
<p>Next level up is an <code>application</code> which consists of a
supervisor tree together with everything else we need to deliver a
particular application.</p>
<p>A system can consist of several <code>application</code> and that’s
where the final “behaviour” comes in. A <code>release</code> packages up
one or more applications. They also contain code to handle upgrades. If
the upgrade fails, it must be able to rollback to the previous stable
state.</p>
</section>
</section>
<section id="how-behaviours-can-be-implemented" class="level2">
<h2><a href="#how-behaviours-can-be-implemented"
title="How behaviours can be implemented">How behaviours can be
implemented</a></h2>
<p>I hope that by now I’m managed to convince you that it’s not actually
the lightweight processes and message passing by themselves that make
Erlang great for building reliable systems.</p>
<p>At best one might be able to claim that lightweight processes and
supervisors are the key mechanisms at play<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>,
but I think it would be more honest to recognise the structure that
behaviours provide and how that ultimately leads to reliable
software.</p>
<p>I’ve not come across any other language, library, or framework which
provides such relatively simple building blocks that compose into big
systems like the AXD301 (“over a million lines of Erlang code”,
p. 167).</p>
<p>This begs the question: why aren’t language and library designers
stealing the structure behind Erlang’s behaviours, rather than copying
the ideas of lightweight processes and message passing?</p>
<p>Let’s take a step back. We said earlier that behaviours are
interfaces and many programming languages have interfaces. How would we
go about starting to implement behaviours in other languages?</p>
<p>Lets start with <code>gen_server</code>. I like to think its
interface signature as being:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> (<span class="dt">State</span>, <span class="dt">Output</span>)</span></code></pre></div>
<p>That’s it takes some input, its current state and produces a pair of
the new updated state and an output.</p>
<p>How do we turn this sequential signature into something that can
handle concurrent requests? One way would be to fire up a HTTP server
which transforms requests into <code>Input</code>s and puts them on a
queue, have an event loop which pops inputs from the queue and feeds it
to the sequential implementation, then writing the output back to the
client response. It wouldn’t be difficult to generalise this to be able
to handle multiple <code>gen_server</code>s at the same time, by giving
each a name and let the request include the name in addition to the
input.</p>
<p><code>gen_event</code> could be implemented by allowing registration
of callbacks to certain types of event on the queue.</p>
<p><code>supervisor</code>s is more interesting, one simple way to think
of it is: when we feed the <code>gen_server</code> function the next
input from the queue, we wrap that call in an exception handler, and
should it throw we notify its supervisor. It gets a bit more complicated
if the supervisor is not running on the same computer as the
<code>gen_server</code>.</p>
<p>I haven’t thought about <code>application</code> and
<code>release</code>s much yet, but given that configuration, deployment
and upgrades are difficult problems they seem important.</p>
</section>
<section id="correctness-of-behaviours" class="level2">
<h2><a href="#correctness-of-behaviours"
title="Correctness of behaviours">Correctness of behaviours</a></h2>
<p>Writing a post solely about stealing from Erlang doesn’t seem fair,
even though it’s the right thing to do, so I’d like to finish off with
how we can build upon the insights of Joe and the Erlang community.</p>
<p>I’ve been interesting in testing for a while now. Most recently I’ve
been looking into <a
href="https://github.com/stevana/property-based-testing-stateful-systems-tutorial">simulation
testing</a> distributed systems à la <a
href="https://www.youtube.com/watch?v=4fFDFbi3toc">FoundationDB</a>.</p>
<p>Simulation testing in a nutshell is running your system in a
simulated world, where the simulation has full control over which
messages get sent when over the network.</p>
<p>FoundationDB built their own programming language, or dialect of C++
with actors, in order do the simulation testing. Our team seemed to be
able to get quite far with merely using state machines of type:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> (<span class="dt">State</span>, [<span class="dt">Output</span>])</span></code></pre></div>
<p>where <code>[Output]</code> is a sequence of outputs.</p>
<p>The idea being that the simulator keeps track of a priority queue of
messages sorted by their arrival time, it pops a message, advances the
clock to the arrival time of that message, feeds the message to the
receiving state machine, generates new arrival times for all output
messages and puts them back into the priority queue, rinse and repeat.
As long as everything is deterministic and the arrival times are
generated using a seed we can explore many different interleavings and
get reproducible failures. It’s also much faster than Jepsen, because
messaging is done in-memory and we advance the clock to the arrival
time, thereby triggering any timeouts without having to wait for
them.</p>
<p>We used to say that programs of this state machine type where written
in “network normal form”, and conjectured that every program which can
receive and send stuff over the network can be refactored into this
shape<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>. Even if we had a proof, “network
normal form” always felt a bit arbitrary. But then I read Joe’s thesis
and realised that <code>gen_server</code> and <code>gen_statem</code>
basically have the same type, so I stopped being concerned about it. As
I think that if a structure is found to be useful by different people,
then it’s usually a sign that it isn’t arbitrary.</p>
<p>Anyway, in, at least, one of Joe’s <a
href="https://youtu.be/cNICGEwmXLU?t=1439">talks</a> he mentions how
difficult it’s to correctly implement distributed leader election.</p>
<p>I believe this is a problem that would be greatly simplified by
having access to a simulator. A bit like I’d imagine having access to a
wind tunnel would make building an airplane easier. Both lets you test
your system under extreme conditions, such as unreliable networking or
power loss, before they happen in “production”. Furthermore, this
simulator can be generic in, or parametrised by, behaviours. Which means
that the developer gets it for free while the complexity of the
simulator is hidden away, just like the concurrent code of
<code>gen_server</code>!</p>
<p>FoundationDB is a good example of simulation testing working, as
witnessed by this <a
href="https://twitter.com/aphyr/status/405017101804396546">tweet</a>
where somebody asked Kyle “aphyr” Kingsbury to Jepsen test
FoundationDB:</p>
<blockquote>
<p>“haven’t tested foundation[db] in part because their testing appears
to be waaaay more rigorous than mine.”</p>
</blockquote>
<p>Formal verification is also made easier if the program is written a
state machine. Basically all of Lamport’s model checking <a
href="https://www.microsoft.com/en-us/research/publication/computation-state-machines/">work</a>
with TLA+ assumes that the specification is a state machine. Also more
recently Kleppmann has <a
href="https://lawrencecpaulson.github.io/2022/10/12/verifying-distributed-systems-isabelle.html">shown</a>
how to exploit the state machine structure to do proof by (structural)
induction to solve the state explosion problem.</p>
<p>So there you have it, we’ve gone full circle. We started by taking
inspiration from Joe and Erlang’s behaviours, and ended up using the
structure of the <code>gen_server</code> behaviour to make it easier to
solve a problem that Joe used to have.</p>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>There are a bunch of related ideas that I have started working
on:</p>
<ul>
<li>Stealing ideas from Martin Thompson’s work on the LMAX Disruptor and
<a href="https://github.com/real-logic/aeron">aeron</a> to <a
href="https://github.com/stevana/pipelined-state-machines">make</a> a
fast event loop, on top of which the behaviours run;</li>
<li>Enriching the state machine type with <a
href="https://github.com/stevana/coroutine-state-machines">async
I/O</a>;</li>
<li>How to implement <a
href="https://github.com/stevana/supervised-state-machines">supervisors</a>
in more detail;</li>
<li>Hot code <a
href="https://github.com/stevana/hot-swapping-state-machines">swapping</a>
of state machines.</li>
</ul>
<p>Feel free to get in touch, if you find any of this interesting and
would like to get involved, or if you have have comments, suggestions or
questions.</p>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li>Chapter 6.1 on behaviours in Joe Armstrong’s <a
href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-1166">thesis</a>,
p. 129;</li>
<li><a
href="https://www.erlang.org/doc/design_principles/des_princ.html">OTP
design principles</a>;</li>
<li>The documentation for behaviours:
<ul>
<li><a
href="https://www.erlang.org/doc/man/gen_server.html"><code>gen_server</code></a>;</li>
<li><a
href="https://www.erlang.org/doc/man/gen_event.html"><code>gen_event</code></a>;</li>
<li><a
href="https://www.erlang.org/doc/man/gen_statem.html"><code>gen_statem</code></a>;</li>
<li><a
href="https://www.erlang.org/doc/man/supervisor.html"><code>supervisor</code></a>;</li>
<li><a
href="https://www.erlang.org/doc/man/application.html"><code>application</code></a>;</li>
<li><a
href="https://www.erlang.org/doc/design_principles/release_structure.html">release</a>.</li>
</ul></li>
<li><a href="https://youtube.com/watch?v=7erJ1DV_Tlo">Hewitt, Meijer and
Szyperski: The Actor Model (everything you wanted to know, but were
afraid to ask)</a> (2012);</li>
<li>Erlang the <a
href="https://www.youtube.com/watch?v=xrIjfIjssLE">movie</a>
(1990);</li>
<li><a href="https://www.youtube.com/watch?v=cNICGEwmXLU">Systems that
run forever self-heal and scale</a> by Joe Armstrong (Strange Loop,
2013);</li>
<li><a href="https://www.youtube.com/watch?v=TTM_b7EJg5E">The Do’s and
Don’ts of Error Handling</a> by Joe Armstrong (GOTO, 2018);</li>
<li><a href="https://ferd.ca/the-zen-of-erlang.html">The Zen of
Erlang</a> by Fred Hebert (2016);</li>
<li><a
href="https://ferd.ca/the-hitchhiker-s-guide-to-the-unexpected.html">The
Hitchhiker’s Guide to the Unexpected</a> by Fred Hebert (2018);</li>
<li><a href="https://www.hpl.hp.com/techreports/tandem/TR-85.7.pdf">Why
Do Computers Stop and What Can Be Done About It?</a> by Jim Gray
(1985);</li>
<li>The supervision trees chapter of <a
href="https://adoptingerlang.org/docs/development/supervision_trees/"><em>Adopting
Erlang</em></a> (2019);</li>
<li>“If there’s one thing I’d say to the Erlang folks, it’s you got the
stuff right from a high-level, but you need to invest in your messaging
infrastructure so it’s super fast, super efficient and obeys all the
right properties to let this stuff work really well.” <a
href="https://youtu.be/OqsAGFExFgQ?t=2532">quote</a> by Martin Thompson
(Functional Conf, 2017).</li>
</ul>
</section>
<section id="discussion" class="level2">
<h2><a href="#discussion" title="Discussion">Discussion</a></h2>
<ul>
<li><a href="https://news.ycombinator.com/item?id=34545061">Hacker
News</a></li>
<li><a
href="https://lobste.rs/s/7dguth/erlang_s_not_about_lightweight_processes">lobste.rs</a></li>
<li><a
href="https://old.reddit.com/r/programming/comments/10mt6hz/erlangs_not_about_lightweight_processes_and/">r/programming</a></li>
<li><a
href="https://old.reddit.com/r/haskell/comments/10mgd0a/erlangs_not_about_lightweight_processes_and/">r/haskell</a></li>
<li><a
href="https://old.reddit.com/r/erlang/comments/10g0zbg/erlangs_not_about_lightweight_processes_and/">r/erlang</a></li>
<li><a
href="https://elixirforum.com/t/erlangs-not-about-lightweight-processes-and-message-passing/53484/7">Elixir
Forum</a></li>
</ul>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>From Joe Armstrong’s thesis (p. 6):</p>
<blockquote>
<p>In February 1998 Erlang was banned for new product development within
Ericsson—the main reason for the ban was that Ericsson wanted to be a
consumer of sodware technologies rather than a producer.</p>
</blockquote>
<p>From Bjarne Däcker’s thesis (2000, p. 37):</p>
<blockquote>
<p>In February 1998, Erlang was banned within Ericsson Radio AB (ERA)
for new product projects aimed for external customers because:</p>
<p>“The selection of an implementation language implies a more long-term
commitment than selection of processors and OS, due to the longer life
cycle of implemented products. Use of a proprietary language, implies a
continued effort to maintain and further develop the support and the
development environment. It further implies that we cannot easily
benefit from, and find synergy with, the evolution following the large
scale deployment of globally used languages.”</p>
</blockquote>
<p>Joe also says, in this <a href="https://vimeo.com/97329186">talk</a>
(34:30), that there were two reasons for Erlang getting banned: 1) that
it wasn’t Java, and 2) that it wasn’t C++.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>It’s a common misconception is that Erlang is about
actors.</p>
<p>The actor model first presented in <a
href="https://www.ijcai.org/Proceedings/73/Papers/027B.pdf"><em>A
Universal Modular Actor Formalism for Artificial Intelligence</em></a>
by Carl Hewitt, Peter Bishop, Richard Steiger (1973) and refined by
others over time, e.g. see Irene Greif’s <a
href="https://dspace.mit.edu/handle/1721.1/57710">thesis</a> (1975) or
Gul Agha’s <a
href="https://dspace.mit.edu/handle/1721.1/6952">thesis</a> (1985).</p>
<p>Erlang first appeard later in 1986, but the Erlang developers were <a
href="https://erlang.org/pipermail/erlang-questions/2014-June/079794.html">not
aware</a> of the actor model. In fact Robert Virding, one of the
original Erlang designers, <a
href="https://erlang.org/pipermail/erlang-questions/2014-June/079865.html">claims</a>
that knowing about the actor model might even have slowed them down.</p>
<p>Carl Hewitt has written a paper called <a
href="https://arxiv.org/abs/1008.1459"><em>Actor Model of Computation:
Scalable Robust Information Systems</em></a> (2015) which documents the
differences between Erlang’s processes and the actor model.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Scala’s Akka seems to be of this opinion. They got
something they call “actors”, not to be confused with the actor model as
per footnote 1, and obligatory supervisors trees. They don’t appear to
have any analogues of the other Erlang behaviours though.</p>
<p>Confusingly Akka has a concept called <a
href="https://doc.akka.io/docs/akka/current/general/actors.html#behavior">“behavior”</a>,
but it has nothing to do with Erlang behaviours.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>The intuition being that since every program using the
state monad can be rewritten to a normal form where a single
<code>read</code>/<code>get</code> followed by a single
<code>write</code>/<code>put</code>, it seems reasonable to assume that
something similar would work for <code>recv</code> and <code>send</code>
over the network. I forget the reference for the state monad normal
form, either Plotkin and Power or Uustalu?<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></description>
      <category>Development</category>
    </item>

    <item>
      <title>Working with binary data</title>
      <link>https://stevana.github.io/working_with_binary_data.html</link>
      <guid>https://stevana.github.io/working_with_binary_data.html</guid>
      <pubDate>Wed, 11 Jan 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>Towards human-readable binary encodings</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#erlangs-bit-syntax" id="toc-erlangs-bit-syntax">Erlang’s
bit syntax</a></li>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#how-it-works" id="toc-how-it-works">How it works</a></li>
<li><a href="#extending-erlangs-bit-syntax"
id="toc-extending-erlangs-bit-syntax">Extending Erlang’s bit syntax</a>
<ul>
<li><a href="#in-place-updates" id="toc-in-place-updates">In-place
updates</a></li>
<li><a href="#on-disk-data-structures"
id="toc-on-disk-data-structures">On-disk data structures</a></li>
<li><a href="#zero-copy" id="toc-zero-copy">Zero-copy</a></li>
<li><a href="#backward--and-forward-compatiability-and-migrations"
id="toc-backward--and-forward-compatiability-and-migrations">Backward-
and forward-compatiability and migrations</a></li>
<li><a href="#compression" id="toc-compression">Compression</a></li>
<li><a href="#checksums" id="toc-checksums">Checksums</a></li>
<li><a href="#validation" id="toc-validation">Validation</a></li>
<li><a href="#protocols" id="toc-protocols">Protocols</a></li>
<li><a href="#pandoc-for-binary-encodings"
id="toc-pandoc-for-binary-encodings">Pandoc for binary
encodings</a></li>
</ul></li>
<li><a href="#discussion" id="toc-discussion">Discussion</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
</ul>
</nav>
<div class="date">Posted on Jan 11, 2023</div>
<p>Can we make binary encodings “human-readable”? This post explores
this question by means of implementing a library inspired by Erlang’s
bit syntax.</p>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>JSON is probably the most commonly used format for serialising data
today. A frequent argument for using it is that JSON is
human-readable.</p>
<p>What does that mean exactly? I suppose that people usually mean two
things. First, it’s less verbose than XML, making it easier to read.
Most people would probably still call XML human-readable, but arguebly
less so than JSON. Second, it’s easier to read than binary encodings
produced by MessagePack, ASN.1 or Protobuf, etc. For example, the JSON
string <code>"foo"</code> is represented by the following byte sequence
when using MessagePack:</p>
<pre><code>                 +------------ A string of length 3 consisting of ...
                 |  +--------- ... the character &#39;f&#39;, following by ...
                 |  |  +--+--- ... two &#39;o&#39; characters.
                 |  |  |  |
                 v  v  v  v
                 a3 66 6f 6f</code></pre>
<p>If we were to open a file with the above bytes or echo them to the
terminal we’d see <code>£foo</code>. Which, while one character
shorter<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> than the JSON string, is starting to
become unreadable already and it will become worse once the JSON object
is more complicated.</p>
<p>It’s worth noting that all serialised data ends up being bytes once
on disk or sent over the network. So in a sense one could argue that the
reason JSON is human-readable, is because these bytes get displayed as
ASCII or UTF-8 by our editors and the standard terminal utilities.
Another way to think about it is that ASCII and UTF-8 are encodings as
well, which would be unreadable without tool support. This isn’t a new
argument, people like <a
href="https://youtu.be/ieEaaofM7uU?list=PL_aCdZH3eJJVki0YqHbJtqZKSmcbXH0jP&amp;t=28">Joe
Armstrong</a> and <a href="https://youtu.be/qDhTjE0XmkE?t=2280">Martin
Thompson</a> have separately and on <a
href="https://youtu.be/rQIE22e0cW8?t=2003">multiple</a> occasions
pointed this out. Both stress that we are <a
href="https://youtu.be/bzDAYlpSbrM?t=1481">wasting</a> massive amounts
of CPU cycles on parsing JSON.</p>
<p>It’s not just that it’s less space efficient, as we saw with
<code>"foo"</code> vs <code>£foo</code>, it’s also because with JSON we
need to inspect every single character after the first <code>"</code> in
order to determine when the string ends, i.e. finding the closing
<code>"</code>. Whereas in, for example, the MessagePack case the length
of the string is encoded in the <code>a3</code> byte so we can jump
forward and just copy the three bytes (without looking at them). Joe
calls this <em>reconstructing</em> as opposed to parsing.</p>
<p>So if JSON is merely human-readable because of our application-level
tooling, this raises the question: what would it take to make binary
encodings “human-readable”?</p>
<p>For starters I think we’d need to make it easier to work with binary
data in our programming languages. I believe Erlang’s bit syntax, which
lets us do bit-level pattern-matching, is a good example of what better
language support for working with binary data looks like. Even though
Erlang’s way ahead most programming languages on this front, there are
important use cases which are not possible to express efficiently using
bit syntax though, e.g. in-place updates, leaving more to be
desired.</p>
<p>In the rest of this post we’ll have first have a look at how Erlang’s
bit syntax works, then we’ll turn to its shortcomings and try to start
addressing them by means of implementing a library.</p>
</section>
<section id="erlangs-bit-syntax" class="level2">
<h2><a href="#erlangs-bit-syntax" title="Erlang’s bit syntax">Erlang’s
bit syntax</a></h2>
<p>Erlang has a feature called bit syntax which allows the user to
encode and decode data at the bit-level. Here’s an example, where we
encode three integers into two bytes:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="op">&gt;</span>​ <span class="va">Red</span> <span class="op">=</span> <span class="dv">2</span><span class="fu">.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span><span class="op">&gt;</span>​ <span class="va">Green</span> <span class="op">=</span> <span class="dv">61</span><span class="fu">.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dv">61</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span><span class="op">&gt;</span>​ <span class="va">Blue</span> <span class="op">=</span> <span class="dv">20</span><span class="fu">.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span><span class="op">&gt;</span>​ <span class="va">Mem</span> <span class="op">=</span> <span class="op">&lt;&lt;</span><span class="va">Red</span><span class="fu">:</span><span class="dv">5</span><span class="fu">,</span> <span class="va">Green</span><span class="fu">:</span><span class="dv">6</span><span class="fu">,</span> <span class="va">Blue</span><span class="fu">:</span><span class="dv">5</span><span class="op">&gt;&gt;</span><span class="fu">.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="dv">23</span><span class="fu">,</span><span class="dv">180</span><span class="op">&gt;&gt;</span></span></code></pre></div>
<p>Normally, even the smallest integer takes up one byte
(e.g. <code>char</code> in C or <code>Int8</code> in Haskell) but
Erlang’s bit syntax lets us encode, e.g., <code>Red</code> using only 5
bits (rather than the default 8 bits) and thus we can fit all three
integers in <span class="math inline">5 + 6 + 5 = 16</span> bits or two
bytes.</p>
<p>We can also pattern match at the bit-level using sizes to get our
integers back:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span><span class="op">&gt;</span>​ <span class="op">&lt;&lt;</span><span class="va">R1</span><span class="fu">:</span><span class="dv">5</span><span class="fu">,</span> <span class="va">G1</span><span class="fu">:</span><span class="dv">6</span><span class="fu">,</span> <span class="va">B1</span><span class="fu">:</span><span class="dv">5</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="va">Mem</span><span class="fu">.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="dv">23</span><span class="fu">,</span><span class="dv">180</span><span class="op">&gt;&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span><span class="op">&gt;</span>​ <span class="va">R1</span><span class="fu">.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dv">7</span><span class="op">&gt;</span>​ <span class="va">G1</span><span class="fu">.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dv">61</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dv">8</span><span class="op">&gt;</span>​ <span class="va">B1</span><span class="fu">.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span></span></code></pre></div>
<p>For larger integer types, e.g. <code>0x12345678 :: Int32</code>, we
can also specify the byte order or <a
href="https://en.wikipedia.org/wiki/Endianness">endianness</a>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="op">&gt;</span>​ <span class="fu">{</span><span class="op">&lt;&lt;</span><span class="bn">16#12345678</span><span class="fu">:</span><span class="dv">32</span><span class="op">/</span><span class="ch">big</span><span class="op">&gt;&gt;</span><span class="fu">,</span><span class="op">&lt;&lt;</span><span class="bn">16#12345678</span><span class="fu">:</span><span class="dv">32</span><span class="op">/</span><span class="ch">little</span><span class="op">&gt;&gt;</span><span class="fu">,</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>​<span class="op">&lt;&lt;</span><span class="bn">16#12345678</span><span class="fu">:</span><span class="dv">32</span><span class="op">/</span><span class="ch">native</span><span class="op">&gt;&gt;</span><span class="fu">,</span><span class="op">&lt;&lt;</span><span class="bn">16#12345678</span><span class="fu">:</span><span class="dv">32</span><span class="op">&gt;&gt;</span><span class="fu">}.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span><span class="op">&lt;&lt;</span><span class="dv">18</span><span class="fu">,</span><span class="dv">52</span><span class="fu">,</span><span class="dv">86</span><span class="fu">,</span><span class="dv">120</span><span class="op">&gt;&gt;</span><span class="fu">,</span><span class="op">&lt;&lt;</span><span class="dv">120</span><span class="fu">,</span><span class="dv">86</span><span class="fu">,</span><span class="dv">52</span><span class="fu">,</span><span class="dv">18</span><span class="op">&gt;&gt;</span><span class="fu">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span><span class="dv">120</span><span class="fu">,</span><span class="dv">86</span><span class="fu">,</span><span class="dv">52</span><span class="fu">,</span><span class="dv">18</span><span class="op">&gt;&gt;</span><span class="fu">,</span><span class="op">&lt;&lt;</span><span class="dv">18</span><span class="fu">,</span><span class="dv">52</span><span class="fu">,</span><span class="dv">86</span><span class="fu">,</span><span class="dv">120</span><span class="op">&gt;&gt;</span><span class="fu">}</span></span></code></pre></div>
<p>For a slightly larger example, here’s pattern-matching on an IP
datagram of IP protocol version 4:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode erlang"><code class="sourceCode erlang"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">-define</span>​<span class="fu">(</span><span class="va">IP_VERSION</span><span class="fu">,</span> <span class="dv">4</span><span class="fu">).</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>​<span class="op">-</span><span class="ch">define</span>​<span class="fu">(</span><span class="va">IP_MIN_HDR_LEN</span><span class="fu">,</span> <span class="dv">5</span><span class="fu">).</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">...</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="va">DgramSize</span> <span class="op">=</span> ​<span class="ch">byte_size</span>​<span class="fu">(</span><span class="va">Dgram</span><span class="fu">),</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>​<span class="ch">case</span>​ <span class="va">Dgram</span> ​<span class="ch">of</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;&lt;</span><span class="fu">?</span><span class="va">IP_VERSION</span><span class="fu">:</span><span class="dv">4</span><span class="fu">,</span> <span class="va">HLen</span><span class="fu">:</span><span class="dv">4</span><span class="fu">,</span> <span class="va">SrvcType</span><span class="fu">:</span><span class="dv">8</span><span class="fu">,</span> <span class="va">TotLen</span><span class="fu">:</span><span class="dv">16</span><span class="fu">,</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">ID</span><span class="fu">:</span><span class="dv">16</span><span class="fu">,</span> <span class="va">Flags</span><span class="fu">:</span><span class="dv">3</span><span class="fu">,</span> <span class="va">FragOff</span><span class="fu">:</span><span class="dv">13</span><span class="fu">,</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">TTL</span><span class="fu">:</span><span class="dv">8</span><span class="fu">,</span> <span class="va">Proto</span><span class="fu">:</span><span class="dv">8</span><span class="fu">,</span> <span class="va">HdrChkSum</span><span class="fu">:</span><span class="dv">16</span><span class="fu">,</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">SrcIP</span><span class="fu">:</span><span class="dv">32</span><span class="fu">,</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="va">DestIP</span><span class="fu">:</span><span class="dv">32</span><span class="fu">,</span> <span class="va">RestDgram</span><span class="op">/</span><span class="ch">binary</span><span class="op">&gt;&gt;</span> ​<span class="ch">when</span>​ <span class="va">HLen</span> <span class="op">&gt;=</span> <span class="dv">5</span><span class="fu">,</span> <span class="dv">4</span><span class="op">*</span><span class="va">HLen</span> <span class="op">=&lt;</span> <span class="va">DgramSize</span> <span class="op">-&gt;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">OptsLen</span> <span class="op">=</span> <span class="dv">4</span><span class="op">*</span><span class="fu">(</span><span class="va">HLen</span> <span class="op">-</span> <span class="fu">?</span><span class="va">IP_MIN_HDR_LEN</span><span class="fu">),</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;&lt;</span><span class="va">Opts</span><span class="fu">:</span><span class="va">OptsLen</span><span class="op">/</span><span class="ch">binary</span><span class="fu">,</span><span class="va">Data</span><span class="op">/</span><span class="ch">binary</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="va">RestDgram</span><span class="fu">,</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">...</span></span></code></pre></div>
<p>Note how we can match on the header length, <code>HLen</code>, and
later use the value of that match as the size when pattern matching on
later values.</p>
</section>
<section id="usage" class="level2">
<h2><a href="#usage" title="Usage">Usage</a></h2>
<p>We can implement a library that lets us do similar things to Erlang’s
bit syntax, but in a more clunky way (it’s difficult to beat native
syntax support).</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">BitsAndBobs</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  pattern0    <span class="ot">=</span> sized word32 <span class="dv">5</span> <span class="op">:::</span> sized word32 <span class="dv">6</span> <span class="op">:::</span> sized word32 <span class="dv">5</span> <span class="op">:::</span> <span class="dt">Nil</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  bytestring0 <span class="ot">=</span> byteString [<span class="dv">2</span> <span class="op">:.</span> sized word32 <span class="dv">5</span>, <span class="dv">61</span> <span class="op">:.</span> sized word32 <span class="dv">6</span>, <span class="dv">20</span> <span class="op">:.</span> sized word32 <span class="dv">5</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>bitMatch pattern0 bytestring0</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- =&gt; (2,(61,(20,())))</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  pattern1    <span class="ot">=</span> word8 <span class="op">:&gt;&gt;=</span> \sz <span class="ot">-&gt;</span> sized bytes sz <span class="op">:::</span> bytes <span class="op">:::</span> <span class="dt">Nil</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  bytestring1 <span class="ot">=</span> byteString [<span class="dv">5</span> <span class="op">:.</span> word8, <span class="st">&quot;hello, rest&quot;</span> <span class="op">:.</span> bytes]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>bitMatch pattern1 bytestring1</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- =&gt; (5,(&quot;hello&quot;,(&quot;, rest&quot;,())))</span></span></code></pre></div>
<p>The above is <a
href="https://github.com/stevana/bits-and-bobs/blob/main/src/BitsAndBobs.hs">implemented</a>
in Haskell, but should be straightforward to port to most languages
using the following recipe.</p>
</section>
<section id="how-it-works" class="level2">
<h2><a href="#how-it-works" title="How it works">How it works</a></h2>
<p>The high-level idea when encoding a bunch of, possibly sized, values
into a <code>ByteString</code> is as follows:</p>
<ol type="1">
<li>For each value convert the value into a list of booleans (or
bits);</li>
<li>If the value is sized then only take that many bits, otherwise if it
isn’t sized use the default value, e.g. <code>Int8</code> = 8 bits,
<code>Float</code> = 32 bits, etc;</li>
<li>Concatenate the lists of booleans for each value into a single list
of booleans;</li>
<li>Split the list in groups of 8 bits;</li>
<li>Convert each 8 bits into a byte (<code>UInt8</code>);</li>
<li>Create a <code>ByteString</code> from list of
<code>UInt8</code>s.</li>
</ol>
<p>For decoding or pattern-matching a, possibly sized, pattern against a
<code>ByteString</code> the idea is:</p>
<ol type="1">
<li>Convert <code>ByteString</code> into list of booleans (or
bits);</li>
<li>For each pattern take its size many bits from the list;</li>
<li>Convert the bits into the value type of the pattern;</li>
<li>Continue matching the remaining patterns against the remaining
bits.</li>
</ol>
<p><code>Float</code> and <code>Double</code>s get converted into
<code>UInt32</code> and <code>UInt64</code> respectively before
converted into bits, and <code>Int</code>egers are encoding using <a
href="https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding">zigzag</a>
encoding<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
</section>
<section id="extending-erlangs-bit-syntax" class="level2">
<h2><a href="#extending-erlangs-bit-syntax"
title="Extending Erlang’s bit syntax">Extending Erlang’s bit
syntax</a></h2>
<p>Erlang’s bit syntax makes it possible to decode binary data into the
host languague’s types, which can then be manipulated, and finally
encoded back to binary.</p>
<p>While already useful, it doesn’t cover some interesting use cases.
Let me try to explain the use cases and at the same time sketch possible
ways we can extend Erlang’s bit syntax to cover those.</p>
<section id="in-place-updates" class="level3">
<h3><a href="#in-place-updates" title="In-place updates">In-place
updates</a></h3>
<p>What if we merely want to update some binary in-place without reading
it all in and writing it all back out?</p>
<p>For example, the de facto standard for metadata format for mp3 files
is called <a href="https://en.wikipedia.org/wiki/ID3">ID3</a>. This was
never part of the mp3 specification, but rather added afterwards and so
in order to not break backwards-compatibility with old media players
they added it at the end of the file.</p>
<p>Lets imagine we wanted to write a metadata editor for mp3 files using
Erlang’s bit syntax. I think no matter how smart the Erlang run-time is
about bit syntax, it’s hard to imagine that it wouldn’t need to
deserialse and serialise more data than necessary. Worst case it would
deserialise all of the audio that leads up to where the metadata starts,
but even if it’s somehow clever and starts from the back then we’d still
probably need to at least deserialise all fields preceding the field we
want to update.</p>
<p>Inspired by this problem and how tools like <a
href="https://jemarch.net/poke"><code>poke</code></a> work, I’ve started
another experiment based on <code>Schema</code>s with this use case in
mind, here’s an example session of editing the metadata of an mp3
file:</p>
<pre><code>$ cabal run mp3 -- /tmp/test.mp3

mp3&gt; help
schema | read &lt;field&gt; | write &lt;field&gt; &lt;value&gt; | list | q(uit)

mp3&gt; schema
audio   : Binary
header  : Magic &quot;TAG&quot;
title   : ByteString (Fixed 30)
artist  : ByteString (Fixed 30)
album   : ByteString (Fixed 30)
year    : ByteString (Fixed 4)
comment : ByteString (Fixed 30)
genre   : UInt8

mp3&gt; read title
Unknown

mp3&gt; write title &quot;Bits and Bobs&quot;

mp3&gt; read title
Bits and Bobs

mp3&gt; list
Right (Id3V1 {title = &quot;Bits and Bobs&quot;, artist = &quot;&quot;, album = &quot;&quot;, year = &quot;2023&quot;, comment = &quot;&quot;})
mp3&gt; quit</code></pre>
<p>The user needs to specify the <code>Schema</code>, which is closely
mapped to the ID3v1 specficiation and the rest is provided by the
library. In particular all the offsets to the different fields are
calculated from the schema<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a>, which allow us to jump
straight to the field of interest and <em>reconstruct</em> it without
parsing. The above interactive <a href="app/Main.hs">editor</a> is
completely <a href="src/BitsAndBobs/Editor.hs">generic</a> and works for
any <code>Schema</code>!</p>
<p>If we can read and update fields, it should also be possible to get
<a
href="https://youtu.be/MUb8rD5mPvE?list=PLTj8twuHdQz-JcX7k6eOwyVPDB8CyfZc8&amp;t=830">diffs</a>
and patches for cheap.</p>
</section>
<section id="on-disk-data-structures" class="level3">
<h3><a href="#on-disk-data-structures"
title="On-disk data structures">On-disk data structures</a></h3>
<p>Now that we can edit files in-place on the disk it would be nice to
use this in order to implement on-disk data structures. For example
imagine we’d like to do some kind of logging. If our schemas could
express arrays and records we could define our log to be an a struct
with a length field and an array of records field that of size length.
In addition to extending the schema with arrays and records, we’d also
need atomic increments of the length field so that we can in a
thread-safe manner allocate space in our array. B-trees or <a
href="https://github.com/real-logic/aeron">Aeron’s</a> <a
href="https://aeroncookbook.com/aeron/log-buffers-images/">log
buffers</a> would be other interesting on-disk data structures to
implement.</p>
<p>The generic editor would be useful for debugging and manipulating
such data structures, but we’d probably want more tooling. For logging
we probably want something like <code>cat</code> and <code>grep</code>
but generic in <code>Schema</code>.</p>
</section>
<section id="zero-copy" class="level3">
<h3><a href="#zero-copy" title="Zero-copy">Zero-copy</a></h3>
<p>When we <code>read</code> a <code>ByteString</code> field in the mp3
metadata example above, we copied the bytes from the underlying file.
Sometimes we might want to avoid doing that.</p>
<p>For example imagine we are implementing some network protocol. We can
use a pre-allocated buffer and <a
href="https://linux.die.net/man/2/recv"><code>recv</code></a> bytes from
a socket into this buffer (avoiding allocating memory while handling
requests), once the request is inside our buffer we can decode
individual fields (without parsing) and from that we can determine what
kind of request it is. Let’s imagine it’s some kind of write request
where we want to save the payload of some field to disk. It would be a
waste to copy the bytestring of the payload only to write it disk
immediately after, since the network request consists of raw bytes and
that’s what we want to write to the disk anyway. Instead we’d like to be
able to decode the payload field as a pointer/slice of the buffer which
we pass to <a
href="https://linux.die.net/man/2/write"><code>write</code></a> (thus
avoiding copying aka “zero-copy”).</p>
</section>
<section id="backward--and-forward-compatiability-and-migrations"
class="level3">
<h3><a href="#backward--and-forward-compatiability-and-migrations"
title="Backward- and forward-compatiability and migrations">Backward-
and forward-compatiability and migrations</a></h3>
<p>Another big topic is schema evolution. How can we maintain backward-
and forward-compatibility as our software evolves? We probably want to
be able to migrate old formats into newer ones somehow also.</p>
</section>
<section id="compression" class="level3">
<h3><a href="#compression" title="Compression">Compression</a></h3>
<p>Currently our schemas cannot express how to compress fields on disk,
or how to avoid sending unnecessary data in consecutive network
messages.</p>
<p>An example of the former might be to compress a bytestring field,
using say <a href="https://en.wikipedia.org/wiki/Deflate">deflate</a>,
before writing it to disk. While an example of the former might be to
only send the difference or change of some integer field, instead of
sending the whole integer again. To make things more concrete, lets say
the integer represents epoch time and we send messages several times per
second, then by only sending the difference or <a
href="https://en.wikipedia.org/wiki/Delta_encoding">delta</a> in time
since the last message we can save space. Other examples of compression
include <a
href="https://en.wikipedia.org/wiki/Dictionary_coder">dictionary</a>
compression, <a
href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length
encoding</a>, <a
href="https://en.wikipedia.org/wiki/Apache_Parquet#Bit_packing">bit
packing</a> and <a
href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman
coding</a>.</p>
<p>It would be neat if encoding and decoding fields could be done modulo
compression! Likewise the schema-based <code>cat</code> and
<code>grep</code> could also work modulo compression.</p>
<p>A related topic is storing our data in a row-based or columnar
fashion. Take the example of a logging library we discussed earlier with
a schema that’s an array of records, i.e. each log call adds a new
record to the array. This is nice in terms of writing efficiency, but if
we wanted to do a lot of grepping or some aggregation on some field in
the record then we’d have to jump around a lot in the file (jumping over
the other fields that we are not interested in). It could be more
efficient to restructure our data into a record of arrays instead, where
each array only has data from one field, that way searching or
aggregating over that field would be much more efficient (no jumping
around). Some compression is also a lot easier to apply on columnar
data, e.g. delta and run-length encoding. Perhaps it would make sense if
the schema-based tools could do such data transformations in order to
optimise for reads or archiving?</p>
</section>
<section id="checksums" class="level3">
<h3><a href="#checksums" title="Checksums">Checksums</a></h3>
<p>If we can do encoding and decoding fields modulo compression, why not
also handle checksums transparently? When we update a field which is
part of a checksum, we’d probably want to check the checksum beforehand
and recompute it afterwards.</p>
</section>
<section id="validation" class="level3">
<h3><a href="#validation" title="Validation">Validation</a></h3>
<p>What if some input bytes don’t match the schema? Currently all magic
tags in a schema get verified, but sometimes we might want to be able to
edit incomplete or malformed inputs.</p>
<p>Can we add refinements to the schema which allow us to express things
like, integer between 18 and 150 or bytestring containing only
alphanumeric characters, etc?</p>
</section>
<section id="protocols" class="level3">
<h3><a href="#protocols" title="Protocols">Protocols</a></h3>
<p>So far we’ve looked at how to specify what data our programs use and
how it’s transformed to and from bytes on disk or over the network.
Another important aspect is what protocol is followed when said data is
sent between components in the system.</p>
<p>For example consider some client-server application where our schema
describes the request and responses:</p>
<pre class="mermaid"><code>flowchart LR
    Client -- request --&gt; Server
    Server -- response --&gt; Client</code></pre>
<p>The schema doesn’t say anything about in which order requests are
legal. For example, we might want to always requrie a login-like request
at the start of a session. Or let’s say we are describing a POSIX-like
filesystem API, then <code>read</code>s and <code>write</code>s must
only be made on <code>open</code> (and not yet <code>close</code>d) file
descriptors.</p>
<p>Joe Armstrong wrote a paper called <a
href="https://erlang.org/workshop/2002/Armstrong.pdf"><em>Getting Erlang
to talk to the outside world</em></a> (2002) which discusses this
problem. He proposed a language for describing protocols and a dynamic
sessions type checker, it never seemed to have got much traction though
even though he gave several <a
href="https://youtu.be/ed7A7r6DBsM?t=1071">talks</a> about it. One
implementation can be found <a
href="https://ubf.github.io/ubf/ubf-user-guide.en.html">here</a>.</p>
</section>
<section id="pandoc-for-binary-encodings" class="level3">
<h3><a href="#pandoc-for-binary-encodings"
title="Pandoc for binary encodings">Pandoc for binary encodings</a></h3>
<p>There’s this neat tool called <a
href="https://github.com/jgm/pandoc"><code>pandoc</code></a> that makes
possible to convert between different text formats, e.g. from Markdown
to HTML.</p>
<p>The list of supported formats to convert from and to is pretty long.
If we were to convert to and from each pair of possibilities would
require <span
class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span> <a
href="https://youtu.be/ed7A7r6DBsM?t=2311">work</a>. So what
<code>pandoc</code> does instead is to convert each format to and from
its internal abstract representation, thereby reducing the problem to
<span class="math inline"><em>O</em>(<em>N</em>)</span>.</p>
<p>Could we do something similar for binary encodings?</p>
<p>In the book <em>Development and Deployment of Multiplayer Online
Games, Vol. I</em> by Sergey Ignatchenko (pp. 259-285, 2017) the author
talks about how most <a
href="https://en.wikipedia.org/wiki/Interface_description_language">IDLs</a>,
e.g. Protobufs, have the same language for describing <em>what</em> the
abstract data which we want to serialise and <em>how</em> we actually
want the data to be serialised. By separating the two, we could change
the binary format “on the wire” without changing the application which
operates on the abstract data (the <em>what</em> part). A clearer
separation between IDL and its encoding could perhaps be useful when
trying to solve the <code>pandoc</code> problem for binary.</p>
<p>Another way to think of this is: can we make a DSL for IDLs?</p>
</section>
</section>
<section id="discussion" class="level2">
<h2><a href="#discussion" title="Discussion">Discussion</a></h2>
<ul>
<li><p>Q: Why not just use <a
href="https://en.wikipedia.org/wiki/Protocol_Buffers">Protobuf</a>?</p>
<p>A: Except for backward- and forward-compatibility, I don’t think
Protobufs can handle any of the above listed use cases. Also the way it
handles compatibility with it’s numbered and optional fields is quite
ugly<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p></li>
<li><p>Q: Writing safely to disk without going via a database is almost
impossible!?</p>
<p>A: Dan Luu has <a
href="https://danluu.com/deconstruct-files/">written</a> about <a
href="https://danluu.com/fsyncgate/">this</a> on several <a
href="https://danluu.com/file-consistency/">occasions</a>. Short answer:
don’t store anything you are worried about losing using this library.
Longer answer: I’d like to revisit this topic from the point of view of
testing at some later point in time. In particular I’m interested in how
we can make the results from the paper <a
href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/pillai"><em>All
File Systems Are Not Created Equal: On the Complexity of Crafting
Crash-Consistent Applications</em></a></p>
<ol start="2014" type="1">
<li>more accessible, especially their tool <a
href="https://github.com/madthanu/alice"><em>ALICE: Application-Level
Intelligent Crash Explorer</em></a>.</li>
</ol></li>
</ul>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>The current implementation is in Haskell, but I’d really like to
encourage a discussion beyond specific languages. In order to make
binary “human-readable” we need solutions that are universal, i.e. work
in any language, or perhaps better yet than libraries – extend
programming languages with something like Erlang’s bit syntax.</p>
<ul>
<li>Do you have use cases that are not listed above?</li>
<li>Do you know of tools, libraries or solutions any of the above use
cases that have already not been discussed or are not listed below in
the “see also” section?</li>
<li>Do you know if some use cases impossible in general or incompatible
with each other?</li>
<li>Interested in porting any of these ideas to your favorite
language?</li>
</ul>
<p>If so, feel free to get in touch!</p>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li>The Erlang reference manual on <a
href="https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax">bit
syntax</a>;</li>
<li>Programming examples of bit syntax from the Erlang <a
href="https://www.erlang.org/doc/programming_examples/bit_syntax.html">user’s
guide</a>;</li>
<li>Joe Armstrong’s PhD <a
href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-1166">thesis</a>
<ol start="2003" type="1">
<li>also has a section on bit syntax on p. 60;</li>
</ol></li>
<li><a href="https://erlang.org/workshop/2002/Gustafsson.pdf">Native
Code Compilation of Erlang’s Bit Syntax</a> (2002);</li>
<li><a href="https://capnproto.org/">Cap’n Proto</a>;</li>
<li>Simple Binary Encoding (<a
href="https://github.com/real-logic/simple-binary-encoding">SBE</a>) by
Martin Thompson et al;</li>
<li>GNU <a href="https://jemarch.net/poke">poke</a>, extensible editor
for structured binary data;</li>
<li><a href="https://github.com/wader/fq">fq: jq for binary formats</a>
also described in this <a
href="https://www.youtube.com/watch?v=GJOq_b0eb-s&amp;list=PLTj8twuHdQz-JcX7k6eOwyVPDB8CyfZc8&amp;index=1">talk</a>;</li>
<li><a href="https://github.com/antonmedv/fx">Terminal JSON
viewer</a>;</li>
<li>Rust’s <a href="https://github.com/jam1garner/binrw">binrw</a>
crate;</li>
<li><em>Designing Data-Intensive Applications</em> by Martin Kleppmann
(chapter 3-4, 2017);</li>
<li><em>Development and Deployment of Multiplayer Online Games, Vol.
I</em> by Sergey Ignatchenko (pp. 200-216 and 259-285, 2017).</li>
</ul>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The savings are greater for more complicated JSON
objects, especially considering JSON doesn’t support binary data which
needs to be either escaped or base64 encoded before used as a string.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I don’t think Erlang uses zig-zag encoding of integers,
in fact I’m not sure what it does with them.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The library tries to calculate the offset of a field
from the start of the file, in this case the beginning of the file
contains an audio binary “field” of unknown length, so it fails and
retries calculating the offset from the end of the file instead.<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Avro has a nicer story for <a
href="https://avro.apache.org/docs/1.11.1/specification/#schema-resolution">compatibility</a>.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></description>
      <category>Development</category>
    </item>

    <item>
      <title>State machines with of async I/O</title>
      <link>https://stevana.github.io/state_machines_with_of_async_io.html</link>
      <guid>https://stevana.github.io/state_machines_with_of_async_io.html</guid>
      <pubDate>Sat, 7 Jan 2023 00:00:00 GMT</pubDate>
      <description><![CDATA[<h1>coroutine-state-machines</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#usage" id="toc-usage">Usage</a></li>
<li><a href="#how-it-works" id="toc-how-it-works">How it works</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#see-also" id="toc-see-also">See also</a></li>
</ul>
</nav>
<div class="date">Posted on Jan  7, 2023</div>
<p>State machines of the type
<code>Input -&gt; State -&gt; (Output, State)</code> are great. They are
easy to reason about, and if run on a separate thread with access to a
queue of <code>Input</code>s they perform well too.</p>
<p>Sometimes the state machine might need to do some blocking I/O before
producing the output though, this slows down the processing of
inputs.</p>
<p>This repo is an experiment in how we can write the state machine as
if the I/O is blocking, but actually it’s non-blocking and inputs can
continue to be processes while we wait for the I/O action to
complete.</p>
<section id="usage" class="level2">
<h2><a href="#usage" title="Usage">Usage</a></h2>
<p>To make things more concrete we will be implementing a key-value
store as a state machine.</p>
<p>To start the key-value store in a terminal issue:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> run app</span></code></pre></div>
<p>Then interact with the key-value store from another terminal using
<code>Write</code> and <code>Read</code> commands as follows:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> http POST :8080 <span class="at">--raw</span> <span class="st">&#39;Write &quot;x&quot; 1&#39;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">HTTP/1.1</span> 200 OK</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Date:</span> Thu, 05 Jan 2023 08:47:03 GMT</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Server:</span> Warp/3.3.23</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ex">Transfer-Encoding:</span> chunked</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Ok</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> http POST :8080 <span class="at">--raw</span> <span class="st">&#39;Read &quot;x&quot;&#39;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="ex">HTTP/1.1</span> 200 OK</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="ex">Date:</span> Thu, 05 Jan 2023 08:47:04 GMT</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="ex">Server:</span> Warp/3.3.23</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Transfer-Encoding:</span> chunked</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="ex">Result</span> 1</span></code></pre></div>
</section>
<section id="how-it-works" class="level2">
<h2><a href="#how-it-works" title="How it works">How it works</a></h2>
<p>The state machine for the key-value store example looks like
this:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Input</span> <span class="ot">=</span> <span class="dt">Write</span> <span class="dt">String</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Read</span> <span class="dt">String</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Show</span>, <span class="dt">Read</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Output</span> <span class="ot">=</span> <span class="dt">Ok</span> <span class="op">|</span> <span class="dt">Result</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock <span class="dt">Show</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">sm ::</span> <span class="dt">SM</span> (<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Int</span>) <span class="dt">Input</span> <span class="dt">Output</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>sm <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">&lt;-</span> ask</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> i <span class="kw">of</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Write</span> k v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>      fsAppend k v</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>      modify (Map.insert k v)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="dt">Ok</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Read</span> k <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      m <span class="ot">&lt;-</span> get</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (<span class="dt">Result</span> (m <span class="op">Map.!?</span> k))</span></code></pre></div>
<p>Where <code>fsAppend</code> appends the key-value pair to a file, so
that we can recover in in-memory state in case of a crash.</p>
<p>The program looks sequential, but once the state machine hits the
<code>fsAppend</code> it will suspend using a coroutine monad, yielding
control back to the event loop which feeds it inputs, the event loop
will enqueue the I/O action to a separate thread that deals with I/O and
continue feeding the state machine new inputs, until the I/O thread
completes the write to disk, at which point the state machine will be
resumed with the latest state.</p>
</section>
<section id="contributing" class="level2">
<h2><a href="#contributing" title="Contributing">Contributing</a></h2>
<p>Any feedback, comments or suggestions are most welcome!</p>
<p>In particular if you know how to solve this problem in a different or
better way.</p>
<p>A potential source of confusion and bugs might be the fact that once
we resume the state might not be the same as it was before we suspended.
It’s not clear to me how big of a problem this is in practice, or if
anything can be done about it without sacrificing either the “sequential
feel” or the parallelism?</p>
<p>One possible generalisation that seems feasible is to not suspend
immediately upon the I/O action, but rather merely return a “future”
which we later can <code>await</code> for. This would allow us to do
suspend and do multiple I/O actions before resuming, something like:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  a1 <span class="ot">&lt;-</span> fsAppend k v</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  a2 <span class="ot">&lt;-</span> someOtherIOAction</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  awaitBoth a1 a2 <span class="co">-- or awaitEither a1 a2</span></span></code></pre></div>
<p>Arguably the await makes it more clear where the suspension and
resumption happen, which could help against the confusion regarding that
the state might change.</p>
</section>
<section id="see-also" class="level2">
<h2><a href="#see-also" title="See also">See also</a></h2>
<ul>
<li><em>Development and Deployment of Multiplayer Online Games, Vol.
II</em> by Sergey Ignatchenko (2020), especially chapter 5;</li>
<li><a
href="https://abhinavsarkar.net/posts/implementing-co-3/"><em>Implementing
Co, a Small Language With Coroutines #3: Adding
Coroutines</em></a>;</li>
<li><a
href="https://ayazhafiz.com/articles/23/a-lambda-calculus-with-coroutines-and-heapless-closures"><em>A
Lambda Calculus With Coroutines and Heapless, Directly-Called
Closures</em></a>;</li>
<li><a href="https://blog.dziban.net/coroutines/">Small VMs &amp;
Coroutines</a>;</li>
<li><a href="https://github.com/slembcke/Tina">Tina is a teeny tiny,
header only, coroutine and job library</a>;</li>
<li><a href="http://dunkels.com/adam/pt/">Protothreads</a>;</li>
<li><a href="https://en.wikipedia.org/wiki/Proactor_pattern">Proactor
pattern</a>;</li>
<li><a
href="https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-rationale.md#why-not-async">WebAssembly
Reactors</a>.</li>
</ul>
</section>
]]></description>
      <category>Development</category>
    </item>


  </channel>
</rss>
