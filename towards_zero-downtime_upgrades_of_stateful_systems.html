<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Stevan A" />
  <title>Towards zero-downtime upgrades of stateful systems</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="alternate" type="application/rss+xml"
        title="RSS feed"
        href="rss.xml" />
  <script src="script.js"></script>
  <script data-goatcounter="https://stevana-github-io.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <noscript>
    <img src="https://stevana-github-io.goatcounter.com/count?p=/towards_zero-downtime_upgrades_of_stateful_systems.html&t=Towards zero-downtime upgrades of stateful systems">
  </noscript>
</head>
<body>
<header id="title-block-header">
  <nav id="nav">
    <span class="title"><a href="/">Stevan's notes...</a></span>
    <a href="about.html">About</a>
    <a href="rss.xml">Feed <img height="10px" src="rss.svg" /></a>
  </nav>
</header>
<hr />
<main>
<h1>Towards zero-downtime upgrades of stateful systems</h1>
<nav id="TOC" class="sidenote" role="doc-toc">
<h2 id="toc-title">Table of contents</h2>
<ul>
<li><a href="#motivation" id="toc-motivation">Motivation</a></li>
<li><a href="#terminology" id="toc-terminology">Terminology</a>
<ul>
<li><a href="#software-systems" id="toc-software-systems">Software
systems</a></li>
<li><a href="#programs-and-their-upgrades"
id="toc-programs-and-their-upgrades">Programs and their
upgrades</a></li>
</ul></li>
<li><a href="#implementation" id="toc-implementation">Implementation</a>
<ul>
<li><a href="#state-machines" id="toc-state-machines">State
machines</a></li>
<li><a href="#example" id="toc-example">Example</a></li>
<li><a href="#semantics" id="toc-semantics">Semantics</a></li>
<li><a href="#pipelines" id="toc-pipelines">Pipelines</a></li>
<li><a href="#deployment" id="toc-deployment">Deployment</a></li>
<li><a href="#upgrades" id="toc-upgrades">Upgrades</a></li>
<li><a href="#sources-and-sinks" id="toc-sources-and-sinks">Sources and
sinks</a></li>
<li><a href="#remote-upgrades" id="toc-remote-upgrades">Remote
upgrades</a></li>
</ul></li>
<li><a href="#discussion-and-future-work"
id="toc-discussion-and-future-work">Discussion and future work</a></li>
</ul>
</nav>
<div class="date">Posted on Mar  7, 2024</div>
<section id="motivation" class="level2">
<h2><a href="#motivation" title="Motivation">Motivation</a></h2>
<p>Most deployed programs need to be upgraded at some point. The reasons
vary from adding new features to patching a bug and potentially fixing a
broken state. Even though upgrades are an essential part of software
development and maintenance, programming languages tend to not help the
programmer deal with them in any way.</p>
<p>The situation reminds me of a remark made by Barbara Liskov about
deployment of software (which is related to upgrades) in her Turing
award <a href="https://youtu.be/qAKrMdUycb8?t=3058">lecture</a>
(2009):</p>
<blockquote>
<p>“There’s a funny disconnect in how we write distributed programs. You
write your individual modules, but then when you want to connect them
together you’re out of the programming language and into this other
world. Maybe we need languages that are a little bit more complete now,
so that we can write the whole thing in the language.”</p>
</blockquote>
<p>There’s one exception, that I know of, where upgrades are talked
about from within the language: Erlang/OTP. In OTP there’s a library
construct called <a
href="https://www.erlang.org/doc/design_principles/release_structure"><em>release</em></a>,
which can be used to perform up- and downgrades. Furthermore, these up-
and downgrades can hot swap the running code resulting in zero-downtime
and no interruption of the service of connected clients.</p>
<p>If you haven’t seen Erlang’s hot swapping feature before, then you
might want to have a look at the classic <a
href="https://www.youtube.com/watch?v=xrIjfIjssLE">Erlang the movie</a>,
which contains a telecommunications example of this. If you prefer
reading over watching, then I’ve written an earlier <a
href="https://stevana.github.io/hot-code_swapping_a_la_erlang_with_arrow-based_state_machines.html">post</a>
which starts off by explaining a REPL session which performs an upgrade
(my example isn’t nearly as cool as in the movie though).</p>
<p>What is it that Erlang’s releases and hot swapping facilities do? Can
we steal those ideas and build upon them? These are the main questions
that motivated me in writing this post.</p>
<p>Let’s take a step back, ignoring Erlang for a moment, and ask
ourselves: what would good support for upgrades look like?</p>
<ul>
<li>Zero-downtime: seamless, don’t interrupt existing client connections
or sessions;</li>
<li>If there’s any state then migrate it in a type-safe way;</li>
<li>Backwards and forwards compatibility: old clients should be able to
talk to newer servers, and newer clients should be able to talk to old
servers;</li>
<li>Atomicity: upgrades either succeed, or fail and rollback any
changes;</li>
<li>Downgrades: even if an upgrade succeeds we might want to rollback to
an earlier version.</li>
</ul>
<p>In the rest of this post I’d like to explore how we can achieve some
of this.</p>
</section>
<section id="terminology" class="level2">
<h2><a href="#terminology" title="Terminology">Terminology</a></h2>
<p>Having defined some desirable characteristics of upgrades, let’s move
on to defining what we mean by upgrades.</p>
<p>There are two notions I’d like clarify: what kind of software systems
the upgrades are targeting, and then how we represent programs and their
upgrades.</p>
<section id="software-systems" class="level3">
<h3><a href="#software-systems" title="Software systems">Software
systems</a></h3>
<p>There’s different kinds of software systems one might want to
upgrade.</p>
<ol type="1">
<li><p>Client-only, e.g. a compiler, editor, or some command line
utility which runs locally on your computer and doesn’t interact with
any server. Downtime is typically not a problem, and the state of the
program is typically saved to disk. The operating system’s package
manager typically takes care of the upgrades, with minimal user
involvement. However there are situations where one might like to
perform an upgrade without first terminating the old version of a
client-only application, e.g. the fix-and-continue debugging <a
href="https://lispcookbook.github.io/cl-cookbook/debugging.html#resume-a-program-execution-from-anywhere-in-the-stack">workflow</a>
from Lisp and Smalltalk, <a
href="https://en.wikipedia.org/wiki/TidalCycles">live coding music</a>,
or when working with large data sets, e.g. in <a
href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1386713/">bioinformatics</a>;</p></li>
<li><p>Client-server applications where the target of the upgrade is a
<em>stateless</em> component of the server, e.g. a front-end or a REST
API. The stateless components typically retrieve the state they need to
service a request from a stateful component, e.g. a database, but they
don’t maintain any state of their own, which makes stateless components
easier to upgrade. A common strategy is to stick a load balancer
in-front of the stateless component(s), spin up the new version of the
component while keeping the old version around, and then (slowly)
migrate traffic over to the new version. Notice that this wouldn’t
necessarily work if there was state in the components, as then the state
of the old and new versions of the components might diverge and
potentially have unexpected results;</p></li>
<li><p>Client-server applications where the target of the upgrade is a
<em>stateful</em> component of the server, e.g. a database or a service
with a stateful protocol like FTP. Databases were designed for
supporting upgrades, with features like schema migrations and
replication. The high-level idea would be to spin up the new version,
take a snapshot of the old database, start logically replicating all new
requests from the old to the new database while also restoring the
snapshot to the new database, once the new database has caught up, we
can switch over and tear down the old database. Depending on the volume
of the database and the rate of new traffic this can still be a
difficult operation.</p>
<p>A service like FTP, where once the user is connected they can “move
around” by e.g. changing the working directory and list the contents of
the current working directory, are typically not possible to upgrade
without downtime. The problem is that the response of one command
depends on the history of previous commands in that user sessions, and
this state is transient. If you think FTP is a silly protocol (it’s),
then consider the similarly stateful POSIX filesystem API, with its file
handles that can be opened, read, written, and closed;</p></li>
<li><p>Distributed stateful systems, e.g. a distributed key-value
database. This is similar to the above, but the replication of data is
performed all the time rather than only at the moment an upgrade is
performed. The disadvantage is that we need more hardware and bandwidth,
but on the other hand it makes upgrades much easier. Distributed systems
can typically tolerate and repair some amount of faulty replicas, which
allows for rolling upgrades where we replace one of the server
components at the time;</p></li>
<li><p>There’s also <a
href="https://www.inkandswitch.com/local-first/">local-first</a>
systems, which are different to all the above. I’ve not had a chance to
think about upgrades in that context, so I won’t talk about them any
further.</p></li>
</ol>
<p>In this post I’d like to focus on upgrading stateful systems, like
non-distributed databases and stateful services like FTP or
filesystems.</p>
<p>Stateful systems arguably have the worst upgrade path of the ones
listed above, making them more interesting to work on. That said I hope
that the techniques can be used to simplify upgrades in the other kinds
of systems too, and potentially enabling other possibilities like better
debugging experience and live coding.</p>
</section>
<section id="programs-and-their-upgrades" class="level3">
<h3><a href="#programs-and-their-upgrades"
title="Programs and their upgrades">Programs and their upgrades</a></h3>
<p>Having defined what kind of systems we’d like to upgrade, let’s turn
our attention to how we can represent programs and their upgrades.</p>
<p>We could choose to use the syntax of a specific programming language
to represent programs, but programming languages tend to be too big and
complicated. Or, we could be general and represent programs as
λ-calculus terms or equivalently Turing machines, but that would be too
clumsy and too low-level.</p>
<p>A happy middle ground, which is easy to implement in any programming
language while at the same time expressive enough to express any
algorithm at a desired level of abstraction, is the humble state
machine<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>. There are different ways to define
state machines, we’ll go for a definition which is a simple function
from some input and a state to a pair of some output and a new
state:</p>
<pre><code>  input -&gt; state -&gt; (state, output)</code></pre>
<p>where inputs, states and outputs are algebraic datatypes
(records/structs and tagged unions).</p>
<p>To make things concrete, let’s consider an example where we represent
a counter as a state machine. One way to define such a state machine is
to use the enum <code>{ReadCount, IncrCount}</code> as input, set the
state to be an integer and the output to be a tagged union where in the
read case we return an integer and in the increment case we return an
acknowledgment (unit or void type). Given these types, the state machine
function of the counter can be defined as follows (in Python):</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> counter(<span class="bu">input</span>: Input, state: <span class="bu">int</span>) <span class="op">-&gt;</span> (<span class="bu">int</span>, <span class="bu">int</span> <span class="op">|</span> <span class="va">None</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">match</span> <span class="bu">input</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> Input.ReadCount: <span class="cf">return</span> (state, state)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> Input.IncrCount: <span class="cf">return</span> (state <span class="op">+</span> <span class="dv">1</span>, <span class="va">None</span>)</span></code></pre></div>
<p>Assuming our programs are such state machines, what would it mean to
upgrade them? I think this is where having a simple representation of
programs where all of the state is explicit starts to shine. By merely
looking at the function type of a state machine, we can see that it
would make sense to be able to:</p>
<ol type="1">
<li>Extend the input type with more cases, e.g. a
<code>ResetCount</code> which sets the new state to <code>0</code>;</li>
<li>Refine an existing output with more data, e.g. we could return the
old count when we increment;</li>
<li>Extending the state, e.g. we could add a boolean to the state which
determines if we should increment by +1 or -1 (i.e. decrementing);</li>
<li>Refine an existing input, e.g. make <code>IncrCount</code> have an
integer value associated with it which determines by how much we want to
increment.</li>
</ol>
<p>I don’t know if the above list complete, but it’s a start.</p>
<p>If we go back to the list of criteria for good upgrade support, we
can see how some of the items there are more tangible now.</p>
<p>For example, typed state migrations means that if we change the state
type from <code>state</code> to <code>state'</code> then when we migrate
to old to the new state using a function of type
<code>state -&gt; state'</code>.</p>
<p>Similarly, what it means to support backwards compatibility is more
clear now. Imagine we upgrade from a server state machine:</p>
<pre><code>  input -&gt; state -&gt; (output, state)</code></pre>
<p>to a new version that has the following type:</p>
<pre><code>  input&#39; -&gt; state&#39; -&gt; (output&#39;, state&#39;)</code></pre>
<p>What would it take to still be able to serve old clients which make
requests using the old <code>input</code> type? If we had a function
from <code>input -&gt; input'</code> we could upgrade the request, feed
it to the new state machine and get an <code>output'</code> back, we
then see that we’d also need a way to downgrade the output, i.e. a
function <code>output' -&gt; output</code><a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<p>Forward compatibility, i.e. an upgraded client sends an
<code>input'</code> to a server which haven’t been upgraded yet
(i.e. expects <code>input</code>), is a bit more tricky, but again at
least we can now start to be able to talk about these things in a more
concrete way.</p>
<p>One last thing with regard to how to represent programs. Our state
machines run entirely sequentially, which is a problem if we want to
implement servers that can handle more than one client at the time. A
simple way adding parallelism is make it possible to construct pipelines
of state machines, where the state machines run in parallel. Picture the
state machines as processing stages on a conveyor belt.</p>
<p><img
src="https://raw.githubusercontent.com/stevana/hot-swapping-state-machines2/main/data/bottling_factory.png" /></p>
<p>The conveyor belt in our case, i.e. our pipeline, will be queues
which connect the state machines.</p>
<p>A typical TCP-based service can then be composed of a pipeline
that:</p>
<ol type="1">
<li>Accepts new connections/sockets from a client;</li>
<li>Waits for some of the accepted sockets to be readable (this requires
some <code>select/poll/io_uring</code>-like constructs);</li>
<li><code>recv</code> the bytes of a request;</li>
<li>Deserialise the request bytes into an input;</li>
<li>Process the input using the a state machine to produce an output
(potentially reading and writing to disk);</li>
<li>Serialise the output into a response in bytes;</li>
<li>Wait for the socket to be writable;</li>
<li><code>send</code> the response bytes back to the client and close
the socket.</li>
</ol>
<p>Each of these stages could be a state machine which runs in parallel
with all the other stages. Structuring services in this pipeline fashion
was <a
href="https://www.youtube.com/watch?v=U3eo49nVxcA&amp;t=1949s">advocated</a>
by the late Jim Gray and more recently Martin Thompson et al have <a
href="https://www.youtube.com/watch?v=qDhTjE0XmkE">been</a> giving <a
href="https://www.youtube.com/watch?v=_KvFapRkR9I">talks</a> using a
similar approach. If a stage is slow, we can shard (or partition, using
Jim’s terminology) it by dedicating another CPU/core to that stage and
have even numbered requests to one CPU/core while odd numbered requests
go to the other. That way we effectively double the throughput, without
breaking determinism.</p>
<p>Let me just leave you with one final image. I like to think of state
machines on top of pipelines as a limited form of actors or Erlang
processes (<code>gen_server</code>s more precisely) that cannot send
messages to which other process they like (graph-like structure), but
rather only downstream (DAG-like structure)<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
</section>
</section>
<section id="implementation" class="level2">
<h2><a href="#implementation"
title="Implementation">Implementation</a></h2>
<p>I hope that I’ve managed to convey what I’d like to do, why and where
my inspiration is coming from.</p>
<p>Next I’d like to make things more concrete with some code. But first
I’d like to apologies for my choice of using Haskell. I know it’s a
language that not that many people are comfortable with, but its
advanced type system (GADTs in particular) helps me express things more
cleanly. If anything isn’t clear, feel free to ask, I’m happy to try to
explain things in simpler terms. Also if anyone knows how to express
this without GADTs, while retaining type safety, then please let me
know. The code doesn’t add anything new to our previous discussion,
merely validates that at least some of it can be implemented, so even if
you can’t follow everything you won’t be missing out on anything
important.</p>
<p>A few notes on the implementation:</p>
<ul>
<li>To keep things simple we’ll only implement linear pipelines. Each
stage of the pipeline runs in parallel with all other stages, thus
giving us pipelining parallelism à la assembly lines;</li>
<li>The transformation at each stage is done via a state machine. The
syntax of state machines needs to be easily serialisable, so that we can
send upgrades over the wire;</li>
<li>The remote end will need to deserialise and typecheck the receiving
code in order to assure that it’s compatible with the already deployed
code.</li>
</ul>
<p>In the rest of this section we’ll try to fleshing out details of the
above.</p>
<section id="state-machines" class="level3">
<h3><a href="#state-machines" title="State machines">State
machines</a></h3>
<p>Typed state machines are represented using a datatype parametrised by
the state, <code>s</code>, and indexed by its input type,
<code>a</code>, and output type <code>b</code><a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.
For example the <code>Id</code>entity state machine has the same input
and output type, while if we want to <code>Compose</code> to state
machines then output type of the first needs to be the same as the input
type of the second, and so on.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> s a b <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Identity and composition.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Id</span><span class="ot">      ::</span> <span class="dt">T</span> s a a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Compose</span><span class="ot"> ::</span> <span class="dt">T</span> s b c <span class="ot">-&gt;</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">T</span> s a c</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Introducing and incrementing integers.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Int</span><span class="ot">     ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">T</span> s () <span class="dt">Int</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Incr</span><span class="ot">    ::</span> <span class="dt">T</span> s <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Mapping over sum types.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Case</span><span class="ot">    ::</span> <span class="dt">T</span> s a c <span class="ot">-&gt;</span> <span class="dt">T</span> s b d <span class="ot">-&gt;</span> <span class="dt">T</span> s (<span class="dt">Either</span> a b) (<span class="dt">Either</span> c d)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Read and update the state.</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Get</span><span class="ot">     ::</span> <span class="dt">T</span> s () s</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Put</span><span class="ot">     ::</span> <span class="dt">T</span> s s ()</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Converting values from and to strings.</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Read</span><span class="ot">    ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">T</span> s <span class="dt">String</span> a</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Show</span><span class="ot">    ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">T</span> s a <span class="dt">String</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- Forward composition.</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;&gt;) ::</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">T</span> s b c <span class="ot">-&gt;</span> <span class="dt">T</span> s a c</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;&gt;</span> g <span class="ot">=</span> g <span class="ot">`Compose`</span> f</span></code></pre></div>
</section>
<section id="example" class="level3">
<h3><a href="#example" title="Example">Example</a></h3>
<p>To keep things concrete let’s reimplement the counter example from
above.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">InputV1</span>  <span class="ot">=</span> <span class="dt">Either</span> () ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">OutputV1</span> <span class="ot">=</span> <span class="dt">Either</span> <span class="dt">Int</span> ()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV1</span><span class="ot"> ::</span> <span class="dt">InputV1</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV1</span> <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">IncrCountV1</span><span class="ot"> ::</span> <span class="dt">InputV1</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">IncrCountV1</span> <span class="ot">=</span> <span class="dt">Right</span> ()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="ot">counterV1 ::</span> <span class="dt">T</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>counterV1 <span class="ot">=</span> <span class="dt">Read</span> <span class="op">&gt;&gt;&gt;</span> counterV1&#39; <span class="op">&gt;&gt;&gt;</span> <span class="dt">Show</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    counterV1&#39; ::</span> <span class="dt">T</span> <span class="dt">Int</span> <span class="dt">InputV1</span> <span class="dt">OutputV1</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    counterV1&#39; <span class="ot">=</span> <span class="dt">Get</span> <span class="ot">`Case`</span> (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Incr</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>)</span></code></pre></div>
<p>Notice how the two operations’ inputs and outputs are represented
with an <code>Either</code> over which the <code>Case</code>
operates.</p>
</section>
<section id="semantics" class="level3">
<h3><a href="#semantics" title="Semantics">Semantics</a></h3>
<p>We can interpret our typed state machines in terms of the
<code>State</code> monad as follows.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runT ::</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (b, s)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>runT f x s <span class="ot">=</span> runState (eval f x) s</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> s b</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Id</span>            <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Compose</span> g f) <span class="ot">=</span> eval g <span class="op">&lt;=&lt;</span> eval f</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Int</span> i)       <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> <span class="fu">const</span> i</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Incr</span>          <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Case</span> f g)    <span class="ot">=</span> <span class="fu">either</span> (<span class="fu">fmap</span> <span class="dt">Left</span> <span class="op">.</span> eval f) (<span class="fu">fmap</span> <span class="dt">Right</span> <span class="op">.</span> eval g)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Get</span>           <span class="ot">=</span> <span class="fu">const</span> get</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Put</span>           <span class="ot">=</span> put</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Read</span>          <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> <span class="fu">read</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Show</span>          <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> <span class="fu">show</span></span></code></pre></div>
<p>Using the above interpreter we can run our example from before.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runT counterV1 (<span class="fu">show</span> <span class="dt">ReadCountV1</span>) <span class="dv">0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;Left 0&quot;</span>,<span class="dv">0</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runT counterV1 (<span class="fu">show</span> <span class="dt">IncrCountV1</span>) <span class="dv">0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;Right ()&quot;</span>,<span class="dv">1</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runT counterV1 (<span class="fu">show</span> <span class="dt">ReadCountV1</span>) <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;Left 1&quot;</span>,<span class="dv">1</span>)</span></code></pre></div>
<p>These runs only step the counter by one input at the time, things get
more interesting when state machines get streams of inputs via
pipelines.</p>
</section>
<section id="pipelines" class="level3">
<h3><a href="#pipelines" title="Pipelines">Pipelines</a></h3>
<p>Pipelines are represented by a type similar to that for typed state
machines, it’s also indexed by the input and output types.</p>
<p>We can picture a pipeline as a conveyor belt with state machines
operating on the items passing through.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">P</span> a b <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IdP</span><span class="ot">    ::</span> <span class="dt">P</span> a a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&gt;&gt;&gt;) ::</span> <span class="dt">Typeable</span> b <span class="ot">=&gt;</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">P</span> b c <span class="ot">-&gt;</span> <span class="dt">P</span> a c</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SM</span><span class="ot">     ::</span> <span class="dt">Typeable</span> s <span class="ot">=&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">P</span> a b</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span></code></pre></div>
<p>Notice how the state type of the state machines is existentially
quantified, meaning each state machine can have its own state.</p>
</section>
<section id="deployment" class="level3">
<h3><a href="#deployment" title="Deployment">Deployment</a></h3>
<p>Pipelines can be deployed. Each state machine will be spawned on its
own thread, meaning that all state machines run in parallel, and they
will be connected via queues.</p>
<p>Given a pipeline <code>P a b</code> and an input
<code>Queue (Msg a)</code> we get an output
<code>Queue (Msg b)</code>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">deploy ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=&gt;</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">Queue</span> (<span class="dt">Msg</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Queue</span> (<span class="dt">Msg</span> b))</span></code></pre></div>
<p>where <code>Msg</code> is defined as follows.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Msg</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Item</span> (<span class="dt">Maybe</span> <span class="dt">Socket</span>) a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Upgrade</span> (<span class="dt">Maybe</span> <span class="dt">Socket</span>) <span class="dt">Name</span> <span class="dt">UpgradeData_</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>Think of <code>Msg a</code> as small wrapper around <code>a</code>
which might contain a client socket (so that we know where to send the
reply), or an upgrade. Upgrades are targeting a specific state machine
in our pipeline, that’s what the <code>Name</code> parameter is for, and
they also carry an untyped <code>UpgradeData_</code> payload which will
come back to shortly.</p>
<p>Given the above we can define deployment of pipelines as follows
(I’ll explain each case below the code).</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>deploy <span class="dt">IdP</span>             q <span class="ot">=</span> <span class="fu">return</span> q</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>deploy (f <span class="op">:&gt;&gt;&gt;</span> g)      q <span class="ot">=</span> deploy g <span class="op">=&lt;&lt;</span> deploy f q</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>deploy (<span class="dt">SM</span> name s0 f0) q <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  q&#39; <span class="ot">&lt;-</span> newQueue</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> go ::</span> <span class="dt">Typeable</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      go s f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        m <span class="ot">&lt;-</span> readQueue q</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> m <span class="kw">of</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Item</span> msock i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (o, s&#39;) <span class="ot">=</span> runT f i s</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            writeQueue q&#39; (<span class="dt">Item</span> msock o)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            go s&#39; f</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Upgrade</span> msock name&#39; ud</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> name <span class="op">/=</span> name&#39; <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                writeQueue q&#39; (<span class="dt">Upgrade</span> msock name&#39; ud)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                go s f</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> typeCheckUpgrade f ud <span class="kw">of</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">Just</span> (<span class="dt">UpgradeData</span> (<span class="ot">f&#39; ::</span> <span class="dt">T</span> t&#39; a b) (<span class="ot">g ::</span> <span class="dt">T</span> () s t&#39;)) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> (t&#39;, ()) <span class="ot">=</span> runT g s ()</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">case</span> cast t&#39; <span class="kw">of</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Just</span> s&#39; <span class="ot">-&gt;</span> go s&#39; f&#39;</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> go s f</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> go s f</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>          <span class="op">...</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>  _pid <span class="ot">&lt;-</span> forkIO (go s0 f0)</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> q&#39;</span></code></pre></div>
<p>The identity pipeline simply returns the input queue. We deploy
compositions of pipelines by deploying the components and connecting the
queues. Deploying state machines is the interesting part.</p>
<p>When we deploy state machines, we first create a new queue which will
hold the outputs, we then fork a new thread which reads from the input
queue and writes to this new output queue, and finally we return the
output queue. When reading from the input queue there’re two cases:</p>
<ol type="1">
<li>We can either get a regular <code>Item</code> in which case we step
our state machine using the <code>runT</code> function to obtain an
output and a new state, we write the output to the output queue and
continue processing with the new state;</li>
<li>Or, if the <code>Msg</code> is an <code>Upgrade</code> we first
check if the upgrade is targeting this state machine by checking if the
names match, if not we simply pass it further downstream. If the names
to match then we try to typecheck the untyped <code>UpgradeData_</code>.
If the typechecking succeeds, we’ll get a new state machine and a state
migration function, which allows us to migrate the current state and
continue processing with the new state machine.</li>
</ol>
<p>Next let’s have a look at how upgrades are represented and
typechecked.</p>
</section>
<section id="upgrades" class="level3">
<h3><a href="#upgrades" title="Upgrades">Upgrades</a></h3>
<p>Upgrades are sent over the wire in a serialised format and
deserialised at the other end, so they need to be plain first-order
data.</p>
<p>This means we can’t merely send over our typed state machine type
<code>t :: T s a b</code>, or rather the receiver will have to
reconstruct the type information. If this sounds strange, the perhaps
easiest way to convince yourself is to imagine you receive
<code>show t</code> and now you want to reconstruct <code>t</code>. When
you call <code>read (show t)</code> you need to annotate it with what
type to read into, and that’s the problem: at this point you don’t have
the type annotation <code>T s a b</code>.</p>
<p>So the plan around this is to introduce a plain first-order datatype
for upgrades, which can easily be serialised and deserialised, and then
use <em>typechecking</em> to reconstruct the type information.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UpgradeData_</span> <span class="ot">=</span> <span class="dt">UpgradeData_</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> oldState        ::</span> <span class="dt">Ty_</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> newState        ::</span> <span class="dt">Ty_</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> newInput        ::</span> <span class="dt">Ty_</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> newOutput       ::</span> <span class="dt">Ty_</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> newStateMachine ::</span> <span class="dt">U</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> stateMigration  ::</span> <span class="dt">U</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>)</span></code></pre></div>
<p>We can to typecheck the above untyped upgrade into the following
typed version.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UpgradeData</span> s a b <span class="ot">=</span> <span class="kw">forall</span> s&#39;<span class="op">.</span> <span class="dt">Typeable</span> s&#39; <span class="ot">=&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UpgradeData</span> (<span class="dt">T</span> s&#39; a b) (<span class="dt">T</span> () s s&#39;)</span></code></pre></div>
<p>The way typechecking for upgrades work is basically the user needs to
provide the untyped types of the state, input and output types of the
new state machine as well as the state migration function, from the
untyped types we can infer the typed types which we then typecheck the
new state machine and migration function against.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeCheckUpgrade ::</span> <span class="kw">forall</span> s a b<span class="op">.</span> (<span class="dt">Typeable</span> s, <span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=&gt;</span> <span class="dt">T</span> s a b <span class="ot">-&gt;</span> <span class="dt">UpgradeData_</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">UpgradeData</span> s a b)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>typeCheckUpgrade _f (<span class="dt">UpgradeData_</span> t_ t&#39;_ a&#39;_ b&#39;_ f_ g_) <span class="ot">=</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> (inferTy t_, inferTy t&#39;_, inferTy a&#39;_, inferTy b&#39;_) <span class="kw">of</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">ETy</span> (<span class="ot">t ::</span> <span class="dt">Ty</span> t), <span class="dt">ETy</span> (<span class="ot">t&#39; ::</span> <span class="dt">Ty</span> t&#39;), <span class="dt">ETy</span> (<span class="ot">a&#39; ::</span> <span class="dt">Ty</span> a&#39;), <span class="dt">ETy</span> (<span class="ot">b&#39; ::</span> <span class="dt">Ty</span> b&#39;)) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Refl</span> <span class="ot">&lt;-</span> decT <span class="op">@</span>a <span class="op">@</span>a&#39;</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Refl</span> <span class="ot">&lt;-</span> decT <span class="op">@</span>b <span class="op">@</span>b&#39;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Refl</span> <span class="ot">&lt;-</span> decT <span class="op">@</span>s <span class="op">@</span>t</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>      f <span class="ot">&lt;-</span> typeCheck f_ t&#39; a&#39; b&#39;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>      g <span class="ot">&lt;-</span> typeCheck g_ <span class="dt">TUnit</span> t t&#39;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (<span class="dt">UpgradeData</span> f g)</span></code></pre></div>
<p>Where untyped types are defined as follows:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty_</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">UTUnit</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTInt</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTBool</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTString</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTPair</span> <span class="dt">Ty_</span> <span class="dt">Ty_</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">UTEither</span> <span class="dt">Ty_</span> <span class="dt">Ty_</span></span></code></pre></div>
<p>and typed types as follows:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty</span> a <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TUnit</span><span class="ot">   ::</span> <span class="dt">Ty</span> ()</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TInt</span><span class="ot">    ::</span> <span class="dt">Ty</span> <span class="dt">Int</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TBool</span><span class="ot">   ::</span> <span class="dt">Ty</span> <span class="dt">Bool</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TString</span><span class="ot"> ::</span> <span class="dt">Ty</span> <span class="dt">String</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TPair</span><span class="ot">   ::</span> <span class="dt">Ty</span> a <span class="ot">-&gt;</span> <span class="dt">Ty</span> b <span class="ot">-&gt;</span> <span class="dt">Ty</span> (a, b)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TEither</span><span class="ot"> ::</span> <span class="dt">Ty</span> a <span class="ot">-&gt;</span> <span class="dt">Ty</span> b <span class="ot">-&gt;</span> <span class="dt">Ty</span> (<span class="dt">Either</span> a b)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>and the way we infer typed types from the untyped ones is done as
follows:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ETy</span> <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ETy</span><span class="ot"> ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Ty</span> a <span class="ot">-&gt;</span> <span class="dt">ETy</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">inferTy ::</span> <span class="dt">Ty_</span> <span class="ot">-&gt;</span> <span class="dt">ETy</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>inferTy <span class="dt">UTUnit</span> <span class="ot">=</span> <span class="dt">ETy</span> <span class="dt">TUnit</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>inferTy <span class="dt">UTInt</span>  <span class="ot">=</span> <span class="dt">ETy</span> <span class="dt">TInt</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>inferTy <span class="dt">UTBool</span> <span class="ot">=</span> <span class="dt">ETy</span> <span class="dt">TBool</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>inferTy <span class="dt">UTString</span> <span class="ot">=</span> <span class="dt">ETy</span> <span class="dt">TString</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>inferTy (<span class="dt">UTPair</span> ua ub) <span class="ot">=</span> <span class="kw">case</span> (inferTy ua, inferTy ub) <span class="kw">of</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ETy</span> a, <span class="dt">ETy</span> b) <span class="ot">-&gt;</span> <span class="dt">ETy</span> (<span class="dt">TPair</span> a b)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>inferTy (<span class="dt">UTEither</span> ua ub) <span class="ot">=</span> <span class="kw">case</span> (inferTy ua, inferTy ub) <span class="kw">of</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ETy</span> a, <span class="dt">ETy</span> b) <span class="ot">-&gt;</span> <span class="dt">ETy</span> (<span class="dt">TEither</span> a b)</span></code></pre></div>
<p>Now the only piece missing is untyped state machines and how to
typecheck those into typed ones.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeCheck ::</span> <span class="dt">U</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> s <span class="ot">-&gt;</span> <span class="dt">Ty</span> a <span class="ot">-&gt;</span> <span class="dt">Ty</span> b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">T</span> s a b)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">U</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">IdU</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ComposeU</span> <span class="dt">U</span> <span class="dt">U</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">IntU</span> <span class="dt">Int</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">CaseU</span> <span class="dt">U</span> <span class="dt">U</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">IncrU</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">GetU</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">PutU</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ReadU</span> <span class="dt">Ty_</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ShowU</span> <span class="dt">Ty_</span></span></code></pre></div>
<p>I’ll spare you from the <a
href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/src/TypeCheck/StateMachine.hs">details</a>,
but the main ingredient is to use the <code>Data.Typeable</code>
instances to check if the types match up, similarly to how it was done
above in <code>typeCheckUpgrade</code>.</p>
</section>
<section id="sources-and-sinks" class="level3">
<h3><a href="#sources-and-sinks" title="Sources and sinks">Sources and
sinks</a></h3>
<p>Almost there. When we deploy a pipeline <code>P a b</code> we need to
provide a <code>Queue (Msg a)</code> and get a
<code>Queue (Msg b)</code>, what are we supposed to do with those
queues? We could manually feed them with items, but for convenience it’s
nice to have some basic reusable adapters that we can connect these
“garden hoses” to.</p>
<p>We call something that provides an input queue a <code>Source</code>
and something that consumes an output queue a <code>Sink</code>. Useful
sources and sinks include stdin/stdout, files, and TCP streams.</p>
<p>We can then implement a run function with the following type:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">run ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Source</span> a <span class="ot">-&gt;</span> <span class="dt">Codec</span> (<span class="dt">Msg</span> a) (<span class="dt">Msg</span> b) <span class="ot">-&gt;</span> <span class="dt">P</span> a b <span class="ot">-&gt;</span> <span class="dt">Sink</span> b r <span class="ot">-&gt;</span> <span class="dt">IO</span> r</span></code></pre></div>
<p>Where <code>Codec a b</code> contains a deserialiser from
<code>ByteString</code> to <code>Maybe a</code> and a serialiser from
<code>b</code> to <code>ByteString</code>. We need this because our
sources and sinks produce and consume <code>ByteString</code>s.</p>
</section>
<section id="remote-upgrades" class="level3">
<h3><a href="#remote-upgrades" title="Remote upgrades">Remote
upgrades</a></h3>
<p>Putting it all together we can now create a TCP server for our
counter:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>run (<span class="dt">FromTCP</span> <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span>) readShowCodec (<span class="dt">SM</span> <span class="st">&quot;counter&quot;</span> <span class="dv">0</span> counterV1) <span class="dt">ToTCP</span></span></code></pre></div>
<p>If we run the above in a REPL, then from another terminal we can
interact with the server as follows.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the current state of the counter.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="st">&#39;Item &quot;Left ()&quot;&#39;</span> <span class="kw">|</span> <span class="ex">nc</span> 127.0.0.1 3000</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Item</span> <span class="st">&quot;Left 0&quot;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Increment the counter.</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="st">&#39;Item &quot;Right ()&quot;&#39;</span> <span class="kw">|</span> <span class="ex">nc</span> 127.0.0.1 3000</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Item</span> <span class="st">&quot;Right ()&quot;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the counter again.</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo <span class="st">&#39;Item &quot;Left ()&quot;&#39;</span> <span class="kw">|</span> <span class="ex">nc</span> 127.0.0.1 3000</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="ex">Item</span> <span class="st">&quot;Left 1&quot;</span></span></code></pre></div>
<p>In order to make life a bit easier for ourselves, we can implement a
simple TCP client in Haskell and use from another REPL to achieve the
same result.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV1</span>))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV1</span>))</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV1</span>))</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV1</span>))</span></code></pre></div>
<pre><code>Item &quot;Left 0&quot;               -- The initial value of the counter is 0.
Item &quot;Right ()&quot;             -- Two increments.
Item &quot;Right ()&quot;
Item &quot;Left 2&quot;               -- The value is now 2</code></pre>
<p>At this point, let’s imagine we want to add a reset feature to our
counter. Reset takes no argument and returns nothing, so we use the unit
type in both the input and output types.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">InputV2</span>  <span class="ot">=</span> <span class="dt">Either</span> () <span class="dt">InputV1</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">OutputV2</span> <span class="ot">=</span> <span class="dt">Either</span> () <span class="dt">OutputV1</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ResetCountV2</span><span class="ot"> ::</span> <span class="dt">InputV2</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ResetCountV2</span> <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV2</span><span class="ot"> ::</span> <span class="dt">InputV2</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV2</span>  <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">ReadCountV1</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">IncrCountV2</span><span class="ot"> ::</span> <span class="dt">InputV2</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">IncrCountV2</span>  <span class="ot">=</span> <span class="dt">Right</span> <span class="dt">IncrCountV1</span></span></code></pre></div>
<p>The state machine looks the same, except for the first
<code>Case</code> where we update the state to be <code>0</code>, thus
resetting the counter.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">counterV2 ::</span> <span class="dt">T</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>counterV2 <span class="ot">=</span> <span class="dt">Read</span> <span class="op">&gt;&gt;&gt;</span> counterV2&#39; <span class="op">&gt;&gt;&gt;</span> <span class="dt">Show</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    counterV2&#39; ::</span> <span class="dt">T</span> <span class="dt">Int</span> <span class="dt">InputV2</span> <span class="dt">OutputV2</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    counterV2&#39; <span class="ot">=</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Int</span> <span class="dv">0</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>) <span class="ot">`Case`</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Get</span> <span class="ot">`Case`</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Incr</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>)</span></code></pre></div>
<p>Back in our REPL we can now do the upgrade, by sending over a type
<code>erase</code>d version of <code>counterV2</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span><span class="ot"> msg ::</span> <span class="dt">Msg</span> ()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    msg <span class="ot">=</span> <span class="dt">Upgrade</span> <span class="dt">Nothing</span> <span class="st">&quot;counter&quot;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">UpgradeData_</span> <span class="dt">UTInt</span> <span class="dt">UTInt</span> <span class="dt">UTString</span> <span class="dt">UTString</span> (erase counterV2) (erase <span class="dt">Id</span>))</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> msg</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV2</span>))</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ResetCountV2</span>))</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV2</span>))</span></code></pre></div>
<p>Which yields the following annotated output.</p>
<pre><code>UpgradeSucceeded &quot;counter&quot;
Item &quot;Right (Left 2)&quot;   -- The counter&#39;s state is preserved by the upgrade.
Item &quot;Left ()&quot;          -- Reset the counter.
Item &quot;Right (Left 0)&quot;   -- The value is back to 0.</code></pre>
<p>As a final example of an upgrade, let’s do a more interesting state
migration. Let’s say we want to add a boolean to the state which
determines if <code>IncrCount</code> should add by <code>1</code> or
<code>-1</code> (i.e. decrement). This boolean can be toggled by the
user using a new operation, while the signatures of the other operations
stay the same as before.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">InputV3</span>  <span class="ot">=</span> <span class="dt">Either</span> () <span class="dt">InputV2</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">OutputV3</span> <span class="ot">=</span> <span class="dt">Either</span> () <span class="dt">OutputV2</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ToggleCountV3</span><span class="ot"> ::</span> <span class="dt">InputV3</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ToggleCountV3</span> <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ReadCountV3</span>, <span class="dt">IncrCountV3</span>, <span class="dt">ToggleCountV3</span><span class="ot"> ::</span> <span class="dt">InputV3</span></span></code></pre></div>
<p>In order to implement the toggle operation we need to extend the
syntax of our state machines to be able to deal with booleans and
products (the details can be found <a
href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/src/Interpreter.hs">here</a>).</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">counterV3 ::</span> <span class="dt">T</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>) <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>counterV3 <span class="ot">=</span> <span class="dt">Read</span> <span class="op">&gt;&gt;&gt;</span> counterV3&#39; <span class="op">&gt;&gt;&gt;</span> <span class="dt">Show</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    counterV3&#39; ::</span> <span class="dt">T</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>) <span class="dt">InputV3</span> <span class="dt">OutputV3</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    counterV3&#39; <span class="ot">=</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Toggle negates the boolean in the state (the second component).</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Second</span> <span class="dt">Not</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>) <span class="ot">`Case`</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Reset resets the counter and the boolean back to false (i.e. incrementing).</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Int</span> <span class="dv">0</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Bool</span> <span class="dt">False</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>) <span class="ot">`Case`</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Reading the counter picks out the first component from the state.</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Fst</span>) <span class="ot">`Case`</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Incrementing or decrementing, depending on the boolean in the state.</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">If</span> <span class="dt">Decr</span> <span class="dt">Incr</span> <span class="op">&gt;&gt;&gt;</span> (<span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> (<span class="dt">Consume</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Get</span> <span class="op">&gt;&gt;&gt;</span> <span class="dt">Snd</span>)) <span class="op">&gt;&gt;&gt;</span> <span class="dt">Put</span>)</span></code></pre></div>
<p>We can then upgrade to our new version of the counter as follows.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> msg2 ::</span> <span class="dt">Msg</span> ()</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>      msg2 <span class="ot">=</span> <span class="dt">Upgrade</span> <span class="dt">Nothing</span> <span class="st">&quot;counter&quot;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>               (<span class="dt">UpgradeData_</span> <span class="dt">UTInt</span> (<span class="dt">UTPair</span> <span class="dt">UTInt</span> <span class="dt">UTBool</span>) <span class="dt">UTString</span> <span class="dt">UTString</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>                 (erase counterV3) (erase (<span class="dt">Id</span> <span class="op">:&amp;&amp;&amp;</span> <span class="dt">Bool</span> <span class="dt">False</span>)))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> msg2</span></code></pre></div>
<p>Notice how the state is migrated using
<code>Id :&amp;&amp;&amp; Bool False</code>, i.e. create a pair where
the first component is the old value of the state (this is the current
count) and the second component is <code>False</code> (this is whether
we are decrementing).</p>
<p>Here’s a final example of how we can use the new counter.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV3</span>))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV3</span>))</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV3</span>))</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV3</span>))</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ToggleCountV3</span>))</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">IncrCountV3</span>))</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  nc <span class="st">&quot;127.0.0.1&quot;</span> <span class="dv">3000</span> (<span class="dt">Item</span> <span class="dt">Nothing</span> (<span class="fu">show</span> <span class="dt">ReadCountV3</span>))</span></code></pre></div>
<p>The above yields the following output.</p>
<pre><code>UpgradeSucceeded &quot;counter&quot;
Item &quot;Right (Right (Left 0))&quot;   -- The counter is 0.
Item &quot;Right (Right (Right ()))&quot; -- Two increments.
Item &quot;Right (Right (Right ()))&quot;
Item &quot;Right (Right (Left 2))&quot;   -- The counter is 2.
Item &quot;Left ()&quot;                  -- Toggle to decrementing.
Item &quot;Right (Right (Right ()))&quot; -- Decrement.
Item &quot;Right (Right (Left 1))&quot;   -- The value is 1.</code></pre>
</section>
</section>
<section id="discussion-and-future-work" class="level2">
<h2><a href="#discussion-and-future-work"
title="Discussion and future work">Discussion and future work</a></h2>
<p>If we look back at the list, from the introduction, of properties
that we wanted from our upgrades, then I hope that I’ve managed to
provide a glimpse of a possible way of achieving zero-downtime upgrades
with type-safe state migrations that are atomic.</p>
<p>Downgrades can be thought of as an upgrade to an earlier version,
although it could be interesting to experiment with requiring an inverse
function to the state migration as part of an upgrade. That way the
system itself could downgrade in case there’s more than N errors within
some time period, or something like that.</p>
<p>I didn’t talk about backwards and forwards compatibility. We could
probably use an <a
href="https://en.wikipedia.org/wiki/Interface_description_language">interface
description language</a>, such as Avro or Protobuf, but it could also be
interesting see if we could add input and output migrations as part of
upgrades (in addition to state migrations). Especially in conjunction
with being able to derive them generically and <a
href="https://www.manuelbaerenz.de/essence-of-live-coding/EssenceOfLiveCoding.pdf">automatically</a>
from the schema change.</p>
<p>There’s also a bunch of other <a
href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/TODO.md">things</a>
that I thought of while working on this, which I don’t have any good
answers for yet. If you feel that I’m missing something, or if you know
some answers or if any of these problems sound interesting to work on,
please do feel free to get in <a
href="https://stevana.github.io/about.html">touch</a>!</p>
<p>Let me close by trying to tie it back to Barbara Liskov’s remark
about the need for more complete programming languages. In a world where
software systems are expected to evolve over time, wouldn’t it be neat
if programming languages provided some notion of upgrade and could
typecheck our code <em>across versions</em>, as opposed to merely
typechecking a version of the code in isolation from the next?</p>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>State machines might seem like low-level clumsy way of
programming, but Yuri Gurevich has <a
href="https://www.microsoft.com/en-us/research/publication/103-evolving-algebras-1993-lipari-guide/">shown</a>
that abstract state machines (state machines where state can be any
first-order structure) can avoid the Turing tarpit and capture any
algorithm at any level of abstraction. This result is a generalisation
of the Church-Turing thesis from computable functions on natural numbers
to arbitrary sequential algorithms.</p>
<p>In case you’re not convinced by this theoretical argument, then here
are a couple of practical examples of state machine use from
industry.</p>
<p>In Joe Armstrong’s PhD <a
href="http://kth.diva-portal.org/smash/record.jsf?pid=diva2%3A9492&amp;dswid=-4551">thesis</a>
(2003), Joe gives an example of a big Ericsson telecommunications system
built in Erlang/OTP using a handful of library constructs (behaviours).
The most commonly used of these building blocks is
<code>gen_server</code>, which is a state machine. I’ve written a
high-level summary of the ideas over <a
href="https://stevana.github.io/erlangs_not_about_lightweight_processes_and_message_passing.html">here</a>,
although I recommend reading his thesis and forming your own
conclusions.</p>
<p>Leslie Lamport is another proponent of state machines. His TLA+ is
basically a language for describing state machines. See his article <a
href="https://www.microsoft.com/en-us/research/publication/computation-state-machines/"><em>Computation
and State Machines</em></a> (2008) for an introduction. Fault tolerance
in distributed systems is often realised by means of replicated state
machines, which Leslie helped develop back in the 80s.</p>
<p>Jean-Raymond Abrial’s B-method (a successor to Z notation) is also
centered around state machines and has been used to verify the automatic
Paris Métro lines 14 and 1 and the Ariane 5 rocket.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Many years ago I had the pleasure to study interaction
structures (aka index containers aka polynomial functors). One of many
possible way to view these structures is as if they are state machines.
One can construct a category with the objects being interaction
structures and then think about what the morphisms must look like in
order to satisfy the necessary categorical laws.</p>
<p>I don’t know much about category theory myself, but I remember that
the morphisms in the resulting category have two components and they
look exactly like those that we needed to be able to support backwards
compatibility.</p>
<p>There’s also a strong <a
href="https://arxiv.org/abs/0905.4063v1">connection</a> between this
category and stepwise refinement or refinement calculus, which at least
intuitively has some connection with upgrades.</p>
<p>I suppose that there are more useful ideas to steal from there.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This restriction makes it easier to make everything
deterministic, which in turn makes it easier to (simulation) test. I
touch upon this in an earlier <a
href="https://stevana.github.io/erlangs_not_about_lightweight_processes_and_message_passing.html">post</a>
towards the end. I hope to expand upon this in a separate post at some
point in the future.</p>
<p>It also make it possible for the implementation to be more efficient.
For example, if we want to have a pipeline that takes the output of one
state machine and broadcasts it to two other state machines (on the same
computer) then in Erlang the output would be copied to the two state
machines downstream, whereas with pipelines we can do it <a
href="https://stevana.github.io/parallel_stream_processing_with_zero-copy_fan-out_and_sharding.html">without
copying</a>.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>People familiar with Haskell’s ecosystem might recognise
that this is an instance of <a
href="https://hackage.haskell.org/package/base-4.19.1.0/docs/Control-Category.html"><code>Category</code></a>
and partially an instance of <a
href="https://github.com/stevana/hot-swapping-state-machines2/blob/main/src/Classes.hs#L13"><code>Cocartesian</code></a>,
plus some extras. In a “real” implementation we would want this datatype
to be an instance of <code>Cocartesian</code> instance as well as
<code>Cartesian</code>.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>
</body>
</html>
